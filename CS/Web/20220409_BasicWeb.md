# 반드시 알고 넘어가야 할 웹 기술 기초편
[Inflearn 강좌 페이지로 이동](https://www.inflearn.com/course/%EC%9B%B9-%EA%B8%B0%EC%88%A0-%EA%B8%B0%EC%B4%88#curriculum)

# 1. 웹의 탄생 그리고 발전
  
![image](https://user-images.githubusercontent.com/101965836/162576268-9e6a4e3c-2582-42f2-9b01-dcd1f74dd3ee.png)  
  
World Wide Web 속칭 \[따따따]   
네트워크 각각 단위가 모여서 거미줄 같다고 WEB 이라고 한다.  

## 웹의 탄생
CERN에서 동료들끼리 지식을 공유하고자 하이퍼텍스트 중심으로 구성. 멀리 떨어진 동료와 지식을 공유하고자 탄생.  
초기 웹은 이미지도 없이 단순히 텍스트로 구성되어 있었다. 하이퍼텍스트로 다른 페이지로 이동했다. 
하이퍼 텍스트는 초창기 웹부터 시작된 웹의 근본이다. 익히 알고있는 HTML HTTP의 이름에 둘 다 HT(HyperText)가 들어간다. 이처럼 하이퍼텍스트는 웹의 근본 그자체이다.   
  
## 웹브라우저 탄생과 발전
최초 웹브라우저는 1990년 팀 버너스 리에 의해 발명된 월드와이드웹이며 WWW와 구분을 위해 Nexus로 변경되었다. 이후 HTML CSS JS의 성장과 함께 다양한 웹브라우저가 등장해서 웹의 성장과 함께 웹브라우저도 성장해 나갔다.  

# 2. 웹을 구성하는 3대 요소
웹 기본 구조 클라이언트 - 서버 구조  
서버는 웹 서버 혹은 웹 어플리케이션 서버로 구분된다. WEB server 와 WEB App Server(WAS)로 구분된다.  
서버에 따라 PHP JSP(JAVA) ASP등 사용되는 언어가 다르다.  
클라이언트와 서버의 기준은 서비스를 제공해주는 서버와 제공 받는 클라이언트로 구분된다. (구분 기준 : 서비스를 제공 하냐 제공 받냐)  

## 클라이언트/서버 통신 원리
![image](https://user-images.githubusercontent.com/101965836/162577816-bb3515e8-7333-4881-99b1-01fc1a13430c.png)    
클라이언트는 서비스를 달라고 요청하는 HTTP Request Message를 서버에 보낸다.  
서버는 클라이언트의 요청에 따라서 응답하는 HTTP Response Message를 클라이언트에 보낸다.  
  
  
## 웹의 3대 요소
HTML HTTP URL 웹의 가장 중요한 3요소
HTTP(HyperText Transfer Protocol)는 웹서버와 웹클라이언트간 통신을 할 수 있도록 기준을 잡아준다. Response Message와 Request Message의 양식도 HTTP에서 지정하는 통신 규약 안에 포함되어있다. 마치 하나의 언어처럼, 서로 다른 사람이 의사소통하기 위해서 서로 HTTP라는 언어를 사용하겠다는 규칙같은거다. 어떤식으로 Request 할 지 규칙이 있어야지 알아듣고 Response 할 수 있기때문에, 이를 표준으로 정한것이 HTTP라는 것이라고 생각하면 되겠다.  
URL(Uniform Resource Locator)은 서버에 자원을 요청할 수 있게 해준다. 내가 어떤 자원을 원한다 라는 것을 요청해야 하기 때문에 URL이라는 개념이 필요하다. 서버에 정확히 어떤 웹 페이지를 달라고 요청하는 것이다.   
HTML(HyperText Markup Language)은 페이지를 어떻게 구성하는지, 어디에 어떤 콘텐츠를 놓을지를 정하는 마크업 언어다. HTTP에 따라서 Request가 왔고, 어떤 페이지를 달라고하는 URL을 봤다면 웹서버는 그에 맞는 페이지를 전달해 줘야 한다. 이 때 HTML로 페이지를 구성하여 클라이언트에게 전달하게되며, HTML이 페이지에서 뭐가 어디에 위치하는지등의 정보를 담게된다.   
  
이렇게 웹의 3대 요소가 어우러져서 HTTP로 Message를 주고받고, URL로 구체적인 페이지를 명시하며, HTML로 페이지를 구성하게 되는 것이다.  
  
  
# 3. 자원을 지정하는 URL
URL(Uniform Resource Locator) 통합 자원 지시자  
인터넷 상의 모든 리소스를 요청할 수 있다. HTTP 뿐만 아니라 FTP, SMTP등 관련된 자원 요청도 가능하다.  

## 동작 원리
![image](https://user-images.githubusercontent.com/101965836/162578279-f37fae5a-5fea-4210-b895-209bad48b43f.png)  
요청 URL을 보면 /img/logo.png로 되어있다. (이는, 웹 서버 파일체계에 따라 물론 달라지지만, 가장 단순히 이해할 수 있는 형태로 설명)  
메인 루트 아래에 img 폴더에 logo.png파일을 요청하는 것이다. 그러면 웹서버는 Response로 해당 이미지를 파일 시스템에서 찾아서 HTTP에 실어서 보내줄 것이다.   
 
 
## URL 구조 분석
![image](https://user-images.githubusercontent.com/101965836/162578350-98c7dc97-cdf7-40ff-8111-b93dd0ec9e8e.png)  
(1) 스키마 부분  
어떤 프로토콜을 사용하는지 명시해준다. http에 security를 보완한 https를 오늘날 많이들 쓰며, 이외에서 ftp등이 있다. 프로토콜 뒤에는 :이 붙는다.  
(2) 서버 주소 (호스트)  
자원을 가진 컴퓨터의 위치가 명시되어 있다. 도메인이 나와있지만 실제로는 IP가 된다. 기본적으로 포트가 명시되어있지 않으면 80포트이다. ex. ww\w.test.co.kr:8080   
(3) 디렉토리 (4) 자원의 이름
  
## 자원을 지정하지 않으면?
htt\p://ww\w.test.co.kr/ 같은 식으로 자원을 명시하지 않으면, 웹서버에 기본 설정된 자원이 호출된다. 대부분 index페이지가 호출된다.   
  
  
## URL 예약 문자
|문자|인코딩|
|----|-----|
|?|파라미터가 시작 된다는 것을 알려줌|
|=| 파라미터 값 대입|
|&|다음 파라미터 식별자|
|+|공백|
|!\*\'(\)\;\:\@\$,/\#\[\]|그 외 문자들|

![image](https://user-images.githubusercontent.com/101965836/162578753-686996a7-d2f0-49ba-817f-5c83492b8203.png)  
  
  
예를 들어 get방식으로 요청 할 경우 자원과 사용자 입력값을 구분하는 기준이 ?가 된다. ?이후 파라미터 명이 나오고 값이 나온다.
ex. ?val=hello+world&a=1  
  
  
## 예약 문자가 들어갈 경우 어떻게 전송이 될까?
& # + 같은 예약 문자를 전송할려면? URL 인코딩을 사용하게 된다.  
  
## URL 인코딩
![image](https://user-images.githubusercontent.com/101965836/162578877-d998ff7c-5272-42cd-bcaa-5fce150a05d0.png)   
웹 브라우저가 자동으로 위의 URL인코딩으로 변환하여 전송해준다.  

# 4. 웹의 핵심 기술 HTTP 프로토콜
팀 버너스 리 박사에 의해 개발. 통신규악으로 웹의 핵심 기술이다. HTTP의 버전은 0.9 1.0 1.0+ 1.1 2.0 이렇게 5가지로 나눌 수 있다.  

## HTTP/0.9
정식 사양으로 등록되기 전 버전이란 의미로 0.9로 명명했다. 단순히 GET 메소드만 지원했으며 특별한 기능이 없었다. 

## HTTP/1.0
정식 사양으로 등록. RFC1945가 발행되었다. POST, HEAD메소드, 헤더를 지원한다. 요청의 결과를 알 수 있는 상태코드가 추가되었다. 상태코드는 클라이언트가 요청을 하였을 때 서버가 어떻게 처리했고 어떤 상태인지 등을 알려주는 내용을 담는다. 또한 HTML 문서 외에 다른 파일들도 전송이 가능하게 되었다. 그러나 요청마다 새로운 연결을 맺고 끊고 다시 새로운 연결을 맺는 비효율적인 '비연결지향(Connectionless)방식'을 사용했다. 

## HTTP/1.0+
비효율적인 '비연결지향' 문제를 해결하기 위해 +를 추가하여 'Keep-Alive 커넥션'을 지원하기 시작했다.  

## HTTP/1.1
현재 가장 많이 사용되고 있는 버전이다. 설계문제나 성능 최적화가 진행되었다. 1.1부터는 'Keep-Alive 커넥션'이 기본으로 되었다. 모든 요청이 끝나면 "Connection:close" 헤더를 통해 연결 종료를 알린다. 또한 기존에 GET POST HEAD 3가지 뿐이었던 메소드가, OPTIONS PUT DELETE등 많은 메소드가 추가되었다.  

## HTTP/2.0
기존에는 웹 하나 페이지를 보기 위해서 수십개의 요청을 주고받아야 했었다. 이는 HTTP의 성능 문제를 야기했고, 이를 보완하고자 성능문제를 해결하기 위한 HTTP/2.0이 등장하였다. 성능 향상에 초점을 두고, 멀티플렉싱 스트림, 헤더 압축, 서버 푸시등의 기능이 추가되었다. 2015년에 HTTP/2.0을 공식 발표하였으나, 아직 대부분은 HTTP/1.1을 사용중이다. Google 계열 사이트는 HTTP/2.0을 지원하고 있으나, 국내 사이트들은 아직 대부분 1.1만 지원한다.  
  
  
## TCP/IP에 대한 이해
인터넷을 이용해 TCP/IP 기반 통신을 하며 대부분 네트워크는 TCP/IP 기반을 근간으로 한다. 자세한 내용은 굉장히 복잡하게 들어가서 간략하게만 짚고 넘어가자. 우선 IP는 그냥 목적지 주소만 알려주는 역할이다. 따라서 패킷이 어쩌고 저쩌고 하는 내용은 IP는 전혀 모른다. TCP는 패킷 교환 방식의 데이터 통신 연구에 따라 나온 방식이다. 어쩌고 저쩌고 복잡하지만 일단 기초 학습이니까 간략히만 알아보자. TCP로 데이터를 주고받기 이전에 서로 연결됐는지 설정하는 과정에서 Three Way Handshake 방식으로 연결한다.   
1. 나 A인데 B랑 통신하고 싶어(SYN)   
2. 나 B인데 나도 A 너랑 통신하고싶어, 그리고 지금 통신 할 준비 끝났어(SYN-ACK)   
3. 나 A인데 나도 B 너랑 통신 할 준비 끝났어(ACK)   
  
이렇게 연결 설정을 마친다.  
그 다음 TCP 규약에 따라 데이터를 서로 전송하는데 TCP는 데이터가 형식에 맞춰서 제대로 수신됐는지 확인하는 과정을 거치는 특징을 가진다.   

  
  
## 연결 관리 방식
크게 비 지속 연결 (Non-Persistent Connection)과 지속 연결 (Persistent Connection) 두 가지로 나뉜다.  


## 비 지속 연결
초창기에는 단순히 문서를 주고받는 식이었기에 지속 연결이 필요하지 않았다. 그러나 오늘날에는 많은 리소스가 필요하기 때문에 지속적으로 연결된 상태를 유지할 필요가 있어졌다.  
![image](https://user-images.githubusercontent.com/101965836/162580727-7a0a3720-551e-4d42-b936-485eb51d5215.png)  
위 이미지처럼 파일 하나를 받을 때 마다 새롭게 연결하는 방식은 비효율적이다.   
  
  
## 지속 연결
![image](https://user-images.githubusercontent.com/101965836/162580764-675cc9f1-1b51-4fa2-8613-e509fbfcc9f0.png)  
지속 연결을 사용하게 되면 연결을 맺고 끊고 하는 과정이 일어나지 않기 때문에 시간이 확연하게 단축이 된다.  


## HTTP 메시지 - 메시지 구조
![image](https://user-images.githubusercontent.com/101965836/162580888-7c64be55-98f0-4451-9573-cbc81615d586.png)  
HTTP 메시지 구조는 Request Response 둘 다 동일하게 위 이미지와 같은 형식이다. 

## HTTP 메시지 - 개행 문자
하나의 문서가 끝났다는 기준이 된다.  OS나 프로토콜마다 다른데, HTTP와 같은 인터넷 프로토콜의 경우 ASCII의 CR + LF 를 개행문자로 사용하도록 규정한다.  ( \\r\\n )  
  
## HTTP 메시지 - 요청 메시지(Request Message)
![image](https://user-images.githubusercontent.com/101965836/162581038-483b26bc-6290-4aa2-b8a0-d48c282bcd3c.png)  
  
## HTTP 메시지 - 응답 메시지(Request Message)
![image](https://user-images.githubusercontent.com/101965836/162581074-88e0c27e-8c58-4bbc-be8b-6be36b931ede.png)  

## HTTP 메소드 - GET/POST
![image](https://user-images.githubusercontent.com/101965836/162581173-33f9638e-722e-481a-80e3-780c1f1e3c2b.png)  
GET은 URL을 통해서 정보를 보내기 때문에 단순히 자원을 받을때만 안된다. GET방식으로 삭제 같은 것을 만들면 URL을 통해서 다시 접근할 수 있기 때문에, 삭제 수정 생성에 GET을 쓰면 안된다.    
POST에서는 Content-Type이라는게 있는데 이게 중요하다. 정상적으로 POST 방식이 해석이 될려면 Content-Type이 제대로 나와야지 해석될 수 있다.

## HTTP 상태 코드
![image](https://user-images.githubusercontent.com/101965836/162581289-c6baff52-6362-496c-8f6e-596cf11a3ad4.png)  
3자리 숫자와 응답 문구로 구성된다.  
대표적인 상태 코드 정도만 좀 알아두면 된다.  
