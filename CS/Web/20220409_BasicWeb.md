# 반드시 알고 넘어가야 할 웹 기술 기초편
[Inflearn 강좌 페이지로 이동](https://www.inflearn.com/course/%EC%9B%B9-%EA%B8%B0%EC%88%A0-%EA%B8%B0%EC%B4%88#curriculum)

# 1. 웹의 탄생 그리고 발전
  
![image](https://user-images.githubusercontent.com/101965836/162576268-9e6a4e3c-2582-42f2-9b01-dcd1f74dd3ee.png)  
  
World Wide Web 속칭 \[따따따]   
네트워크 각각 단위가 모여서 거미줄 같다고 WEB 이라고 한다.  

## 웹의 탄생
CERN에서 동료들끼리 지식을 공유하고자 하이퍼텍스트 중심으로 구성. 멀리 떨어진 동료와 지식을 공유하고자 탄생.  
초기 웹은 이미지도 없이 단순히 텍스트로 구성되어 있었다. 하이퍼텍스트로 다른 페이지로 이동했다. 
하이퍼 텍스트는 초창기 웹부터 시작된 웹의 근본이다. 익히 알고있는 HTML HTTP의 이름에 둘 다 HT(HyperText)가 들어간다. 이처럼 하이퍼텍스트는 웹의 근본 그자체이다.   
  
## 웹브라우저 탄생과 발전
최초 웹브라우저는 1990년 팀 버너스 리에 의해 발명된 월드와이드웹이며 WWW와 구분을 위해 Nexus로 변경되었다. 이후 HTML CSS JS의 성장과 함께 다양한 웹브라우저가 등장해서 웹의 성장과 함께 웹브라우저도 성장해 나갔다.  

# 2. 웹을 구성하는 3대 요소
웹 기본 구조 클라이언트 - 서버 구조  
서버는 웹 서버 혹은 웹 어플리케이션 서버로 구분된다. WEB server 와 WEB App Server(WAS)로 구분된다.  
서버에 따라 PHP JSP(JAVA) ASP등 사용되는 언어가 다르다.  
클라이언트와 서버의 기준은 서비스를 제공해주는 서버와 제공 받는 클라이언트로 구분된다. (구분 기준 : 서비스를 제공 하냐 제공 받냐)  

## 클라이언트/서버 통신 원리
![image](https://user-images.githubusercontent.com/101965836/162577816-bb3515e8-7333-4881-99b1-01fc1a13430c.png)    
클라이언트는 서비스를 달라고 요청하는 HTTP Request Message를 서버에 보낸다.  
서버는 클라이언트의 요청에 따라서 응답하는 HTTP Response Message를 클라이언트에 보낸다.  
  
  
## 웹의 3대 요소
HTML HTTP URL 웹의 가장 중요한 3요소
HTTP(HyperText Transfer Protocol)는 웹서버와 웹클라이언트간 통신을 할 수 있도록 기준을 잡아준다. Response Message와 Request Message의 양식도 HTTP에서 지정하는 통신 규약 안에 포함되어있다. 마치 하나의 언어처럼, 서로 다른 사람이 의사소통하기 위해서 서로 HTTP라는 언어를 사용하겠다는 규칙같은거다. 어떤식으로 Request 할 지 규칙이 있어야지 알아듣고 Response 할 수 있기때문에, 이를 표준으로 정한것이 HTTP라는 것이라고 생각하면 되겠다.  
URL(Uniform Resource Locator)은 서버에 자원을 요청할 수 있게 해준다. 내가 어떤 자원을 원한다 라는 것을 요청해야 하기 때문에 URL이라는 개념이 필요하다. 서버에 정확히 어떤 웹 페이지를 달라고 요청하는 것이다.   
HTML(HyperText Markup Language)은 페이지를 어떻게 구성하는지, 어디에 어떤 콘텐츠를 놓을지를 정하는 마크업 언어다. HTTP에 따라서 Request가 왔고, 어떤 페이지를 달라고하는 URL을 봤다면 웹서버는 그에 맞는 페이지를 전달해 줘야 한다. 이 때 HTML로 페이지를 구성하여 클라이언트에게 전달하게되며, HTML이 페이지에서 뭐가 어디에 위치하는지등의 정보를 담게된다.   
  
이렇게 웹의 3대 요소가 어우러져서 HTTP로 Message를 주고받고, URL로 구체적인 페이지를 명시하며, HTML로 페이지를 구성하게 되는 것이다.  
  
  
# 3. 자원을 지정하는 URL
URL(Uniform Resource Locator) 통합 자원 지시자  
인터넷 상의 모든 리소스를 요청할 수 있다. HTTP 뿐만 아니라 FTP, SMTP등 관련된 자원 요청도 가능하다.  

## 동작 원리
![image](https://user-images.githubusercontent.com/101965836/162578279-f37fae5a-5fea-4210-b895-209bad48b43f.png)  
요청 URL을 보면 /img/logo.png로 되어있다. (이는, 웹 서버 파일체계에 따라 물론 달라지지만, 가장 단순히 이해할 수 있는 형태로 설명)  
메인 루트 아래에 img 폴더에 logo.png파일을 요청하는 것이다. 그러면 웹서버는 Response로 해당 이미지를 파일 시스템에서 찾아서 HTTP에 실어서 보내줄 것이다.   
 
 
## URL 구조 분석
![image](https://user-images.githubusercontent.com/101965836/162578350-98c7dc97-cdf7-40ff-8111-b93dd0ec9e8e.png)  
(1) 스키마 부분  
어떤 프로토콜을 사용하는지 명시해준다. http에 security를 보완한 https를 오늘날 많이들 쓰며, 이외에서 ftp등이 있다. 프로토콜 뒤에는 :이 붙는다.  
(2) 서버 주소 (호스트)  
자원을 가진 컴퓨터의 위치가 명시되어 있다. 도메인이 나와있지만 실제로는 IP가 된다. 기본적으로 포트가 명시되어있지 않으면 80포트이다. ex. ww\w.test.co.kr:8080   
(3) 디렉토리 (4) 자원의 이름
  
## 자원을 지정하지 않으면?
htt\p://ww\w.test.co.kr/ 같은 식으로 자원을 명시하지 않으면, 웹서버에 기본 설정된 자원이 호출된다. 대부분 index페이지가 호출된다.   
  
  
## URL 예약 문자
|문자|인코딩|
|----|-----|
|?|파라미터가 시작 된다는 것을 알려줌|
|=| 파라미터 값 대입|
|&|다음 파라미터 식별자|
|+|공백|
|!\*\'(\)\;\:\@\$,/\#\[\]|그 외 문자들|

![image](https://user-images.githubusercontent.com/101965836/162578753-686996a7-d2f0-49ba-817f-5c83492b8203.png)  
  
  
예를 들어 get방식으로 요청 할 경우 자원과 사용자 입력값을 구분하는 기준이 ?가 된다. ?이후 파라미터 명이 나오고 값이 나온다.
ex. ?val=hello+world&a=1  
  
  
## 예약 문자가 들어갈 경우 어떻게 전송이 될까?
& # + 같은 예약 문자를 전송할려면? URL 인코딩을 사용하게 된다.  
  
## URL 인코딩
![image](https://user-images.githubusercontent.com/101965836/162578877-d998ff7c-5272-42cd-bcaa-5fce150a05d0.png)   
웹 브라우저가 자동으로 위의 URL인코딩으로 변환하여 전송해준다.  

# 4. 웹의 핵심 기술 HTTP 프로토콜
팀 버너스 리 박사에 의해 개발. 통신규악으로 웹의 핵심 기술이다. HTTP의 버전은 0.9 1.0 1.0+ 1.1 2.0 이렇게 5가지로 나눌 수 있다.  

## HTTP/0.9
정식 사양으로 등록되기 전 버전이란 의미로 0.9로 명명했다. 단순히 GET 메소드만 지원했으며 특별한 기능이 없었다. 

## HTTP/1.0
정식 사양으로 등록. RFC1945가 발행되었다. POST, HEAD메소드, 헤더를 지원한다. 요청의 결과를 알 수 있는 상태코드가 추가되었다. 상태코드는 클라이언트가 요청을 하였을 때 서버가 어떻게 처리했고 어떤 상태인지 등을 알려주는 내용을 담는다. 또한 HTML 문서 외에 다른 파일들도 전송이 가능하게 되었다. 그러나 요청마다 새로운 연결을 맺고 끊고 다시 새로운 연결을 맺는 비효율적인 '비연결지향(Connectionless)방식'을 사용했다. 

## HTTP/1.0+
비효율적인 '비연결지향' 문제를 해결하기 위해 +를 추가하여 'Keep-Alive 커넥션'을 지원하기 시작했다.  

## HTTP/1.1
현재 가장 많이 사용되고 있는 버전이다. 설계문제나 성능 최적화가 진행되었다. 1.1부터는 'Keep-Alive 커넥션'이 기본으로 되었다. 모든 요청이 끝나면 "Connection:close" 헤더를 통해 연결 종료를 알린다. 또한 기존에 GET POST HEAD 3가지 뿐이었던 메소드가, OPTIONS PUT DELETE등 많은 메소드가 추가되었다.  

## HTTP/2.0
기존에는 웹 하나 페이지를 보기 위해서 수십개의 요청을 주고받아야 했었다. 이는 HTTP의 성능 문제를 야기했고, 이를 보완하고자 성능문제를 해결하기 위한 HTTP/2.0이 등장하였다. 성능 향상에 초점을 두고, 멀티플렉싱 스트림, 헤더 압축, 서버 푸시등의 기능이 추가되었다. 2015년에 HTTP/2.0을 공식 발표하였으나, 아직 대부분은 HTTP/1.1을 사용중이다. Google 계열 사이트는 HTTP/2.0을 지원하고 있으나, 국내 사이트들은 아직 대부분 1.1만 지원한다.  
  
  
## TCP/IP에 대한 이해
인터넷을 이용해 TCP/IP 기반 통신을 하며 대부분 네트워크는 TCP/IP 기반을 근간으로 한다. 자세한 내용은 굉장히 복잡하게 들어가서 간략하게만 짚고 넘어가자. 우선 IP는 그냥 목적지 주소만 알려주는 역할이다. 따라서 패킷이 어쩌고 저쩌고 하는 내용은 IP는 전혀 모른다. TCP는 패킷 교환 방식의 데이터 통신 연구에 따라 나온 방식이다. 어쩌고 저쩌고 복잡하지만 일단 기초 학습이니까 간략히만 알아보자. TCP로 데이터를 주고받기 이전에 서로 연결됐는지 설정하는 과정에서 Three Way Handshake 방식으로 연결한다.   
1. 나 A인데 B랑 통신하고 싶어(SYN)   
2. 나 B인데 나도 A 너랑 통신하고싶어, 그리고 지금 통신 할 준비 끝났어(SYN-ACK)   
3. 나 A인데 나도 B 너랑 통신 할 준비 끝났어(ACK)   
  
이렇게 연결 설정을 마친다.  
그 다음 TCP 규약에 따라 데이터를 서로 전송하는데 TCP는 데이터가 형식에 맞춰서 제대로 수신됐는지 확인하는 과정을 거치는 특징을 가진다.   

  
  
## 연결 관리 방식
크게 비 지속 연결 (Non-Persistent Connection)과 지속 연결 (Persistent Connection) 두 가지로 나뉜다.  


## 비 지속 연결
초창기에는 단순히 문서를 주고받는 식이었기에 지속 연결이 필요하지 않았다. 그러나 오늘날에는 많은 리소스가 필요하기 때문에 지속적으로 연결된 상태를 유지할 필요가 있어졌다.  
![image](https://user-images.githubusercontent.com/101965836/162580727-7a0a3720-551e-4d42-b936-485eb51d5215.png)  
위 이미지처럼 파일 하나를 받을 때 마다 새롭게 연결하는 방식은 비효율적이다.   
  
  
## 지속 연결
![image](https://user-images.githubusercontent.com/101965836/162580764-675cc9f1-1b51-4fa2-8613-e509fbfcc9f0.png)  
지속 연결을 사용하게 되면 연결을 맺고 끊고 하는 과정이 일어나지 않기 때문에 시간이 확연하게 단축이 된다.  


## HTTP 메시지 - 메시지 구조
![image](https://user-images.githubusercontent.com/101965836/162580888-7c64be55-98f0-4451-9573-cbc81615d586.png)  
HTTP 메시지 구조는 Request Response 둘 다 동일하게 위 이미지와 같은 형식이다. 

## HTTP 메시지 - 개행 문자
하나의 문서가 끝났다는 기준이 된다.  OS나 프로토콜마다 다른데, HTTP와 같은 인터넷 프로토콜의 경우 ASCII의 CR + LF 를 개행문자로 사용하도록 규정한다.  ( \\r\\n )  
  
## HTTP 메시지 - 요청 메시지(Request Message)
![image](https://user-images.githubusercontent.com/101965836/162581038-483b26bc-6290-4aa2-b8a0-d48c282bcd3c.png)  
  
## HTTP 메시지 - 응답 메시지(Request Message)
![image](https://user-images.githubusercontent.com/101965836/162581074-88e0c27e-8c58-4bbc-be8b-6be36b931ede.png)  

## HTTP 메소드 - GET/POST
![image](https://user-images.githubusercontent.com/101965836/162581173-33f9638e-722e-481a-80e3-780c1f1e3c2b.png)  
GET은 URL을 통해서 정보를 보내기 때문에 단순히 자원을 받을때만 안된다. GET방식으로 삭제 같은 것을 만들면 URL을 통해서 다시 접근할 수 있기 때문에, 삭제 수정 생성에 GET을 쓰면 안된다.    
POST에서는 Content-Type이라는게 있는데 이게 중요하다. 정상적으로 POST 방식이 해석이 될려면 Content-Type이 제대로 나와야지 해석될 수 있다.

## HTTP 상태 코드
![image](https://user-images.githubusercontent.com/101965836/162581289-c6baff52-6362-496c-8f6e-596cf11a3ad4.png)  
3자리 숫자와 응답 문구로 구성된다.  
대표적인 상태 코드 정도만 좀 알아두면 된다.  

# 5 쿠키와 세션

상태 유지 및 관리의 필요성. 
쇼핑몰을 사용하는 상황을 가정해보자. 쇼핑몰에서 장바구니에 상품을 담은 다음에, 다른 상품을 둘러보는 중에도 장바구니에 상품은 그대로 있다. 또 결제 창이라던가 지난번에 담았던 장바구니의 상품을 확인 할 때 등 인증이 필요한 페이지에 여러번 접근해도, 한 번 로그인 한것이 유지되어서 계속 둘러볼 수 있게된다. 이렇게 사용자의 상태를 유지할 수 있도록 하는데 쿠키가 사용된다.  

## 쿠키
쿠키는 크게 (1) 지속 쿠키 (2) 세션 쿠키로 나뉜다.  
일반적으로 말하는 쿠키는 지속 쿠키이며, 세션이라고 하는 것은 세션 쿠키를 말한다.  

## 쿠키 헤더 구조
![image](https://user-images.githubusercontent.com/101965836/162734615-fa3ef0fe-3d13-4bf9-9ce5-9d8a0c5fb3c1.png)  
쿠키는 발급 시 Set-Cookie 헤더로 클라이언트 쿠키 값이 세팅된다. 사이트에 접근 시 마다 클라이언트는 Set-Cookie에 의해 세팅된 값을 Cookie 헤더에 세팅하여 요청 메시지를 전달한다. 서버는 이를 통해 상태 관리를 한다.  

## (1) 지속 쿠키
지속 쿠키는 클라이언트의 하드 디스크에 텍스트 형태로 저장된다. 클라이언트 pc 사용자들도 쿠키 정보를 열람할 수 있다. 옛날에는 이렇게 하드디스크에 저장되는 부분 때문에 보안상 문제가 되었는데 오늘날에는 보안도 발달하여 이부분의 보안 위협이 과거보단 낮아졌다.

### 지속 쿠키 - 쿠키 발급 과정

#### (1) 사용자가 쿠키 발급 요청
로그인 정보를 입력하면 사용자가 로그인 시도를 했음을 서버로 보낸다  
![image](https://user-images.githubusercontent.com/101965836/162735505-ff0d6b85-36f1-4e5f-8163-cc5db0f4d9bf.png)  
아이디 패스워드가 정상적이면, 서버의 쿠키 로직이 작동하여 쿠키를 발급한다.  
  
#### (2) 서버가 쿠키 발급해서 전달
![image](https://user-images.githubusercontent.com/101965836/162737610-720f0475-4206-400a-bdee-ebf2f63b2dbb.png)  
서버에서 생성한 쿠키를 사용자에게 전달한다. 사용자는 쿠키를 받아서 사이트에다가 쿠키를 세팅한다.  

#### (3) 사용자가 쿠키 사용시
![image](https://user-images.githubusercontent.com/101965836/162738227-92a3a51d-6fec-4793-aad9-36fdc87a6da0.png)   
사용자가 갖고 있던 쿠키 값으로 서버에다가 요청을 보낸다. 서버는 쿠키 요청을 받아서 사용자를 식별하고, 사용자의 쿠키에 맞게 페이지를 생성해서 다시 보내준다.  

#### (4) 쿠키 폐기 과정
![image](https://user-images.githubusercontent.com/101965836/162738809-8d76f8a7-a172-4001-8baa-67e7c58f611f.png)   
사용자가 어떤 쿠키를 폐기하려고 하는지 정보를 담아서 서버로 보낸다. 위 이미지의 경우 id=hong123 쿠키를 폐기한다고 서버에 요청을 보낸다.   
서버는 id=deleted 라는 응답을 다시 사용자에게 보내며, id=deleted가 사용자에게 전달되면 사용자는 쿠키를 폐기하게 된다.  

### 지속 쿠키 문제점
(1) 재사용 문제
쿠키를 폐기 하여도 해당 값을 알고 있으면 재사용이 가능하다.
(2) 변조 위협
쿠키 값이 평문일 경우 변조의 위협이 있다. 따라서 사용자 식별 및 인증 관련 내용은 반드시 암호화 해야한다. 
특히 **양방향 암호화 알고리즘** 을 사용해야하며, **비밀 키 관리** 에 대해서도 고려해야 한다. 
(3) 유효기간, 폐기방법 등 로직의 문제
지속 쿠키의 다양한 문제점들을 고려해서 쿠키 발급 로직을 잘 만들어야 한다. 재사용이나 보안상 위협이 잔존할 수 있다.
특히 지속 쿠키의 보안 취약점 문제는 실제로도 골머리를 앓는 부분 중 하나다.

## (2) 세션 쿠키
웹 서버에서 발급시 클라이언트에서 쿠키는 **웹 브라우저 캐시에** 저장되고, 서버에서 세션에 대한 정보는 서버의 메모리, 파일 시스템, 데이터베이스 중 서버 로직에 따라 적절한 위치에 저장된다. 일반적으로 메모리에 저장해둔다.  
또한 세션은 정보를 암호화 또는 난독화 한 정보가 아니다. 세션은 단지 무작위로 나열된 정보를 담은 것이다. 예를 들어 '홍길동'이 'hong'이라는 아이디의 로그인 세션 쿠키를 발급 받았다고 해보자. 그러면 세션을 발급 할 때, 'hong'이나 '홍길동'등 사용자의 정보와 관련된 내용을 암호화나 복호화 해서 발급하는게 아니다. 그냥 '#S%12TD9%'같은 무작위 문자열을 생성해서 세션을 발급한다. 따라서 공격자는 특성 사용자의 세션을 맞추기 어렵게 된다.  

### 세션 쿠키 - 세션 발급 과정

#### (1) 사용자가 세션 발급 요청
![image](https://user-images.githubusercontent.com/101965836/162741594-007bfda7-062f-4f11-9d68-4a7399ed1d88.png)  
사용자가 로그인을 하면 서버는 로그인이 유효한지 검사하고, 이후 세션을 발급해서 서버에 세션 값과 어떤 내용인지를 저장한다.  

#### (2) 서버가 세션을 클라이언트에 전달
![image](https://user-images.githubusercontent.com/101965836/162741768-ab3d6f23-6d4c-4a42-98c0-adb719de5df8.png)  
서버는 발급한 세션을 사용자에게 전달하고, 사용자는 세션 값을 받아서 브라우저의 캐시에 저장해둔다.

#### (3) 사용자가 세션 사용시
![image](https://user-images.githubusercontent.com/101965836/162742130-34d0cee9-4846-4c48-a8a5-54f1a73ff8d2.png)  
사용자는 헤더에 세션 값을 담아서 서버에 요청하게되고, 서버는 저장된 세션 값과 어떤 내용인지를 적어둔 데이터를 확인하고 "아 이게 hong의 로그인 정보구나" 같은 식으로 해석한다.  

#### (4) 세션 폐기 과정
![image](https://user-images.githubusercontent.com/101965836/162742652-b100768b-141e-4f64-9a0b-6a9f4402783b.png)  
사용자가 세션 삭제 요청을 보내면, 서버는 사용자에 보관된 세션을 삭제하는 게 아니라, 서버에 있는 세션 정보를 삭제한다. 그러면 이제 사용자가 갖고 있는 세션은 '유효하지 않은 세션'이 된다. 따라서 **세션은 재사용 문제가 없다.**

### 세션 쿠키 문제점
세션을 사용하면 지속 쿠키의 문제점을 대부분 해결할 수 있다. 그러나 세션 쿠키는 **서버 부하 문제를 갖고 있다.**   
대규모 시스템이라면, 메모리에서 모든 세션 쿠키를 보관하기에 부담스럽다. 그렇다고 DB에다가 보관하기에는 속도가 너무 느리다. 따라서 성능 문제 때문에 지속 쿠키를 사용하게 된다.  
대규모 서비스 입장에서는 암호화 복호화 로직만 서버에서 계산하면 되기 때문에 지속 쿠키를 사용하는 편이 훨씬 성능상 이점을 가져온다.  

# 결론 
웹 서비스와 인프라 구성에 따라서 알맞게 사용해야 한다.   
사용자가 많은가? 복잡하게 암호화 복호화 로직을 구현하면서 지속 쿠키를 쓸 필요가 있는가? 등을 고려하면서 뭐를 쓸지 생각해야 한다.  
  
  
# 6 웹 아키텍처

## 웹 아키텍처
![image](https://user-images.githubusercontent.com/101965836/162743905-4c503043-38e7-441b-b928-1af07deb0541.png)  
간략화 시켜서 클라이언트 - 웹 서버 - DB 형태로 구성된다. 영역별로는 프론트엔드 백엔드로 나뉜다. 실 환경은 이보다 훨씬 복잡하다.  
  
## 동작 원리 분석
