[참고한 글1 - 2진수의 수와 음수 표현법](https://st-lab.tistory.com/189)  
[참고한 글2 - 보수(Complement)와 보수 뺄셈에 대한 정말 쉬운 설명](https://songios.tistory.com/12)  
  
# 의문. Int에서 음수 표기법은?
  
|0|0|0|0|0|0|0|0|
|---|---|---|---|---|---|---|---|  
  
이건 **0**이다  
  
  
|0|0|0|0|0|0|0|1|
|---|---|---|---|---|---|---|---|  
  
이건 **1**이다  
  
  <br><br>  
  
## 그러면 -1은 ??
  
|0|0|0|0|0|0|0|1|
|---|---|---|---|---|---|---|---|  
    
이게 +1 이니까  
-1이면 제일 앞부분 **부호비트**만 살짝 바꿔서    
**1 0 0 0 0 0 0 1** 일까?  
  
### 아니다 -1은 아래와 같다  
  
|1|1|1|1|1|1|1|1|
|---|---|---|---|---|---|---|---|  
    
  
왜 이런식일까?  
  
<br><br><br>  
  
# 2의 보수 
  
## 먼저 보수란  

N의 보수 라고 하면  
N을 만들기 위해서 더해야 하는 수  
를 말한다.  
    
ex1. **3**에 대한 **10의 보수**는 **7**이다  
  
<br><br>  
  
## x진수에서 N의 보수  
  
익숙한 10진수에서 먼저 보자  
  
ex2. **12**에 대한 **10의 보수**는 **88**이다  
  
감이 오는가?  
X진수에서 보수라 하면  
더해서 그냥 X가 되는 수가 아니라, 더해서 X제곱이 되는 수를 말한다  
  
<br><br>  

## N-1의 보수  
**컴퓨터**가 **음수**를 **표기**하는 방법에 대해 설명하기 전에  
추가로 **N-1의 보수**에 대해 알아야 한다  
  
ex3. **17**에 대한 **9의 보수**는 ( (10의 보수) - 1 ) 이므로 **82** 이다 
  
**N-1의 보수**는 **N의 보수**에 **-1**만 해주면 된다  
  
<br><br><br><br><br>  
  
---
  
# 음수 표기 방법

컴퓨터는 2진법을 사용한다   
그러면 제일 처음에 봤던 것 처럼  
간단하게 **앞의 부호비트만** 바꾸고  
나머지는 동일하게 2진법을 사용하는 방식으로 하면 되지 않을까?  
  
순서대로  
1. 부호 비트만 바꾸는 방식
2. 1의 보수 방식
3. 2의 보수 방식  
  
이렇게 알아보자  
  
> ### 예시부터  
> +1 (0000 0001)          
> 위의 1. 2. 3. 방식대로 -1을 나타내면
>    
> 1. 1000 0001  
> 2. 1111 1110
> 3. 1111 1111
  

## 1. 부호 비트만 바꾸는 방식  
  
글의 제일 앞부분에서 말한 방식이다  
하지만 이 방법의 가장 큰 문제점은  
  
### "0 이 2가지가 생긴다"는 점이다  
  
|0|0|0|0|0|0|0|0|
|---|---|---|---|---|---|---|---|  
  
|1|0|0|0|0|0|0|0|
|---|---|---|---|---|---|---|---|  
  
이렇게 2가지의 +0 -0 이 생긴다  
따라서 이 방식은 문제가 있다  
  
<br><br>  

---

<details> 
  <summary> <h1> 보수 도입하는 이유 </h1> </summary>

## 뺄셈을 용이하게 하기 위해서 보수를 도입  
  
그러면 **단순히 부호를 표기하는 -** 가 아니라   
  
"Int 비트가 **뺄셈을 의미**하도록 바꿔버리면 되지 않을까?"   
  
해서 나온게 **보수를 이용한 방식**이다  
  
<br><br>  
  
## 보수로 뺄셈 하는법   
  
### 10진수를 10의 보수로 뺄셈   
### ex1. 54-34 (결과가 음수가 아닌경우)  
1. -34 를 10의 보수로 변환 : 66
2. 54 + 66 = 120
3. 초과한 자리를 버린다 : 20  

### ex2. 34-54 (결과가 음수인 경우)  
1. -54 를 10의 보수로 변환 : 46
2. 34 + 46 = 80
3. 결과를 10의 보수로 바꾼다 : 20
  
<br><br>  
  
### ex1과 ex2는 결과가 같지않은가?  
부호의 차이일뿐 둘 다 20이 나오게 된다.  
그러면 어떻게 부호를 구분하는가?   
짐작하듯 20 위 자리에 1인가 0인가 따라서 부호가 구분된다  
  
근데, **ex1 과 ex2 의 3. 과정이 다르다**  
ex1 의 3은 "초과한 자리를 버린다"  
ex2 의 3은 "10의 보수로 바꾼다" 이다  
그러면 **일일이 결과가 음수인지 양수인지 비교**해야하는가?  
  
  <br>  
  
### 아니다  
그냥 **음수를 보수로 표기해버리면** 이 문제가 해결된다  
  
</details>
  
<br><br>
  
## 2. 1의 보수  
**1의 보수**가 2의 보수보다 **더 간단하다**  
왜냐하면    
![image](https://user-images.githubusercontent.com/101965836/197160140-48afc8c5-9ab2-49dd-ad45-2f18d1d02ed7.png)    
[출처](https://st-lab.tistory.com/189)  
  
### 양수에 NOT 만 씌우면 된다  
  
1의 보수(N-1의 보수)를 만들려면  
양수에서 각 비트를 반전시키기만 하면 된다  
따라서 **구현이 더 간단하다**    
  
<br><br> 
  
## 하지만 "1의 보수" 방식에는 단점이 있다  
1. -0 +0 문제가 발생한다  
2. 캐리를 발생시키는 경우 처리해야 한다  
  
  <br>  
  
### 1. -0 +0 문제  
0000 0000 은 **+0**    
1111 1111 은 **-0**   
이 된다  
  
<br>  

### 2. 캐리 발생하는 경우 처리 필요  
  
> ### 캐리란?  
> 자리 올림을 말한다   
> 예를 들어    
> 54-34 인 경우   
> 54 + (100 - 34)   
> = 54 + 66    
> = 120   
> 이렇게 자리 올림이 발생하는데  
> 여기서 올라가는 수를 carry 라고 한다  
  
캐리가 발생하는지 아닌지 따져주고  
캐리가 발생하면  
+1을 해줘야 한다  


> ### 캐리 발생시 +1 해줘야 하는 이유  
> [이미지 출처](https://st-lab.tistory.com/189)  
>   
> 23 + 31 의 경우를 먼저 보면  
> ![image](https://user-images.githubusercontent.com/101965836/197164393-70479052-fd82-42c2-a343-ad86055d0609.png)  
> 양수끼리 덧셈이니 어렵지 않다  
>     
> 그러나  
> -23 + 31 을 해보면  
> ![image](https://user-images.githubusercontent.com/101965836/197164539-75bb960d-d6ab-48bb-98b3-660fe405963d.png)  
> 이렇게 이렇게 캐리가 발생해서 심지어 MSB를 초과하게 되고,  
> 캐리가 발생한 경우에는 추가로 +1을 해줘야 결과가 올바르게 된다    
  
<br><br><br>  

## 3. 2의 보수  
  
2의 보수는   
1의 보수처럼 비트를 반전시킨 뒤  
1을 더해서 구현한다  
  
![image](https://user-images.githubusercontent.com/101965836/197165002-09572368-6b18-4d6f-9e49-435978623b66.png)  
  
처음에 2진수 보수에서 좀 헷갈렸으니 짚고 넘어가보면  
  
먼저 **2진수에서 1**은  
  
|0|0|0|0|0|0|0|1|
|---|---|---|---|---|---|---|---|  

이렇게 된다  
    
  
그럼 2진수 1에서 2의 보수는?  
  
|1|1|1|1|1|1|1|1|
|---|---|---|---|---|---|---|---|  
  
이다  

|　|0|0|0|0|0|0|0|1|
|---|---|---|---|---|---|---|---|---| 
|+|1|1|1|1|1|1|1|1|
|1|0|0|0|0|0|0|0|0|

여기서 비트 범위를 넘어간건 버려지므로  
  
|0|0|0|0|0|0|0|0|
|---|---|---|---|---|---|---|---|  

이렇게 0000 0000 만 남게 된다  
  
<br><br>  

<details> 
  <summary> <h2> 보수도 똑같이 0000 0001 아닌가?   </h2> </summary>
  
처음에 든 의문점이다. 
  
먼저  
0000 0001  
1111 1111  
하면 0000 0000 이 되는건 이해된다 (cpu 특성상 비트 초과하면 무시하니까)  
  
근데  
0000 0001   
0000 0001   
이렇게해도  
어차피 **보수는 해당 자리까지만** 이야기하는거니까  
더하면 0000 00**10 으로 제일 앞자리 0이 되니까**    
0000 0001의 보수는 0000 0001도 가능하지 않나?      
라고 생각했다  
  
  
아니 그러면  
10진수에서  
0001 의 보수는  
9999 도 될수 있고  
999  
99   
9  
다 될 수 있겠네?  
  
### 명확한 답은 찾지 못했다  
적당한 글이나 래퍼런스를 찾진 못했고...  
그냥 뇌피셜로 말해보자면   
어차피 컴퓨터에서 음수 표기를 목적으로 보수를 쓰는거니까  
비트를 다 채우는식으로 쓰고,  
초과하는 비트는 자동으로 버려지는 방식을 활용하는 것 같다  
  
  
</details>  


## 2의 보수를 사용하면 "1의 보수 단점"들이 해결된다
  
### 양수 계산  
![image](https://user-images.githubusercontent.com/101965836/197172260-45d628e9-19ea-4397-b036-6a7a0dad5817.png)  
  
### 음수 계산  
![image](https://user-images.githubusercontent.com/101965836/197172281-a34775a2-40ac-4461-816c-2f3955261018.png)  
  
이렇게 캐리가 발생하더라도 문제없는 모습을 볼 수 있다  
  

  
