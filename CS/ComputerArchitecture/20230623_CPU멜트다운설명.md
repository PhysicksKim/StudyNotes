[참고](http://csneverdie.net/spectre_meltdown_introduction/)  
  
# CPU 게이트 - 멜트다운 
CPU의 최적화 기법인 Speculative Execution(추측 실행)을 활용해  
허가 없이 메모리에서 민감한 정보를 탈취할 수 있는 보안 결함을 말한다.  

<br><br>  

---

<br><br>
  
# 배경지식 

## A. CPU의 예측

1. CPU는 성능을 위해서   
미리 캐싱하고, 동시에 여러 명령을 실행한다.

2. 심지어, 조건문이 있더라도   
성능을 위해서 조건문의 true/false에 상관없이  
분기 둘 다 미리 실행 해둔다.  

3. 해당되지 않은 분기의 값은   
그냥 값을 User에게 보여주지만 않을 뿐이다.    
이미 연산되고 캐싱된 값들은 그대로 남아있다.   


> 물론 직접 메모리 하나하나에 접근하는건 안된다.  
> 따라서 해커는 간접적인 접근 방안을 모색하고 
> 그 간접적인 방법이 뒤쪽에서 설명할 Memory flush + reload 방법이다.  

  <br>  
  
## B. CPU의 메모리 캐싱

1) CPU는 미리 필요할법한 값을 불러와서 저장해둔다.  
  
2) 메모리에 있는 값을 불러 올 때에는   
메모리 페이지 단위로 캐싱해서 가져온다.  
  
3) 캐싱된 값은 읽어올 때는 속도가 확연히 빠르다  

<br><br>  

# 멜트다운 

## A. 공격 방법  

```
1	raise_exception();
2	// 아래 코드는 시행되지 않음  
3	access(probe_array[data * 4096]); 
```

```
// 이후, probe_array[]의 index별 접근 속도 비교
```

<br><br>  

## B. 설명  

> ### 왜 4096 곱하는데?
> 에 대해서는 일단 무시하자.
> 순서상 다음 챕터에 설명하는 게 적합하니까  
> 천천히 인내심을 가지고 읽어 내려가 주세요  
    
- data : 공격 목표 데이터  
- 4096 : 메모리 페이지 크기
  
앞선 배경 지식에서 설명했듯  
line 1, 3 두 명령 다 cpu는 미리 계산한다.  
  
다만 앞선 line 1에서 문제가 발생했기에  
line 3의 실행 결과만 user에게 보여주지 않을 뿐이다.  
  
그런데 캐싱된 값은 그대로 cpu 캐시메모리에 남아있다.  
  

### 그러면 어떻게 data 값을 아느냐?
  
: line 3 의 probe_array\[data * 4096] 이 부분이 핵심이다.   
  
cpu는 probe_array\[data * 4096] 라는 데이터가 사용되는 것을 보고  
"아 이거 쓸 거 같으니 캐싱해두자" 라고 동작한다.    
  
그런데 이렇게 캐싱을 해두게 되면  
User가 line 3 실행 결과는 모를지언정  
캐싱된 array의 특정 index에는  
접근 속도가 훨씬 더 빠른것을 알 수는 있다.  

따라서 캐싱된 index가 어디인지 찾는다면 "data" 값이 얼마인지 알 수 있게되고  
probe_array 의 index들을 탐색하면서  
접근 속도가 상대적으로 빠른 index를 찾는다면  
캐싱된 위치가 어디인지 알 수 있게된다.  

<br><br>  

## C. 왜 4096 곱하는가?  

계속해서 설명하는 메모리 캐싱 이야기와 관련있는데  
캐싱은 메모리 페이지 사이즈 단위로 일어난다.  

### 1. probe_array\[data] 라고 해버리면  

```
probe_array[data]  
```

```
// data = 2인 경우  
probe_array\[2]
```
data가 0 1 2 3 ... 4095 무슨 값이 들어오더라도  
캐싱은 메모리 페이지 단위로 일어나므로    
전부 다 index 0~4095 통째로 캐싱이 되어버리기 때문에  
어디가 캐싱됐는지 알 수 없다  

### 2. probe_array\[data * 4096] 라고 하면  

```
probe_array[data]  
```

```
// data = 2인 경우  
probe_array\[2 * 4096]
```
data가 0 들어오면 0~4095 에 해당하는 인덱스가 캐싱되고  
data가 1 들어오면 4096~8191 에 해당하는 인덱스가 캐싱된다.  
왜? 페이지 단위로 캐싱되는데   
한 페이지가 4096의 크기를 가지기 때문이다.  

### 따라서, 페이지 단위를 곱해야 캐싱된 곳을 구분할 수 있다  

  
<br><br>  

---

<br><br>  
  
# 예시

### CPU의 방어 의도  
해커가 만든 프로그램이 
다른 프로그램에서 입력한 키보드 입력을 직접적으로 알아내고자 한다면  
OS는 직접 관련없는 값들을 알아내지 못하도록 막는다.  
  
```
print(키보드입력값); // 에러가 난다  
```
  
이렇게 하면 OS가 위 동작을 막는다.
  
행여 위 명령이 CPU 최적화 때문에 실행되고 캐시에 저장될지언정   
직접 해당하는 캐시 메모리 주소를 알 길도 없고  
무수히 넓은 캐시 메모리 공간에서   
뭐가 "키보드입력값"인지 어떻게 알 수 있겠는가?    

### 멜트다운 공격  
  
그런데 해킹 app이 멜트다운 취약점을 사용한다면?  
  
```
raise_exception();
access(probe_array[키보드입력값 * 4096]);  
```

예를 들어 "키보드 입력 값이 1"인 경우    
probe_array\[4096]으로 접근하는 속도가    
probe_array\[0]으로 접근하는 속도보다  
훨씬 빠른것을 해커는 알 수 있다.   
   
- 왜? 
미리 2번째 줄을 연산했고  
> 나는 2번째줄 결과를 안보여줬으니 '키보드입력값'은 안보여줬어  

라고 방어했다고 생각하지만  
  
해커는   
캐싱된 probe_array\[] 의 인덱스가 어디인지 알아보는 방식으로  
키보드 입력값을 알 수 있다.  
  
probe_array\[] 를 순회하면서 
캐싱이 일어나서 접근 속도가 상대적으로 더 빠른 index를 알아낼 수 있기 때문에  

```
캐싱일어난인덱스 / 4096 = 키보드입력값
```

으로 키보드 입력값이 뭔지 알 수 있다    
  
