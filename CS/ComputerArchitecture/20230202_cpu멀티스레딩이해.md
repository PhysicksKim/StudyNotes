[출처](https://udteam.tistory.com/213)  
  
# CPU 기본 구조  

![image](https://user-images.githubusercontent.com/101965836/216358247-ef2c1c48-2172-415c-8d81-4092de0ad42c.png)
[- 이미지 출처](https://jisu-shin.github.io/2021/02/17/cs-study-03/)  
  
CPU가 위와 같은 구조로 되어있다고    
컴퓨터 구조 기본 과정에서 배운다.  
  
근데 의문이 생겼다  
  
<br>
  
### 1코어 2스레드 라고 하는 "멀티스레드" 는 어떤 구조지?  
  
멀티 코어는 위 cpu 구조를 단순히 복제해두면 되겠지 하고 쉽게 받아들일 수 있었는데  
1코어에 멀티 스레드는... 어떤 구조인가 의문이 들었다  
  
<br><br>  

---

---

<br><br>  
  
[멀티스레딩 관련 참고 출처](https://udteam.tistory.com/213)  
이하 이미지들은 위 링크에서 가져옴  
  
# 결론 : 연산 유닛을 어떻게 효율적으로 쓰는가?  
  
잘 생각해보면  
cpu는 다양한 작업과 연산을 한다  
정수 사칙연산도 있고    
실수 사칙연산도 있고  
메모리 주소 관련된 작업을 할 수도 있다   
  
간단히 몇 가지 연산 유닛에 대해 소개하면  
- 정수 스칼라 유닛 (ALU)  
- 부동소수점 스칼라 유닛 (FPU)  
- 정수 벡터 유닛 (MMX)  
- 부동소수점 벡터 유닛 (SSE, AVX)  
  
이런 유닛들이 있다  
    
그러면 여기서 이런 개념이 나온다  
  
### 아, 자주 쓰이는 유닛들을 더 많이 배치하면 되잖아?  
  
아하!  
  
코어에 하드웨어적 멀티 스레딩 개념이 이렇게 탄생한다  
  
자주 쓰이는 연산 유닛을 늘리면  
코어 하나로 2코어처럼 쓸 수 있겠네?  
  
<br><br>  

> ### 주의사항  
> 이하 내용은, 앞서 밝힌 링크의 이미지를 사용했음을 다시한번 밝히며  
> 좀 더 정확하고 전문적이고 깔끔한 설명은, 위 링크를 직접 가서 읽어보길 추천한다  
>   
> 또한   
> 아래 설명에 나오는 용어들은  
> 제대로 된 정석적인 용어가 아니다.    
> 내 맘대로 이름 붙인 용어들이므로  
> 내용만 이해하고 용어는 걸러서 가져가도록    
    
<br><br>
    
# 1. 1 Core / 1 Thread  
![image](https://user-images.githubusercontent.com/101965836/216364242-e0722c45-2b8a-4ea9-b5a5-0d020f7eb163.png)  
  
위 이미지에 대해 설명하자면  
먼저 A B C D 가 각 연산/연산유닛에 해당한다.      
그리고 프로그래밍적 스레드 1과 2에서 연산 요청이 들어오고,  
한 사이클에 A B C D 각 하나씩만 처리할 수 있다  
  
1코어 1스레드인 경우에는   
그냥 정석적이게 처리된다.  
  
여기서 먼저 챙겨갈 개념은  
동시에 B 연산만 많거나 C 연산만 많으면  
**사이클이 낭비됨**을 짚고 가자    
  
![image](https://user-images.githubusercontent.com/101965836/216366167-5186b1f6-8b58-4813-9fc2-ab6d48bc1cf2.png)  
이렇게 B연산만 계속 요청이 들어오면  
A C D 는 그냥 멀뚱멀뚱 놀고만 있게 된다.  
  
![image](https://user-images.githubusercontent.com/101965836/216366375-200aa6d0-5655-4b74-8287-0777dfacdea7.png)  
반대로 스레드간 요청이 이렇게 일어나는 경우도 있다  
스레드 1과 2를 동시에 처리했다면 4사이클이면 됐지만  
한 스레드의 작업을 다 처리해야 다른 스레드의 작업을 처리할 수 있으므로  
문제가 생긴다.  
  
### 2가지 문제점  
1번문제 : (연산 사이클 낭비) A B C D 연산 중에서 한가지 연산에만 집중되면 다른 연산유닛이 놀고만 있다  
2번문제 : (배타적 요청 문제) \[ Thread 1 : AAA BBB ] \[ Thread 2 : CCC DDD ] 이 경우 두 스레드를 한방에 섞어서 처리할 수 없는 문제가 된다    
  
<br><br>  
  
# 2. 멀티코어 : 2 Cores / 2 Threads  
![image](https://user-images.githubusercontent.com/101965836/216367593-10ad886b-786f-4b13-ad0b-eb4050250663.png)  
  
이렇게 멀티코어를 쓰면   
2번 문제(배타적 요청 문제)는 해결할 수 있지만  
1번 문제(연산 사이클 낭비 문제)는 발생한다.  
  
![image](https://user-images.githubusercontent.com/101965836/216369276-b0768254-c199-4b7a-9665-4a8c034ac6b6.png)  
이렇게  
다른 연산유닛이 노는 문제가 해결된다.  
  
<br><br>  
  
# 3. 다른 방안 : 1 Wide Core / 1 Thread 모델
  
![image](https://user-images.githubusercontent.com/101965836/216370258-26b96f61-4ec7-445a-ae60-b31db071f63b.png)  
  
와이드 코어는 위처럼 자주 쓰이는 유닛을 늘리는 방식이다  
  
이 경우에는  
1번 문제는 해결 할 수 있지만   
2번 문제는 해결 할 수 없다  
  
![image](https://user-images.githubusercontent.com/101965836/216370712-8ae99a3e-f16b-4459-b9f3-437f08665d12.png)  
이렇게 배타적 요청 문제가 그대로 발생한다.  
  
<br><br>  
  
# 4. 멀티스레딩 1 - 인텔의 하이퍼스레딩 1 Core / 2 Threads  
  
![image](https://user-images.githubusercontent.com/101965836/216371987-cf00312c-088f-4deb-97dd-2ae9593fc06c.png)  
하이퍼 스레딩은  
본래 구조는 싱글 코어처럼 생겼지만  
Thread 1 2 를 섞어서 처리할 수 있다  
  
![image](https://user-images.githubusercontent.com/101965836/216372564-d324457a-dd23-4240-8534-180281930a43.png)  
하지만 위와 같이  
B요청만 계속 들어온다면 여전히 문제가 있다  
이 때문에  
하이퍼스레딩이 그다지 성능이 잘 안나온다는 평가가 있었다  
  
  
<br><br>  

# 5. 멀티스레딩 2 - AMD의 클러스터 멀티스레딩(CMT) '2-Core-like' Module / 2 Threads  
  
![image](https://user-images.githubusercontent.com/101965836/216372915-1482fd20-5fb4-43c0-8664-4b13e42bbf26.png)  
잘 안쓰이는 A D 연산유닛은 그냥 공유해버리고  
자주 쓰이는 B C 유닛은 별도로 각 스레드들이 갖는 방식이다.  
Clustered Multi-Threading 구조라 하며 '2-core-like' 라고도 한다.   
  
근데, AMD는 불도저 아키텍처에서 모듈 구조 아키텍처를 최초로 출시했는데  
불도저 아키텍처는 망했다.  
AMD는 이후로도 ZEN 출시 전까지는 계속해서 Intel에 압도적으로 밀렸었는데  
다양한 문제와 더불어 CMT 구조도 문제가 많았다.    
[불도저 아키텍처 문제점 - 나무위키](https://namu.wiki/w/AMD%20%EB%B6%88%EB%8F%84%EC%A0%80%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98#s-3)  
  
CMT가 망했음을 깨닫고  
AMD도 ZEN 아키텍처부터는 인텔의 하이퍼스레딩 방식을 사용하고 있다.  
  
<br><br>  
  
---

---

<br><br>  
  
# 물리 코어가 최고, 그 다음은 멀티 스레드  
하이퍼 스레딩, 클러스터 멀티스레딩 같은 많은 도전이 있었고  
실제로 성능 향상도 있음을 벤치마크에서는 보여줬다  
  
그리고 지금까지도 Intel과 AMD 모두 상위 모델뿐만 아니라 하위 모델 까지도  
멀티스레딩을 적용시켜서 CPU를 출시하고 있다.  
  
[CPU들 코어 스레드 정리표 - 나무위키](https://namu.wiki/w/%EB%A9%80%ED%8B%B0%EC%BD%94%EC%96%B4%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C#s-2.5.1)  
  
### 하지만, 스레드보다는 물리코어가 최고  
  
1코어 2스레드와  
2코어 2스레드를 비교하면  
역시나 2코어 2스레드가 더 좋다.   
  
그럼 1코어 2스레드는  
1코어 1스레드에 비해서 몇 배의 성능을 낼 수 있을까?  
  
이건 상황마다 다 달라진다.  
하나 확실한건, 대부분 연산을 풀로딩 걸어버리는 벤치마크 상황에서는  
확실히 성능 향상을 볼 수 있다.  
  
하지만 일부 게임의 경우에는  
오히려 **어쩔때는 하이퍼스레딩을 끄는게** 안정적인 프레임 뿐만 아니라  
**더 높은 프레임**을 내기도 한다고 하니까  
  
하이퍼 스레딩 자체가 물리 코어를 늘리는 것 만큼 파워풀하지는 못하다.  
    
[하이퍼 스레딩 벤치마크](https://www.techspot.com/article/1850-how-screwed-is-intel-no-hyper-threading/)  
  
  
<br>

# 정리    
CPU에는 연산 유닛들이 여러 가지 있다 (부동소수점 연산 유닛, 정수 연산 유닛 등)  
편의상 A B C D 연산유닛/연산요청 이라고 칭하겠다.  
  
코어 하나를 2스레드로 나누는 기술에는  
인텔의 하이퍼스레드 방식과 AMD의 CMT 방식이 있다  
  
인텔의 하이퍼스레딩 방식  
A B C D 연산 유닛들을 놓고   
스레드1번에는 AA BB 요청이 스레드2번에는 CC DD 형태로 연산요청이 쏟아질 때  
기존 CPU에서는 스레드1번의 AA BB 를 처리하고 나서 2번의 CC DD 를 처리했지만  
하이퍼스레딩은 스레드 1번 2번을 합쳐서 AA BB CC DD 를 다 한방에 처리한다.  
  
AMD의 CMT 방식  
A B | C D | A B  
이렇게 자주 쓰이는 A B 는 각기 따로 두고  
잘 안쓰이는 C D 는 공유해서 쓰는 방식이다.  
  
하지만 CMT 방식에는   
제대로 병렬화 되지 않은 애플리케이션 문제와  
CMT를 제대로 지원하지 못하는 OS 문제가 있었다.  
  
그래서   
AMD의 CMT 방식은 망했고, ZEN 부터는 인텔과 동일한 방식을 쓴다  
  
하지만  
하이퍼스레딩 방식도 결국은 이상적인 멀티스레딩처럼 동작하지 못하고   
특정 상황에서 뛰어난 성능을 보이기만 하는 게 아니라  
심지어 어쩔때는 하이퍼 스레딩을 끄는 게 오히려 더 좋은 퍼포먼스를 보이기도 했다.  
  
결론은   
멀티스레딩은 하나의 물리 CPU를 두고  
어떻게 연산유닛을 효율적으로 써볼까에 대한 고민에 탄생했지만  
아직은 특정 연산이면서 무거운 연산에만 이상적인 퍼포먼스를 보일 수 있다.  
  
