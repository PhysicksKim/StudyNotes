# CH4 아키텍처  

<br><br>

# 4.1 MySQL 엔진 아키텍처

![image](https://github.com/PhysicksKim/TIL/assets/101965836/b793546a-5e34-4af6-b79b-c62c5325f420)  
  
MySQL은 전체 구조를 간략하게 설명하면 위와 같다  
  
여기서 핵심은 엔진이 크게 2단계로 나뉘어 있다는 점이다.    
  
- MySQL 엔진 : 프로그래밍 API 와 밀접하게 연관된 동작을 수행    
- 스토리지 엔진 : 데이터 저장소와 밀접하게 연관된 동작을 수행  
  
<br>  
  
## 4.1.2 MySQL 스레딩 구조  
포그라운드 스레드 + 백그라운드 스레드  

### 포그라운드 스레드  
MySQL 서버에 접속된 클라이언트 사용자 요청 쿼리를 처리한다  
커넥션이 종료되면 해당 스레드는 스레드 캐시(Thread Cache)로 되돌아간다.  
스레드 캐시에는 일정 개수 이상의 스레드가 대기중에 있다.  
  
### 백그라운드 스레드   
InnoDB 에서는 여러 작업이 백그라운드로 처리된다.    
로그를 기록, 버퍼 사용해서 데이터를 디스크에 쓰는 작업, 데드락 모니터링 등을 백그라운드로 처리한다.   
  
쓰기 작업은 버퍼를 사용하고 백그라운드 스레드에서 일어난다.  
반대로 읽기 작업은 백그라운드로 넘기지 않고 포그라운드 스레드가 곧바로 처리한다  
  
<br>  
  
## 4.1.3 메모리 할당 및 사용 구조  

글로벌하게 중심이 되는 MySQL 서버 하나가 딱 있고  
각 Connection 마다 할당될 스레드가 있고 각기 있을 것이다.  
  
이에 따라서 메모리 할당도  
Global Memory 영역 하나 딱 있고  
Session(Connection) Memory 영역이 제각각 있게 된다.  
  
### Global Memory 영역  
스레드 수와 무관하게 하나의 메모리 공간만 할당  
> - 그냥 대충 이런 것들이 있다    
> Inno DB 버퍼 풀 , MyISAM 키 캐시, 바이너리 로그 버퍼, 리두 로그 버퍼, 테이블 캐시    
  
### Session Memory 영역  
커넥션(Connection) 메모리 영역 이라고도 한다   
클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.    
  
스레드별로 메모리가 독립적으로 할당되며    
절대로 공유되어 사용되면 안된다.   
   
> Session Memory 영역을 너무 크게 잡아버리면 메모리 부족으로 멈출 수 있다.

> 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼 등이 있다  
  
<br>  
  
## 4.1.4 플러그인 스토리지 엔진 모델  
    
MySQL 의 독특한 구조 중 하나인 플러그인 모델      
플러그인을 바꿔 끼워 넣거나 추가하는 식으로 MySQL에 기능을 추가할 수 있다는 장점이 있다.    
    
이 중에서 스토리지 엔진은    
디스크 읽기 쓰기를 처리하는 역할을 한다.     
  
책에는 스토리지 엔진이 어떤 것들이 있고 플러그인들을 어떻게 확인하는지 등 이야기를 하는데  
거두절미하고  
그냥 인증, 전문 검색(Full Text Search), 쿼리 재작성, 비밀번호 검증, 커넥션 제어 등과 같은 유용한 플러그인들을 입맛에 따라 도입해서 사용할 수 있다  
  
<br>  
  
## 4.1.5 컴포넌트  
  
컴포넌트 아키텍처는 기존 플러그인 구조의 단점을 해결하고자 나온 것이다. MySQL 8.0에 나왔다  
  
### 단점  
1. Plugin - MySQL 서버 Interface 끼리만 통신 가능. 플러그인 간의 통신 불가
2. Plugin이 직접 MySQL 서버의 변수와 함수를 호출 하므로, 캡슐화 X 라서 안전하지 않음
3. Plugin 끼리 Dependency 를 설정할 수 없어서 초기화 어려움
  
> MySQL 8.0 부터는 비밀번호 검증 기능이 컴포넌트 방식으로 바뀌었다  
  
<br>    
  
## 4.1.6 쿼리 실행 구조  
    
1. 쿼리 파서 : 쿼리 문장을 토큰으로 분리하고, 트리 구조로 만들어냄. 이 과정에서 기본 문법 오류를 발견.         
2. 전처리기 : 쿼리 파서가 만든 트리를 기반으로, 테이블 이름, 칼럼 이름, 내장 함수 같은 것에 맵핑하면서 존재 여부와 접근 권한을 확인한다. 없는 함수나 테이블,칼럼 이름을 여기서 걸러낸다.        
3. 옵티마이저 : 쿼리 문장을 더 빠르게 처리할 수 있도록 최적화해주는 과정. 반대로 개발자는 옵티마이저가 잘 최적화 할 수 있도록 어떻게 유도할지 알아야 한다.      
4. 실행 엔진 : 앞서 만들어진 실행 계획에 따라서 작업을 처리하기 위해 핸들러(스토리지 엔진)에게 요청을 보내서 처리함.    
5. 핸들러(스토리지 엔진) : 디스크에 데이터를 읽고 쓰기 하는 작업을 처리한다.  
  
<br>  
  
## 4.1.7 복제  

DB를 여러 개 둘 수 있도록 복제(Replication) 하는 기능.  
DB를 여러 개 복제해서 1. 데이터 백업 2. DB 부하 분산 을 할 수 있다.  
자세히는 16장 '복제' 에서 다룬다.  

<br>  

## 4.1.8 쿼리 캐시  
    
동일한 쿼리가 날아오면 캐시된 데이터로 즉각 응답하는 기능.    
    
얼핏 좋아보이지만, 데이터가 변경되면 캐시된 데이터를 다 삭제하고 다시 만들게 되므로    
데이터 쓰기가 거의 없는 테이블에나 효과가 있음.    
오히려 데이터 쓰기가 빈번한 테이블의 경우 캐시를 쓰는 게 더 느린 결과를 낳기도 함.   
더불어 버그의 원인으로 작용하기도 했음.  
   
이러한 이유 때문에 MySQL 8.0 에서는 쿼리 캐시 기능이 삭제됨  

<br>  
    
## 4.1.9 스레드 풀  
  
스레드 풀만 설치한다고 무작정 성능이 두 배이상 올라가고 그러는 건 아니다.  

스레드 풀 세팅 변수들에는 thread_pool_size, thread_pool_oversubscribe, thread_pool_stall_limit 등 다양한 값들이 있는데  
이에 관해서 무작정 많은 스레드를 사용한다고 해서 성능이 향상되는 게 아니다.  

따라서 서비스나 서비스 방향성에 따라서 스레드 풀 변수를 알맞게 튜닝해줘야 한다.  

<br> 

## 4.1.10 트랜잭션 지원 메타데이터  

메타데이터가 파일 기반으로 되어있으면, MySQL이 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 발생한다.  
  
MySQL 8.0 버전 부터는 메타데이터(구조 정보, 스토어드 프로그램 코드)를 InnoDB 테이블에 저장하도록 개선됐다.  
시스템 테이블과 데이터 딕셔너리 정보가 mysql.ibd라는 이름의 테이블에 저장된다.  
사용자가 직접 볼 수는 없지만, 실제로 테이블이 존재한다.  
  

<br><br>  
  
# 4.2 스토리지 엔진 아키텍처(InnoDB)    
  
InnoDB 스토리지 엔진 구조에 대해 살펴본다.  
InnoDB 엔진은 MySQL 스토리지 엔진 중 거의 유일하게 **레코드 기반 잠금**을 제공한다.  
따라서 높은 동시성 처리, 안정성을 얻을 수 있다.  
  
> ### 레코드 기반 잠금  
> DB table 에서 record(=row) 단위로 Lock을 거는 것을 말한다.
    
<br><br>  
   
## 4.2.1 PK 클러스터링 
PK를 기준으로 데이터들이 클러스터링 되어 저장된다.    
  
> 클러스터링 테이블 : 쉽게 말해서 테이블을 대표(PK)하는 인덱스 테이블.   
  
PK로 클러스터링 테이블을 만드는 특성 덕분에 PK를 이용한 Range Scan을 아주 빠르게 처리할 수 있다.  
InnoDB와 달리 MyISAM 에서는 클러스터링 키를 지원하지 않는다.  
  
<br><br>    

## 4.2.2 FK 외래키 지원

InnoDB 에서는 외래 키를 지원한다. 반면 MyISAM이나 MEMORY 에서는 이를 지원하지 않는다.  
  
이론적으로 본다면 데이터 무결성 때문에 외래키 설정해야 한다고 생각할 수 있다.  
하지만 책에서 뿐만 아니라 많은 인터넷 자료에서 제시하는 바에 따르면  
오히려 서비스 데이터베이스에서는 외래키를 안걸어 주는 게 더 서비스에 좋을 수 있다.  
  
실제 서비스 데이터베이스에서는  
외래키를 설정하게 되면 데드락이 발생할 때가 많다고 한다.   
[CS/Database/20220809_실무에서외래키를안쓴다는게정말이니.md](CS/Database/20220809_실무에서외래키를안쓴다는게정말이니.md)  
  
실무에서 데이터베이스 구조가 커져 외래키가 길게 얽히게 되면     
<code>수정 대상 레코드 -> 외래키1 -> 외래키2 -> ...</code>  
이렇게 Cascade 타고 들어가면서 문제가 복잡해진다.  
따라서 실무에서 외래 키를 걸어줄지에 대해서는 신중하게 생각하는 게 좋다.  
   
> foreign_key_checks 시스템 변수를 OFF로 하면 일시적으로 외래 키 체크를 중지할 수 있다.    
    
<br><br>    
     
## 4.2.3 MVCC(Multi Version Concurrency Control)     
      
트랜잭션이 일어나면 DB에 Lock이 걸린다.      
Lock이 걸리면 해당 테이블에 접근이 가능할까? 했을 때    
읽기는 가능하지만 쓰기는 불가능하다.    
      
이를 InnoDB는 언두 로그를 이용해서 구현한다    
    
1. Disk에 저장된 데이터 (데이터 파일)      
2. 트랜잭션 과정에서 수정된 데이터 (InnoDB 버퍼 풀)    
3. 수정 이전의 데이터 (언두Undo 로그)   
     
이렇게 3가지로 데이터가 나뉘게 된다.    
     
![image](https://github.com/PhysicksKim/TIL/assets/101965836/273c933c-14f6-47f5-a9ce-fdda66f741c4)     
   
버퍼 풀에서 id=3 데이터의 address 를 seoul -> busan 으로 바꾼다 하자.   
이때 트랜잭션이 걸리고 Flush 가 되기 전에는 Undo Log 까지만 올라가 있는다.   
이러면 3개의 다른 곳에 데이터가 존재한다.    
   
그러면 이 상황에서 <code>SELECT</code> 조회 하게 되면 어디에 있는 데이터가 반환될까?  
이는 transaction_isolation 에 담긴 Isolation Level에 따라 달라지는데  
READ_UNCOMMITTED 로 된 경우 데이터를 버퍼 풀에서 읽어서 반환하고  
READ_COMMITTED 또는 그 이하인 경우 언두 영역의 데이터를 반환한다.  
  
<br><br>  
  
## 4.2.4 Non-Locking Consistent Read (잠금 없는 일관된 읽기)    
  
앞서 MVCC 에서 이미 설명한 내용이다.    
잠금 없는 일관된 읽기는   
트랜잭션으로 인해 레코드에 LOCK이 걸려 있더라도  
LOCK이 걸린 레코드는 언두 로그를 읽는 등으로 LOCK에 영향받지 않고 계속해서 읽어내는 것을 말한다.  
  
 
<br><br>    
  
## 4.2.5 자동 데드락 감지  

InnoDB는 데드락을 자동으로 감지하고 해결할 수 있다.  
데드락 감지 스레드가 주기적으로 LOCK 대기 상태를 체크하여 데드락이 걸린 트랜잭션을 강제 종료한다.  
  
<br><br>  
  
## 4.2.6 자동 장애 복구  
  
DB server 나 하드웨어 수준에서 시스템 장애가 발생할 수 있고  
이때 자동으로 복구하는 기능을 지원하여 데이터를 보호한다.  

<br><br>  
  
## 4.2.7 InnoDB 버퍼 풀 
  
InnoDB 스토리지 엔진의 가장 핵심인 부분  
메모리에 데이터 파일이나 인덱스 정보를 캐시해두기도 하고  
쓰기 지연을 통한 버퍼 역할도 한다.  
  
자주 액세스 되는 데이터가 버퍼 풀을 통해서 메모리에 캐시되므로  
디스크의 랜덤 IO를 줄여서 성능 향상 이점을 얻을 수 있다.  
  
<br><br>    
  
## 4.2.8 Double Write Buffer  

## 4.2.9 언두 로그  

## 4.2.10 체인지 버퍼  

## 4.2.11 리두 로그 및 로그 버퍼  

## 4.2.12 어댑티브 해시 인덱스  

## 4.2.13 InnoDB 와 다른 스토리지 엔진(MyISAM, MEMORY) 비교  

<br><br><br>  

# 4.3 MyISAM 스토리지 엔진 아키텍처  
