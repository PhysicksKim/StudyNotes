# Chapter 8. 인덱스  
  
DB 쿼리 성능을 향상시키려면 인덱스 활용이 중요할 것이다.  
반대로 인덱스의 남용 오용은 오히려 Insert Update 성능을 떨어뜨릴 수 있다.  
따라서 개발자는  
인덱스가 어떻게 동작하는지 이해해야지  
이를 바탕으로 쿼리문을 쓸 때 인덱스가 잘 활용될 수 있는 형태로 쓰고,  
DB 모델링도 인덱스 활용 방식을 고려해서 잘 쓸수 있다.  
  
그러므로 인덱스는 성능 향상을 위해 꼭 탄탄히 짚고 넘어가야 한다고 생각한다.  
  
> 미래의 누군가를 위해 글을 남겨두자면   
> 기본적인 SQL 공부를 마치고 나서 realMySQL을 처음 공부했을 때,      
> 제일 처음으로 08. 인덱스 단원부터 공부했다.  
> 딱히 어떤 의도가 있는건 아니고  
> 그냥 인덱스쪽이 도대체 어떻게 동작하는지 너무 궁금해서  
> 앞단원 스킵하고 인덱스부터 봤다.  
>   
> 근데 막상 인덱스 단원을 공부하면서 느낀건  
> 자신이 **궁금한 부분**이 있으면, **그 부분부터 공부**하는게 좋은것 같다.  
> 인덱스부분을 공부하다가 InnoDB엔진 같은 앞단원에 관한 단어가 나오면  
> "어? InnoDB가 뭐지" 하고 자연스러운 흐름속에서 궁금증을 갖게되고  
> 이런 호기심이 받쳐줘서 내용이 머릿속에 더 잘 들어온다  
>   
> realMySQL **책 자체**가  
> MySQL에 대한 아주 **심층적인 내용**을 다루고 있기 때문에  
> 이렇게 호기심 바탕으로 퍼져나가는게 좋은 것 같다.  
  
---

# 8.1 디스크 읽기 방식   
  
#### Q. DB 테이블은 어디에 저장되어있을까?  
#### A. 저장장치에 저장되어있다.  
따라서 DB 성능을 올리기 위해서는 저장장치에 최소한으로 접근하는 것이 중요하다.  
이말인 즉, 최소한으로 테이블을 읽는것이 성능상 유리하다는 것이다.  
사실 어찌보면 당연한 말이지만 좀 더 풀어서 이야기해보자.  
   
실행중인 **앱은 메모리**에 올라가있지만  
**DB 테이블** 데이터들은 **저장장치**에 들어있다.  
근데 **이게 왜 중요하냐??** 하면   
저장장치(HDD, SSD)는 CPU나 메모리보다 훨씬 느리기 때문이다.  
따라서 저장장치에 요청이 더 많을수록 쿼리의 성능은 더 느려질것이다.   
  
하지만 이렇게 느린 저장장치일지라도  
속도가 **빠른** 접근 방법이 있고  
속도가 **느린** 접근 방법이 있다.  
**순차 I/O** 와 **랜덤 I/O** 가 바로 그 두 방법이다.  
  
## - 순차 I/O vs 랜덤 I/O
  
![image](https://user-images.githubusercontent.com/101965836/184498411-b9032b27-3c1c-4fea-b08b-839a231c1ce3.png)   
위 그림을 보자.  
순차(Sequential) I/O 는 그림의 위 처럼    
1 2 3 4 5 이렇게 순서대로 이동한다.  
  
하지만 랜덤(Random) I/O 는 그림의 아래 처럼    
하나를 읽은 다음에 어디로 가야할지 데이터를 얻고 이동해야 한다.  
  
따라서 쉽게 집작할 수 있듯  
랜덤 I/O가 더 오래걸린다.  
  
물론 깊게 들어가서 성능 비교를 한다면  
굉장히 복잡한 부분이 있다고 한다.    
하지만 일단 간단하게 이렇구나 정도로만 알아두자  
  
---

# 8.2 인덱스란? 
SELECT 문의 성능을 위해서   
테이블을 어떤 기준을 잡고 정렬해둔 것을 말한다.  
  
예를들어 어떤 테이블의 name 칼럼에 kim lee park ... 이렇게 10만명의 이름이 저장되어 있다고 해보자.  
그러면 여기서 where='park' 으로 찾을려면  
SQL이 어떻게 동작하게 될까?      
  
### 1. 만약 name이 정렬되어 있지 않다면?  
처음부터 끝까지 일일이 name 이 뭔지 보고 비교해야한다.  
즉 10만개의 행이 있다면, 10만개를 일일이 비교해야한다.  
  
### 2. 만약 name이 정렬되어 있다면?   
a b c 순서대로 name이 정렬되어 있다면  
k인 부분으로 바로 가서 kim을 찾는게 더 빠르지 않겠는가?  
또 만약 ki까지 정렬되어 있는걸 바로 찾고  
kim을 찾으면 더 빠를것이다.  
따라서 정렬되어 있다면, 적어도 10만개를 일일이 확인하지는 않아도 된다.  
  
### 결론  
데이터를 정렬해놓으면, 특정 데이터를 찾을 때 더 빨리 찾을 수 있다.  
  
따라서 적절한 인덱스 사용으로  
select문의 성능을 향상시킬 수 있다.  
  
<br>  
  
## 근데 왜 인덱스에 대해 깊게 알아야 할까?  
앞서 **"적절한 인덱스 사용"** 이라고 했다.  
그럼 반대로 **"적절하게 사용하지 않는다면"** 무슨 일이 생길 수 있다는 것이다.  
  
당연히 인덱스는 성능에 관한 사항이니까    
잘 못 사용하면 인덱스를 제대로 활용할 수 없다는 말이다.  
  
### 제대로 사용하려면?  
1. 인덱스를 적절하게 만들고  
2. 쿼리문을 적절하게 써야 한다  
  
제대로된 인덱스를 활용했다면 0.1초면 끝날 작업을  
쿼리문을 잘 못 써서 인덱스를 활용하지 못하고 10만개를 다 탐색하는 경우도 있다.  
  
### 따라서, 인덱스 원리를 알고 제대로 써야한다  
그냥 인덱스 달아둔다고 DBMS가 다 알아서 해주는 게 아니다  
DBMS의 옵티마이저가 작동해서 쿼리문을 어느정도 최적화해주기도 하지만  
그렇다고 옵티마이저가 무적은 아니다.  
  
예를들어  
index가 name으로만 정렬되어 있는데  
where문에서 age 조건으로 찾는다면?  
당연히 name과 age는 무관하니까 10만개를 다 찾아봐야 할 것이다.  
  
또한 name과 age 둘 다 정렬되어 있다고 하더라도  
name = 'kim' AND age > 20  
이렇게 되어 있다면   
name과 age 인덱스는 따로따로 정렬되어 있기 때문에  
한번에 딱 여기서부터 여기까지라고 정할 수 없을 것이다.  
  
몇 가지 더 추가적인 의문이 들 수 있지만  
일단은 간단히 이 말만 알아두자  
### 인덱스는 적절한 사용법을 알지 못하면 의미가 없다. 따라서 작동원리를 알아야 한다.    

<br>

### 인덱스 장단점  
장점 : SELECT문이 빨라진다 
단점 : 데이터 저장(INSERT UPDATE DELETE)이 느려진다. (추가될때마다 인덱스를 다시 정렬해줘야 하니까)  
  
<br><br><br>
  
# 8.3 B-Tree 인덱스  
