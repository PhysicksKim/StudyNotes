# Chapter 8. 인덱스  
  
DB 쿼리 성능을 향상시키려면 인덱스 활용이 중요할 것이다.  
반대로 인덱스의 남용 오용은 오히려 Insert Update 성능을 떨어뜨릴 수 있다.  
따라서 개발자는  
인덱스가 어떻게 동작하는지 이해해야지  
이를 바탕으로 쿼리문을 쓸 때 인덱스가 잘 활용될 수 있는 형태로 쓰고,  
DB 모델링도 인덱스 활용 방식을 고려해서 잘 쓸수 있다.  
  
그러므로 인덱스는 성능 향상을 위해 꼭 탄탄히 짚고 넘어가야 한다고 생각한다.  
  
> 미래의 누군가를 위해 글을 남겨두자면   
> 기본적인 SQL 공부를 마치고 나서 realMySQL을 처음 공부했을 때,      
> 제일 처음으로 08. 인덱스 단원부터 공부했다.  
> 딱히 어떤 의도가 있는건 아니고  
> 그냥 인덱스쪽이 도대체 어떻게 동작하는지 너무 궁금해서  
> 앞단원 스킵하고 인덱스부터 봤다.  
>   
> 근데 막상 인덱스 단원을 공부하면서 느낀건  
> 자신이 **궁금한 부분**이 있으면, **그 부분부터 공부**하는게 좋은것 같다.  
> 인덱스부분을 공부하다가 InnoDB엔진 같은 앞단원에 관한 단어가 나오면  
> "어? InnoDB가 뭐지" 하고 자연스러운 흐름속에서 궁금증을 갖게되고  
> 이런 호기심이 받쳐줘서 내용이 머릿속에 더 잘 들어온다  
>   
> realMySQL **책 자체**가  
> MySQL에 대한 아주 **심층적인 내용**을 다루고 있기 때문에  
> 이렇게 호기심 바탕으로 퍼져나가는게 좋은 것 같다.  
  
---

# 8.1 디스크 읽기 방식   
  
#### Q. DB 테이블은 어디에 저장되어있을까?  
#### A. 저장장치에 저장되어있다.  
따라서 DB 성능을 올리기 위해서는 저장장치에 최소한으로 접근하는 것이 중요하다.  
이말인 즉, 최소한으로 테이블을 읽는것이 성능상 유리하다는 것이다.  
사실 어찌보면 당연한 말이지만 좀 더 풀어서 이야기해보자.  
   
실행중인 **앱은 메모리**에 올라가있지만  
**DB 테이블** 데이터들은 **저장장치**에 들어있다.  
근데 **이게 왜 중요하냐??** 하면   
저장장치(HDD, SSD)는 CPU나 메모리보다 훨씬 느리기 때문이다.  
따라서 저장장치에 요청이 더 많을수록 쿼리의 성능은 더 느려질것이다.   
  
하지만 이렇게 느린 저장장치일지라도   
속도가 **빠른** 접근 방법이 있고   
속도가 **느린** 접근 방법이 있다.   
**순차 I/O** 와 **랜덤 I/O** 가 바로 그 두 방법이다.   
   
## - 순차 I/O vs 랜덤 I/O  
  
![image](https://user-images.githubusercontent.com/101965836/184498411-b9032b27-3c1c-4fea-b08b-839a231c1ce3.png)   
위 그림을 보자.  
순차(Sequential) I/O 는 그림의 위 처럼    
1 2 3 4 5 이렇게 순서대로 이동한다.  
  
하지만 랜덤(Random) I/O 는 그림의 아래 처럼    
하나를 읽은 다음에 어디로 가야할지 데이터를 얻고 이동해야 한다.  
  
따라서 쉽게 집작할 수 있듯  
랜덤 I/O가 더 오래걸린다.  
  
물론 깊게 들어가서 성능 비교를 한다면  
굉장히 복잡한 부분이 있다고 한다.    
하지만 일단 간단하게 이렇구나 정도로만 알아두자  
  
---

# 8.2 인덱스란? 
SELECT 문의 성능을 위해서   
테이블을 어떤 기준을 잡고 정렬해둔 것을 말한다.  
  
예를들어 어떤 테이블의 name 칼럼에 kim lee park ... 이렇게 10만명의 이름이 저장되어 있다고 해보자.  
그러면 여기서 where='park' 으로 찾을려면  
SQL이 어떻게 동작하게 될까?      
  
### 1. 만약 name이 정렬되어 있지 않다면?  
처음부터 끝까지 일일이 name 이 뭔지 보고 비교해야한다.  
즉 10만개의 행이 있다면, 10만개를 일일이 비교해야한다.  
  
### 2. 만약 name이 정렬되어 있다면?   
a b c 순서대로 name이 정렬되어 있다면  
k인 부분으로 바로 가서 kim을 찾는게 더 빠르지 않겠는가?  
또 만약 ki까지 정렬되어 있는걸 바로 찾고  
kim을 찾으면 더 빠를것이다.  
따라서 정렬되어 있다면, 적어도 10만개를 일일이 확인하지는 않아도 된다.  
  
### 결론  
데이터를 정렬해놓으면, 특정 데이터를 찾을 때 더 빨리 찾을 수 있다.  
  
따라서 적절한 인덱스 사용으로  
select문의 성능을 향상시킬 수 있다.  
  
<br>  
  
## 근데 왜 인덱스에 대해 깊게 알아야 할까?  
앞서 **"적절한 인덱스 사용"** 이라고 했다.  
그럼 반대로 **"적절하게 사용하지 않는다면"** 무슨 일이 생길 수 있다는 것이다.  
  
당연히 인덱스는 성능에 관한 사항이니까    
잘 못 사용하면 인덱스를 제대로 활용할 수 없다는 말이다.  
  
### 제대로 사용하려면?  
1. 인덱스를 적절하게 만들고  
2. 쿼리문을 적절하게 써야 한다  
  
제대로된 인덱스를 활용했다면 0.1초면 끝날 작업을  
쿼리문을 잘 못 써서 인덱스를 활용하지 못하고 10만개를 다 탐색하는 경우도 있다.  
  
### 따라서, 인덱스 원리를 알고 제대로 써야한다  
그냥 인덱스 달아둔다고 DBMS가 다 알아서 해주는 게 아니다  
DBMS의 옵티마이저가 작동해서 쿼리문을 어느정도 최적화해주기도 하지만  
그렇다고 옵티마이저가 무적은 아니다.  
  
예를들어  
index가 name으로만 정렬되어 있는데  
where문에서 age 조건으로 찾는다면?  
당연히 name과 age는 무관하니까 10만개를 다 찾아봐야 할 것이다.  
  
또한 name과 age 둘 다 정렬되어 있다고 하더라도  
name = 'kim' AND age > 20  
이렇게 되어 있다면   
name과 age 인덱스는 따로따로 정렬되어 있기 때문에  
한번에 딱 여기서부터 여기까지라고 정할 수 없을 것이다.  
  
몇 가지 더 추가적인 의문이 들 수 있지만  
일단은 간단히 이 말만 알아두자  
### 인덱스는 적절한 사용법을 알지 못하면 의미가 없다. 따라서 작동원리를 알아야 한다.    

<br>

### 인덱스 장단점  
장점 : SELECT문이 빨라진다 
단점 : 데이터 저장(INSERT UPDATE DELETE)이 느려진다. (추가될때마다 인덱스를 다시 정렬해줘야 하니까)  
  
<br><br><br>

---

# 미리 훑어보기  
  
### 8.3 B-Tree(Balanced) 인덱스  
먼저 가장 흔히 사용되는 B-Tree 인덱스에 대해서  
어떤 구조로 이루어져 있고 어떻게 동작하는지 본다.  
   
당연하게도 자료구조에 따라서 데이터 입출력 비용이 달라진다.  
그러므로 인덱스의 기본적 구조인 B-Tree에 대해서 먼저 알아본다.  
    
그다음 B-Tree 인덱스를 통한 읽기 방법들에 대해 본다.  
1. 인덱스 레인지 스캔  
2. 인덱스 풀 스캔  
3. 루스 인덱스 스캔  
4. 인덱스 스킵 스캔  
  
이후 B-Tree 다중 칼럼, 정렬, 가용성과 효율성에 대해 알아본다.  
  
  <br>  
  
### 8.4 R-Tree 인덱스  
여기서 R은 Rectangle을 뜻하며  
B-Tree 방식을 공간 정보 저장에 활용한 것이다.  
공간 인덱스(Spatial Index)를 통해 2차원 데이터를 인덱싱하는 방법에 대해 알아본다.  
그리고 R-Tree 용도에 대해서도 살짝~ 본다.  
  
  <br>  
  
### 8.5 전문 검색 인덱스  
여기서 전문은 Full Text를 뜻한다.    
전문 검색은 엄청 긴 글들이 많은(게시판 내용 검색 등) 데이터 속에서   
키워드를 검색하는데 사용한다.  
  
이럴 때 당연히 Index를 통한 SELECT 성능 향상이 중요하고,    
그렇다고 무작정 이전에 나온 B-Tree 방식으로는 인덱싱하기에는 부적절하다.    
따라서 전문 검색(Full Text) 인덱싱을 위해서 별도의 알고리즘이 필요하다.   
  
전문 검색 인덱스 알고리즘에 대해 알아본다.  
어근 분석 알고리즘 , n-gram 알고리즘 , 불용어 처리에 대해 알아본다.  
  
<br>  
  
### 8.6 함수 기반 인덱스  
일반적으로는 특정 칼럼에 대해서만 인덱싱이 이뤄진다. (예. id 칼럼을 인덱스로 정함)  
하지만 때로는 칼럼의 값을 변형해서 인덱스를 구축해야 할 때도 있다.  
이럴 때 함수 기반 인덱싱을 사용한다.  
  
2가지 방법이 있다  
1. 가상 칼럼을 이용한 인덱스   
2. 함수를 이용한 인덱스   

위 두 방법에 대해 간략히 본다.  
  
<br>  
  
### 8.7 멀티 밸류 인덱스  
전문 검색 인덱스를 제외하곤 모든 인덱스들이 데이터 1개에 1개의 인덱스 값을 가진다.  
즉, 데이터와 인덱스 키가 1:1 관계를 갖는다.  
  
하지만 멀티 밸류 인덱스는  
하나의 데이터가 여러 인덱스 키 값을 갖는다.  
  
이는 사실 정규화에 위배되는 형태다.  
하지만 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서,   
JSON의 배열 안에 있는 값(element)에 대해 인덱스가 필요해졌다.  
따라서 이를 위해 멀티 밸류 인덱스가 등장했다.  
  
멀티 밸류 인덱스에 대해서는   
간단히 어떻게 테이블을 선언하고 또 쿼리에서 인덱스를 사용하는지 본다.  
  
<br>  
  
### 8.8 클러스터링 인덱스  
클러스터링 인덱스 개념은 지금까지 설명한 것과 크게 다르지 않다.   
다만 InnoDB 엔진을 쓰는 MySQL 에서는  
PK(Primary Key)가 비슷한 값들을 동시에 조회한다는 점에서 착안해  
PK 값이 비슷한 레코드들을 묶어서 저장하는데  
이를 클러스터링이라고 한다.  
  
클러스터링 인덱스 챕터에서는  
클러스터링 테이블 구조에 대해서 보고  
PK가 인덱스에 어떤 영향을 미치는지를 중점적으로 본다.  
  
PK 선정이 또 중요한 이유가   
MySQL에서는 PK값이 주어지면 무조건 클러스터링 인덱스를 만든다    
따라서 PK를 잘 못 잡으면 당연히 성능상에도 문제가 발생할 수 있으니  
클러스터링 인덱스에 대해서 잘 이해하고 PK를 선정해야 한다.  
    
<br>  
  
### 8.9 유니크 인덱스  
MySQL에서는 또 특이한게  
유니크 조건을 붙이면 자동으로 인덱스가 생성된다.  
따라서 그냥 유일한 값이라고 무작정 유니크 조건을 붙이게 되면  
당연하게 문제가 생길수도 있다.  
  
따라서 유니크 인덱스와 일반 세컨더리 인덱스가 어떻게 다른지 비교해보고  
성능 관점을 비롯한 주의사항에 대해서 알아본다.  
    
<br>  
  
### 8.10 외래키  
외래키 제약이 설정되면  
자동으로 연관되는 테이블까지 인덱스가 생성된다.  
  
여기서 외래키 인덱스가 대해 갑자기 등장한 이유는  
부모 - 자식 테이블 간에서  
한쪽 테이블이 외래키 관련 컬럼을 변경(ex.UPDATE) 하는 중이라면(트랜잭션)      
다른 한쪽에서는 접근할 수 없게 락이 걸린다.  
  
따라서 외래키와 인덱스 락 등에 대해 이해 해야지  
락으로 인해서 발생할 문제를 예상하고 DB를 설계할 수 있다.  
  
  
  
---
  
 
# 8.3 B-Tree 인덱스  
  
### 1. 기본 개요  
![image](https://user-images.githubusercontent.com/101965836/185101485-f9c8cb7f-bace-4e34-8de3-adf7c4a2b8de.png)  
[출처](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)  
   
위 그림은 숫자를 B-Tree에 따라서 정렬한 예시이다.   
데이터를 찾아들어가는 과정과 함께 B-Tree에 대해 알아보자.  
  
먼저, 제일 처음 들어오면 10과 20이 보인다.   
여기를 **루트 노트(Root Node)** 라고 한다.   
  
1. 만약 5를 찾을려 했다면, 10보다 작으니 왼쪽으로 가면 된다.  
2. 만약 15를 찾으려 했다면, 10초과 20미만이니 10 오른쪽 20 왼쪽으로 가면 된다.  
3. 만약 20을 찾으려 했다면, 곧바로 20이 있으니 20으로 가면 된다.  
  
딱 직관적으로 어떤 구조인지 이해가 될 거다.  
  
<br>  
   
### 2. 일반 B-Tree 구조와 SQL의 B-Tree 인덱스간의 차이점
![image](https://user-images.githubusercontent.com/101965836/185111664-4933d5c8-2b14-4b3b-b04f-2f69d64b6f22.png)  
[출처](https://12bme.tistory.com/138)   
   
1. 위 그림에서는 **정렬 기준이 곧 데이터지만**     
SQL의 B-Tree 인덱스에서는 **정렬 기준이 별도의 인덱스 키** 이다    
    
2. 위 그림에서는 **마지막 노드 전에 찾으려는 값이 있으면 바로 꺼낼 수 있지만**    
SQL의 B-Tree 인덱스에서는 **앞쪽 노드들은 "키-자식노드 주소" 구조이고, 마지막 노드만 "키-프라이머리 키" 구조로 직접 데이터로 접근 가능하다**  

> ### B+Tree 라고 말함
> 앞서 말한 SQL의 B-Tree 를 흔히 B+Tree 라고 하는데,
> 책에서는 그냥 B-Tree 라고 하므로 계속 B-Tree 라고 하겠다.  
>
> 여기서 B+Tree 는 "비 플러스 트리" 라고 하지만
> B-Tree 는 "비 마이너스 트리" 라고 할 수 도 있지만 그냥 "비 트리" 라고 하는 게 맞다.
> 왜냐하면  
> B-Tree 에서 - 하이픈은 그냥 "Balanced Tree의 줄임말이다" 라는 뜻이고,      
> B-Tree 를 발전시킨 방식의 이름이 B+Tree , B*Tree 가 된다  
> 
  
  <br>  
  
### 3. 구조 & 이름  
앞선 그림처럼 B-Tree는  
1️⃣ -> 2️⃣ -> 3️⃣ -> ... -> N    
이렇게 1층부터 3층 ... N층까지 계속 값을 찾아들어가는 식이다.  
**B-Tree는** Binary가 아니라 **Balanced** Tree 이며  
**각 노드**에다가는 2개만 저장하는 게 아니라 **여러 개씩 저장**할 수 있다.  
  
제일 먼저 접근하는 1층을 앞서 말했듯 **루트 노트(Root Node)**  
중간에 있는 2층 ... N-1층 을 **브랜치 노드(Branch Node)**  
마지막 N층은 **리프 노트(Leaf Node)** 라고 한다.   
    
<br>  
  
### 4. SQL에서 B-Tree 인덱스 
앞서 3. 에서 차이점 비교로 잠깐 봤던 내용인데,  
마지막 층인 리프 노트만 직접 데이터로 접근할 수 있는 PK 값을 갖고 있다.   
  
> ### 왜 SQL B-Tree 인덱스는 다른지 추측   
> 아마 DB에는 10만건 100만건씩 저장되고, 각 노드는 엄청 많은 인덱스를 갖고 있을 것이다.
> 무슨 말이냐면,  
> 예를 들어 각 노드가 100개씩 인덱스-자식노드 주소 를 갖고 있을 것이다.  
> 그러면 루트에 100개, 브랜치에 100개, 리프에 100개 이런식으로 가질 수 있다. (실제로 그런게아니라 예를들어서)  
> 그러면 총 100 * 100 * 100 = 100만 개의 데이터가 저장되어 있다.           
> 따라서 대부분의 경우에는 리프노트까지 가야지 찾고자 하는 값이 있을 것이다.  
> (리프 전에 찾을 확률은 1만/100만 이므로 1%밖에 안된다)  
> 그러므로 루트와 브랜치에는 PK를 저장해봤자 고작 1% 케이스에서만 효율적여지므로    
> 그냥 리프노트에만 값을 두는 것 같다.    
  
<br><br><br>  

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제  
결론부터 말하면  
인덱스 키에 변경이 있으면,   
경우에 따라 노드에 저장된 데이터들을 빼고 넣고 막 자리 바꾸기를 해야해서  
비용이 많이 발생할 수 있다.  
  
이를 이해하려면   
  
1. SQL B-Tree 노드는 어떻게 생겼고, 얼마만큼 저장할 수 있는가
2. 만약 노드가 가득차면, 어떤 일이 생길까?  
  
위 내용들을 알아야 한다.  
  
### 왜 위에 2가지 내용들을 알아야 할까?  
결국 자료 구조의 성능 문제는 a. 데이터 읽기 b. 데이터 I/O 에서 발생한다  
근데 B-Tree는 앞서 대충 알아봤듯  
정렬 + 트리 구조를 통해서 데이터에 빨리 접근하려고 만들어낸 구조다.  
그러면 빨리 접근할려면 반대로 데이터 I/O 성능에서 문제가 있지 않겠는가?  
대게는 Trade Off 관계니까.  
  
따라서 B-Tree I/O를 이해하기 위해서 각 노드는 어떤 구조인지 다시 알아야 하고,    
B-Tree I/O 과정에서 발생하는 "노드가 가득 차면?" 에 대해서 알아본다.  
  
<br>  

## 1. SQL B-Tree 구조 / 얼마나 저장 가능?   
![image](https://user-images.githubusercontent.com/101965836/185111664-4933d5c8-2b14-4b3b-b04f-2f69d64b6f22.png)  
[출처](https://12bme.tistory.com/138)     
  
노드 타고 들어가서 데이터로 접근하는 개념은 앞서 설명했다.   
이때 더 중요한건 "각 노드가 얼마만큼 저장하는가?" 이다.  
  
### 페이지
Inno DB 엔진에서는  
데이터를 저장하는 기본 단위를 페이지(Page) 또는 블록(Block) 이라고 한다.  
디스크의 모든 I/O와 Read 의 기본이 페이지가 된다.  
당연히 인덱스도 페이지 단위로 관리되며,  
루트, 브랜치, 리프 노드들 모두 페이지로 구분된다.  
  
<br>  
  
### 이진 트리 vs B-Tree
이진 트리는 자식 노드를 2개만 가지는데 반해서  
B-Tree는 여러 자식 노드를 가질 수 있다.  
  
<br>  
  
### B-Tree 자식 노드는 가변적이다   
각 데이터의 크기가 클수록  
한 페이지에 담을 수 있는 자식 노드들도 적어질 것이다.  
  
각 페이지의 크기는 default 16KB 이며,  
innodb_page_size 라는 시스템 변수를 이용해서 4KB ~ 64KB 사이 값으로 조절할 수 있다.  
  
<br>  
  
### 한 페이지에 저장할 수 있는 데이터 수는?  
예를 들어  
  
| 인덱스 (사용자 ID) | 자식 노드 주소 |
|---|---|
|abcdef|&000100|
|aaa123|&000200|
|...|...|
  
이런식으로 구성되어 있다고 해보자.     
각각은 16바이트, 12바이트로 구성되어 있으면  
하나의 데이터는 각각 28바이트이며  
16\*1024/28 = 585 개의 인덱스를 저장할 수 있다.  
    
만약 여기서 인덱스가 길어져서 각각 데이터 하나의 용량이 커지면  
그만큼 저장할 수 있는 인덱스가 적어지고  
이는 곧 가장 느린 "디스크 읽기"를 더 많이 해야한다는 뜻이 된다.  
  
<br>  
  
## 2. 만약 노드가 가득차면, 어떤 일이 생길까?  
데이터가 추가되면 인덱스 키도 인덱스 페이지에 추가될 것이다.  
그러다가 인덱스 페이지가 가득 차면 어떻게 될까?  
  
### 인덱스 키 추가 / 만약 가득 차면  
새로운 키가 Leaf 노드에 저장되어야 하는데  
만약 가득찬다면 Leaf 노드를 분리(Split)해야 할 것이다.  
  
그러면 상위 브랜치 노드까지 처리 작업이 또 이뤄져야 한다.  
분리되는 노드의 주소와 인덱스도 상위 브랜치 노드에 추가되어야 하고,  
이러면 또 다시 루트 노드까지 작업이 확장된다.  
  
이러한 탓에   
인덱스 키 추가로 노드가 가득차서 분리해야 한다면  
단순히 Leaf 노드만 분리되고 끝이 아니라  
그 위에 브랜치, 루트 노드까지 추가 작업이 이루어 진다.  
  
따라서 쓰기 작업에는 비용이 많이 발생한다.  

<br><br>  

## 삭제도 알아보자  
좀 간단하다.  
리프 노드에서 찾아서 그냥 삭제 마킹만 하면 된다.   
삭제 마킹된 곳은 그대로 방치해도 되고 재활용할 수도 있다.  
    
키를 삭제한다고 마킹하는 작업도 디스크 쓰기작업으로 이뤄진다.  
따라서 키 삭제에도 디스크 I/O가 이뤄진다.  
  
하지만 이런 부분들은 Inno DB 엔진에서 버퍼링되어 지연 처리된다.  
지연 처리? 뭔말일까  
  
<br><br>  

## 지연 처리  
인덱스가 변하면 이리저리 인덱스 페이지들을 건드려야 하므로  
디스크 I/O 작업이 이리저리 이뤄진다.  
  
따라서 얼마나 오래걸릴지 확신할 수 없는 작업이므로 (뇌피셜)  
INSERT, UPDATE, DELETE 같은 작업들은  
인덱스 관리를 위해서 추가 작업이 이뤄질 수 있으므로  
Inno DB 엔진 같은 경우에는 지연시켜서 나중에 처리한다  
이에 대해서는 "체인지 버퍼"(책 4.2.10)를 알아보면 된다.   
  
<br><br><br>  

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소  
1. 인덱스 키 값의 크기
페이지 단위로 데이터를 읽음.
인덱스 크기가 커지면 한 페이지에 들어가는 레코드 수가 줄어듦.
따라서 인덱스 키의 크기가 크면 효율이 떨어짐.  
  
2. B-Tree 깊이 :
Tree의 깊이를 말한다.  
근데, 어차피 아무리 큰 DB라도 5단계 이상 깊어질 일은 없으니, 깊이는 큰 의미 없다.   
   
3. 기수성(선택도) :
유니크한 값의 수.  
극단적으로 인덱스 키 값은 10개 뿐인데 데이터가 100만건이라면, 인덱스가 의미 없어진다  
  
4. 읽어야 하는 레코드 수
예를 들어 100만 건이 있는 테이블에서 50만건을 가져와야 한다고 해보자.
인덱스로 50만건을 가져오기 vs 그냥 테이블을 50만건 읽기    
라고 했을 때 그냥 테이블 50만건 읽는 게 더 빠르다.  
보통의 DB는 인덱스 1건 읽는게 직기보다 4~5배 비용이 드는 것으로 판단한다.  
따라서 전체 레코드의 20~25%를 넘어서면, 그냥 Full Scan을 해버리는 게 더 좋다고 판단한다.  

<br><br><br>  

## 8.3.4 인덱스 Scan의 종류  

### 1) 인덱스 유니크 스캔
인덱스로 딱 1건 찾을 때 사용함.  
가장 인덱스의 강한 효과를 볼 수 있음.  
  
```sql
SELECT * FROM employees
	WHERE first_name = 'Ebbe';
```
  
<br>  

### 2) 인덱스 레인지 스캔  

범위를 찾을 때 사용하는 방법.  
비교 연산자(\<, \>, \<=, \>=)나 BETWEEN, IN 등에 사용됨.  
시작점을 인덱스로 찾고, 조건을 만족할 때까지 행을 찾는 방식이다.  

```sql
SELECT * FROM employees
	WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

위 예시를 바탕으로 설명하면    
(1) 인덱스로 'Ebbe'를 먼저 찾음    
(2) 이후 순차적으로 다음 데이터가 조건에 맞는지 체크해나감.    
  
여기서 아래와 같은 의문이 들 수 있다.  
  
> "그냥 'Ebbe' 찾고 'Gad' 찾은 다음,  
> 그 중간은 체크 안하고 전부 긁어오면 되는 거 아냐?"  
    
이에 대해 두 가지 답변을 할 수 있는데.  
  
1. 혹시, 루스 인덱스 스캔이나 인덱스 스킵 스캔 방식을 생각한 것일 수 있다. 곧바로 다음에 나오니까 그걸 읽어보자.  
  
2. 위 방법을 적용할 수 있는지를 한방에 판별할 방법이 없다. 예를들어 age BETWEEN 20 AND 30 했다면, 만족하는 값이 3개라면 순차읽기가 더 나을테고, 테이블 전체라면 당연히 앞서 설명한 방법이 더 낫다. 하지만 이를 알 방법이 없으니, 차라리 그냥 쭉 읽어나가는 게 일반적으로 더 빠르다고 DBMS들이 생각하는 것 같다.  
  
> ### 추가 뇌피셜  
> 전부 긁어올 수 있다면 그게 나을 수 있다.  
> 하지만 DB 특성상(HDD에 저장되므로) Random Access가 안되고 I/O 비용이 크므로     
> 앞서 말한 더 나은 방법은 오히려 비용이 더 들수 있다.    
> 즉, DB는 가능한 한 I/O를 피하도록 설계되므로,    
> 그냥 Sequential Access 최대한 이용하는 방향으로 동작한다.    
> 다만 절대적인 것은 아니다.   
> DBMS 정책, 데이터 분포, 테이블 크기, 하드웨어 성능 등에 따라서 동작 방식이 달라질 수 있다.  
  
<br>  
  
### 3) 인덱스 풀 스캔   
테이블 풀 스캔처럼 전부 스캔하지만, 인덱스 키를 스캔한다.      
이는 인덱스의 크기가 테이블 보다 작으므로 더 효율적이다.  
   
구체적인 이유는    
테이블 전체를 불러오는 것 보다 인덱스 전체를 불러오는 게     
더 적은 I/O 로 전체를 가져올 수 있기 때문이다.   
    
그러나 **인덱스 풀 스캔**의 경우    
일반적으로 인덱스를 사용한다고 표현하지 않는다.    
인덱스 풀 스캔은 인덱스를 효율적으로 사용하지 못해서 전부 다 탐색해야 하는 어쩔 수 없는 경우에 일어난 것이기 때문이다.   
  
<br>  

---

> 아래 **루스 인덱스 스캔** 부터는 **다중 칼럼 인덱스**에 대해 알아야 한다.  
> 별건 아니고 (name, age) 라고 2개 이상의 column에 대해서 index를 잡는 것을 말한다.    
> 정렬 방식은 name을 먼저 정렬하고 그 다음 age가 정렬되는 식이다.  
>     
> Real MySQL 책에는 곧바로 다음 소챕터에 나오는데  
> 이어질 **4) 루스 인덱스 스캔** 과 **5) 인덱스 스킵 스캔** 을 이해하려면  
> 먼저 **다중 칼럼 인덱스** 에 대해 알아야 한다.  
> 근데 왜 책에는 이게 순서가 다중 칼럼 인덱스를 먼저 알려주지 않았는지 좀 의아하다.  

---

### 4) 루스 인덱스 스캔 (Loose Index Scan)  
GROUP BY + MIN() MAX() 쓸 때 사용함  

(1) 인덱스로 GROUP별 첫 row 찾음    
(2) GROUP에서 MIN() 또는 MAX()의 ROW 갖고옴 (인덱스로 찾은 첫 row가 MIN 또는 MAX니까)
(3) GROUP의 그 외의 ROW는 찾을 필요 없으니 바로 다음 GROUP 으로 넘어감  
  
핵심은, 중간에 필요하지 않은 인덱스 키 값은 무시하고 넘어가는 방식이다.   
  
> Oracle 에서는 Index Skip Scan 이라 한다.  
    
- 예시  
    
Student 테이블에서 year(학년) 별로 가장 height(키)가 작은 학생을 찾는다고 해보자.  
그러면 GROUP BY year 로 아래와 같은 쿼리가 짜여질거다.  

```sql
SELECT year, MIN(height) FROM Student
	GROUP BY year;
```
  
이때 인덱스가 year과 height에 둘 다 걸려있다면  
year로 첫 번째 요소 찾은 후 height 도 처음꺼 딱 짚고  
바로 다음 year로 넘어가는 방식이다.  
    
<br>  

### 5) 인덱스 스킵 스캔  
예시부터 보자.  
    
아래와 같은 인덱스와 쿼리가 있다고 하자  
    
```sql
CREATE INDEX ix_gender_birthdate ON employees (gender, birth_date)
```
  
```sql  
SELECT gender, birth_date FROM employees
	WHERE birth_date >= '1965-02-01';
```

|gender|birth_date|
|---|---|
|M|'1965-01-20'|
|M|'1965-02-01'|
|M|'1965-02-12'|  
|M| ... |

|중간생략|중간생략|
|---|---|
|F|'1965-01-03'|
|F|'1965-02-01'|
|F|'1965-03-24'|
|F|...|

이런 경우에 앞선 쿼리는 아래와 같이 2개로 나눠서 실행하는 게 더 좋을거다  
  
```sql  
SELECT gender, birth_date FROM employees
	WHERE gender='M' AND birth_date >= '1965-02-01';
SELECT gender, birth_date FROM employees
	WHERE gender='F' AND birth_date >= '1965-02-01';
```

이러한 작업을 DB가 알아서 판단하고 해주는 게 인덱스 스킵 스캔이다  

<br><br>  

## 루스 인덱스 스캔 VS 인덱스 스킵 스캔  
두 방식은 유사하지만 다르다.  

- 루스 인덱스 스캔 : group별로(GROUP BY) 첫 row 찾아 읽은 다음, 다음 group으로 바로 넘어감  
- 인덱스 스킵 스캔 : group별로(다중 INDEX의 상위 index) 첫 row 찾아 읽은 다음, 조건에 맞지 않을 때 까지 순차적으로 읽고, 조건에 어긋나는 row 찾은 순간 다음 group으로 넘어감.   
  
둘의 같은 점은 index를 써서 첫 row 를 찾아 들어간다는 점이고  
차이점은 첫 row 이후에 바로 다음 group으로 넘어갈 것인지,  
아니면 순차읽기로 range를 scan해야 하는지에 차이가 있다.  
  
두 방식이 비슷하게 동작하지만 이름은 유사하지 않은데  
그 이유는 명확히 모르겠지만   
아마도 두 방식이 적용되는 쿼리 예시가 좀 상황이 다르기 때문이라고 생각한다.  

루스 인덱스 스캔은 GROUP BY + MIN 또는 MAX 를 쓸 때 사용되는 최적화 방식이고,  
인덱스 스킵 스캔은 다중 Column 인덱스가 잡혀있지만 모든 column에 대해서 조건문을 걸어주지 않았을 때 최적화 하는 방식이다.  
  
그래서 두 방식이 적용되는 맥락이 연관이 없어서 이름을 통일성있게 맞추지 않은 것 같다.  
  
> 근데 중간에 row를 스킵한다는거나 
> 인덱스 덕분에 첫 row 를 쉽게 찾을 수 있다는 점을 활용한 게 비슷하니까  
> 두 방식의 이름을 좀 유사하게 지었으면 좋았을텐데 싶은 생각이 든다.  
  
<br><br><br>

## 8.3.5 다중 칼럼 인덱스

실제 서비스에서는 2개 이상의 칼럼을 포함해 하나의 인덱스로 만드는 "다중 칼럼 인덱스" 가 더 많이 사용된다.  
다른 이름으로는 2개 이상 연결됐다 해서 "Concatenated Index" 라고도 한다.  
  
> ### Concatenate
> 형용사 1. 연쇄된, 이어진, 연결된
> Java, Javascript, Python 등 다양한 언어에서 concat 이나 concatenate 라는 메서드 이름을 찾을 수 있는데
> 그게 바로 Concatenate 에서 따온 이름이다.
>   
> 나도 Java 기본서 공부할 때 처음 알았다   
  
### (name, age) 로 정의되면, name 먼저 정렬된다   
뭔 말이냐면  

|name|age|
|---|---|
|Kim|21|
|Kim|35|
|Park|31|
|Park|42|

이런 식으로  
name이 먼저 정렬된 후, age가 정렬된다는 것이다.  
따라서 age 정렬 순서는 name이 같은 경우에만 의미가 있다.  
  
### 따라서, (칼럼A, 칼럼B, 칼럼C) 이렇게 잡을 때, 순서가 중요하다  
  
인덱스 정의할 때 칼럼을 적어넣은 순서에 따라서 정렬되니까       
어떤 순서로 인덱스 칼럼을 정의하느냐에 따라 성능차이가 날 것을 예상할 수 있다.      
  
그래서 인덱스 정의할 때에는   
주로 어떤 쿼리를 날리게 될지 미리 예상하고 정의해야 한다.    
   
또 쿼리를 짜는 입장에서도   
어떻게 다중 칼럼 인덱스가 짜여져 있는지 생각하고 쿼리를 날려야 한다.   
  
<br><br><br>  

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향  
  
인덱스가 오름차순으로 정렬되도록 정의했다고 해서  
항상 오름차순으로만 읽을 수 있는 것은 아니다  
거꾸로 끝에서 부터 읽으면 그게 곧 내림차순이니까  
어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 알아서 한다.  

<br>  
  
### 인덱스의 정렬 
  
칼럼마다 정렬 순서를 다르게 할 수 있다.    

- 예전(MySQL 8.0 이전)
칼럼별로 지정할 수 없어서 -1을 곱하는 방식을 쓰기도 했다.  

- 최근(MySQL 8.0 이후)
칼럼별로 오름차순 내림차순 따로 가능
  
<br><br><br>  

## 8.3.7 인덱스 가용성 & 효율성  
  
쿼리를 어떻게 구성하느냐에 따라서    
조회에 인덱스를 사용할 수 있는지가 결정된다.    

반대로 인덱스 설계 과정에서  
어떤 쿼리를 날릴지 예상하면서 인덱스를 정의해야 하기도 한다.  
  
<br>  
  
### 인덱스 적용 고려사항    
  
1. 다중 컬럼에서 조건 순서 : WHERE A AND B / B AND A  
2. LIKE 와일드카드 위치 : WHERE something LIKE 'abc%' / LIKE '%def'  
3. 사용할 수 없는 조건들 (ex. NOT EQUAL류, 연산자나 스토어드 함수 사용 등)  
  
위 사항들을 고려해서 인덱스와 쿼리를 설계해야 한다.  
  

### 1) 다중 칼럼에서 조건 순서  

```SQL
CREATE INDEX test_index ON 
```

```SQL
SELECT * FROM dept_emp
	WHERE dept_no='d002' AND emp_no >= 10114;
```

```SQL
SELECT * FROM dept_emp
	WHERE emp_no >= 10114 AND dept_no='d002';
```
   
앞서 다중 칼럼 인덱스에서도 설명한 내용이다.  
   
dept_no 조건을 먼저 거느냐   
emp_no 조건을 먼저 거느냐에 따라서   
인덱스 타는지 여부가 달라진다  
  
   
### 2) LIKE 와일드카드   

|column|
|---|
|...|
|감덱스|
|나덱스|
|박덱스|
|인덱스|
|페덱스|
|...|
  
위와 같이 column 이 있을 때   
문자열 검색에서 LIKE 문을 쓰는 상황에서도 인덱스를 탈수 있다    
  
```SQL
WHERE column LIKE '나덱%'  
```  
  
위와 같이 조회하면      
인덱스를 통해서 '김덱스' 를 먼저 찾아들어간 다음  
순차조회로 체크해나간다    

- 인덱스 안걸리는 경우
  
```SQL
WHERE column LIKE '%덱스'
WHERE column LIKE '_덱스'
WHERE column LIKE '%덱%'
```
  
와일드카드를 위와 같이 걸 경우 인덱스가 안걸린다.  
  
이는 당연하게도 'ABC' 라고 문자열이 있다면  
A먼저 정렬되고 B정렬되고 C정렬되기 때문이다.  
  
AB 를 먼저 조회한 다음 조회해 나갈 수는 있지만    
'%C'로 뒤의 C부터 조회하는건   
앞에 붙을 수 있는 문자의 경우의 수가 너무 많아진다    
  
따라서 인덱스를 이용하려면     

#### **와일드카드를 앞에 걸어줘야 한다**

<br>

### 3) 인덱스를 사용할 수 없는 조건  
  
- NOT-EQUAL 경우 (<> , NOT IN , NOT BETWEEN , IS NOT NULL)
- 스토어드 함수나 연산자로 인해 column이 변형된 경우 <code>WHERE DAYOFMONTH(column) = 1</code>
- NOT-DETERMINISTIC 속성의 스토어드 함수가 사용된 경우  
- 데이터 타입이 서로 다른 경우 <code>WHERE char_column = 10</code>  
- 문자열 데이터 타입의 콜레이션(Collation)이 다른 경우  

### 다중 칼럼에서는  
  
```SQL
INDEX ix_test (col_1, col_2, col_3, ... , col_n)
```
  
아래와 같은 경우 **인덱스 사용이 안된다**  
  
- col_1 칼럼에 대한 조건이 없는 경우  
- col_1 칼럼의 조건이 위에서 말한 인덱스를 사용할 수 없는 조건인 경우  

  
**인덱스 사용이 되는 경우는**
  
이는 반대로   
col_1 , col_2 , ... 순서대로 조건이 걸려있을 때  

```
동등 비교
범위 비교
LIKE '좌측%' 
```

으로 되어있는 경우   
인덱스를 사용할 수 있다.  
  
<br>  

### 범위 결정 조건 vs 체크 조건  

- 범위 결정 조건  
"wage 가 10000 ~ 20000 사이 값만 먼저 체크하면 되겠구나"  
-> Table Full Scan 안하고 Index Range Scan 가능  
  
  
- 체크 조건
앞서 wage 범위를 정한 다음.  
"first_name = 'Park' 인 사람만 찾자"     
-> wage로 Range 잡은 다음, first_name 이 'Park' 인지 일일이 체크해나간다    
   
<br>  
  
### 인덱스 걸리는 / 안걸리는 예시  

1. 인덱스 사용 불가  
```SQL
WHERE col_1 <> 2
```

<br>
  
2. col_1, col_2 둘 다 범위 결정 조건으로 사용 가능  
```SQL
WHERE col_1 = 1 AND col_2 > 10
```

<br>
  
3. col_1, col_2, col_3 모두 범위 결정 조건으로 사용됨  
```SQL
WHERE col_1 IN (1,2) AND col_2 = 2 AND col_3 <= 10
```

<br>

4. col_1, col_2, col_3 까지는 범위 결정 조건 / col_4는 체크조건으로 사용됨  
```SQL
WHERE col_1 = 1 AND col_2 = 2 AND col_3 IN (10,20,30) AND col_4 <> 100
```

<br>

5. col_1, col_2, col_3, col_4 모두 범위 결정 조건 (LIKE 도 '좌측%' 이므로 인덱스 탈 수 있음  )    
```SQL
WHERE col_1 = 1 AND col_2 IN (2,4) AND col_3 = 30 AND col_4 LIKE '페덱%'
```

<br>

6.  col_1, col_2, col_3, col_4, col_5 모두 범위 결정 조건  
```SQL
WHERE col_1 = 1 AND col_2 = 2 AND col_3 = 30 AND col_4 = '김김김' AND col_5 = '서울'
```
  
<br><br><br>  
  
# 8.4 R-Tree 인덱스  
R-Tree는 Rectangle Tree로,   
앞서 본 B-Tree 인덱스가 1차원적으로 자료를 정리했다면,   
R-Tree 는 2차원 데이터를 인덱싱 하는 방식이다.    
  
공간 인덱스(Spatial Index) 라고도 한다.    
    
<br>  
  
### R-Tree 구조 기본 : MBR(Minimum Bounding Rectangle)  
  
R-Tree 구조의 기본 개념은 MBR(Minimum Bounding Rectangle)에서 시작한다  
  
도형을 감싸는 최소 크기의 사각형  
  
가장 작은 도형부터 감싸는 사각형을 만들어 나간다.  
  
<br>  
    
![image](https://github.com/PhysicksKim/TIL/assets/101965836/84cbb476-f547-4364-a2bb-2272c6768150)    
가장 먼저 기본 도형들을 감싸는 사각형을 만들고(R1 ~ R4)      
  
<br>  
   
![image](https://github.com/PhysicksKim/TIL/assets/101965836/08caab06-a4c4-4413-a969-7175f63639fd)   
기본 도형 사각형을 다시 한번 감싸는 사각형을 또 만들고 (R5 , R6)   
  
<br>  
   
![image](https://github.com/PhysicksKim/TIL/assets/101965836/a7a083d8-048a-4b59-8033-f040d4c2442f)  
이를 또 전부 감싸는 사각형을 만든다 (R7)  
  
<br><br>  
  
### R-Tree : B-Tree 에 MBR을 저장
  
![image](https://github.com/PhysicksKim/TIL/assets/101965836/dd75f69a-8889-41b4-bedc-6f4f135fcd69)
  
위 이미지와 같이  
앞에서 MBR 만들어 둔 것에다가 B-Tree 구조를 적용시켜주면 된다.  
  
<br><br>  
  
### R-Tree 의 용도  
GPS 좌표 저장, CAD/CAM 소프트웨어, 회로 디자인 등 좌표 시스템 기반 정보에 사용한다.  
  
예를 들어 기준점으로부터 반경 5km 이내에 있는 카페를 검색한다고 해보자.  
이 경우 만약 Full Scan 한다면?  
기준 점을 기준으로 100만개의 데이터에다가 distance 계산을 다 해야한다.  
하지만 R-Tree를 이용해서 
  
<br><br>  
  
### 근데 R-Tree 에서 어떻게 "근처"를 탐색?  
  
기준 좌표가 주어지면  
Root 에서 기준 좌표를 포함하는 사각형을 찾는다  
그 다음 Branch 에서도 기준 좌표를 포함하는 사각형을 찾고  
다시 또 Leaf 에서 기준 좌표를 포함하는 사각형을 찾으면 된다.  
  
<br><br><br>  

## 8.5 전문(Full Text) 검색 인덱스  
게시판의 본문 검색을 위한 인덱스는 어떻게 만들까?    
지금까지 본 B-Tree Index를 사용할 수 있을까?    
   
답은 "B-Tree 인덱스를 사용할 수 없다" 이다.    
B-Tree 인덱스 하나는 약 1000 byte 또는 3072 byte (InnoDB) 정도 사용한다     
따라서 Full Text를 인덱스에 넣을 수 없다.   
    
또한 앞서 "인덱스의 가용성" 챕터에서 봤던 LIKE 에서 Index 사용 문제 때문에 B-Tree 인덱스를 사용할 수 없다.    
<code>LIKE '인덱%'</code> 같이 앞부분 검색에만 인덱스 사용 가능하고,      
<code>LIKE '%덱%'</code> 같이 중간에 있는 내용 검색은 인덱스를 사용할 수 없다.          
    
<code>안녕하세요. Real MySQL 책을 통해 공부하고 있습니다.</code>   
위와 같은 경우 중간에 있는 "Real MySQL" 를 검색하려 할 때        
B-Tree 인덱스를 사용한다면 Full Text 검색을 인덱스를 활용해 수행할 수 없다.    
<code>LIKE '%Real MySQL%'</code> 이라고 하면 인덱스를 탈 수 없다.   
   
따라서    
전문(Full Text)검색을 위한 인덱스 알고리즘을 따로 사용해야 한다.    

## 예시  

```SQL
SELECT * FROM Board WHERE content LIKE '%검색%';
```
게시판에서 글 내용 검색을 어떻게 구현하지 라고 생각했을 때  
가장 단순하게는 위와 같이 만들 수 있다.  
  
하지만 이렇게 하면 Full Table Scan이 일어나므로 성능 문제가 발생한다.  
게시판 글 내용 조회 요청이 엄청 많다면? 당연히 문제된다.  
그래서 Full Text 전용 인덱싱 전략이 필요하다   
  
## MySQL의 전문(Full Text) 검색 알고리즘 2가지  
1. 어근분석 알고리즘     
2. n-gram 알고리즘   
  
MySQL은 위와 같이 두 방식을 사용해서 Full Text 를 인덱싱 한다  

[MySQL n-gram 공식 문서](https://dev.mysql.com/blog-archive/innodb-full-text-n-gram-parser-ko/)  
  
### 1. 어근 분석  
영어 같은 경우 동사에 s가 붙는다거나 하는 식의    
기본 단어 + 변형 방식  
으로 구성된다.  
  
따라서 이러한 언어의 경우에는 어근 분석 알고리즘을 사용하는 게 적합하다.  

MySQL 에서는 오픈소스 형태소 분석 라이브러리인 MeCab을 플러그인 형태로 사용해서 어근 분석 알고리즘을 지원한다.  
  
하지만 어근 분석 알고리즘의 큰 단점은  
MeCab을 가져다 설치한다고 끝이 아니라는 점이다  
문장 구조 인식을 위한 학습이 필요하다.  
  
### 2. n-gram  
단어를 잘게 쪼개서 저장하는 방식이다  
예를 들어 question 이라는 단어가 있다하면  
qu, ue, es, st, ti, io, on 으로 나눠서 저장한다  
  
인덱스 크기가 커지지만, 언어에 대한 이해가 필요없다는 장점이 있다
