# Chapter 8. 인덱스  
  
DB 쿼리 성능을 향상시키려면 인덱스 활용이 중요할 것이다.  
반대로 인덱스의 남용 오용은 오히려 Insert Update 성능을 떨어뜨릴 수 있다.  
따라서 개발자는  
인덱스가 어떻게 동작하는지 이해해야지  
이를 바탕으로 쿼리문을 쓸 때 인덱스가 잘 활용될 수 있는 형태로 쓰고,  
DB 모델링도 인덱스 활용 방식을 고려해서 잘 쓸수 있다.  
  
그러므로 인덱스는 성능 향상을 위해 꼭 탄탄히 짚고 넘어가야 한다고 생각한다.  
  
> 미래의 누군가를 위해 글을 남겨두자면   
> 기본적인 SQL 공부를 마치고 나서 realMySQL을 처음 공부했을 때,      
> 제일 처음으로 08. 인덱스 단원부터 공부했다.  
> 딱히 어떤 의도가 있는건 아니고  
> 그냥 인덱스쪽이 도대체 어떻게 동작하는지 너무 궁금해서  
> 앞단원 스킵하고 인덱스부터 봤다.  
>   
> 근데 막상 인덱스 단원을 공부하면서 느낀건  
> 자신이 **궁금한 부분**이 있으면, **그 부분부터 공부**하는게 좋은것 같다.  
> 인덱스부분을 공부하다가 InnoDB엔진 같은 앞단원에 관한 단어가 나오면  
> "어? InnoDB가 뭐지" 하고 자연스러운 흐름속에서 궁금증을 갖게되고  
> 이런 호기심이 받쳐줘서 내용이 머릿속에 더 잘 들어온다  
>   
> realMySQL **책 자체**가  
> MySQL에 대한 아주 **심층적인 내용**을 다루고 있기 때문에  
> 이렇게 호기심 바탕으로 퍼져나가는게 좋은 것 같다.  
  
---

# 8.1 디스크 읽기 방식   
  
#### Q. DB 테이블은 어디에 저장되어있을까?  
#### A. 저장장치에 저장되어있다.  
따라서 DB 성능을 올리기 위해서는 저장장치에 최소한으로 접근하는 것이 중요하다.  
이말인 즉, 최소한으로 테이블을 읽는것이 성능상 유리하다는 것이다.  
사실 어찌보면 당연한 말이지만 좀 더 풀어서 이야기해보자.  
   
실행중인 **앱은 메모리**에 올라가있지만  
**DB 테이블** 데이터들은 **저장장치**에 들어있다.  
근데 **이게 왜 중요하냐??** 하면   
저장장치(HDD, SSD)는 CPU나 메모리보다 훨씬 느리기 때문이다.  
따라서 저장장치에 요청이 더 많을수록 쿼리의 성능은 더 느려질것이다.   
  
하지만 이렇게 느린 저장장치일지라도  
속도가 **빠른** 접근 방법이 있고  
속도가 **느린** 접근 방법이 있다.  
**순차 I/O** 와 **랜덤 I/O** 가 바로 그 두 방법이다.  
  
## - 순차 I/O vs 랜덤 I/O
  
![image](https://user-images.githubusercontent.com/101965836/184498411-b9032b27-3c1c-4fea-b08b-839a231c1ce3.png)   
위 그림을 보자.  
순차(Sequential) I/O 는 그림의 위 처럼    
1 2 3 4 5 이렇게 순서대로 이동한다.  
  
하지만 랜덤(Random) I/O 는 그림의 아래 처럼    
하나를 읽은 다음에 어디로 가야할지 데이터를 얻고 이동해야 한다.  
  
따라서 쉽게 집작할 수 있듯  
랜덤 I/O가 더 오래걸린다.  
  
물론 깊게 들어가서 성능 비교를 한다면  
굉장히 복잡한 부분이 있다고 한다.    
하지만 일단 간단하게 이렇구나 정도로만 알아두자  
  
---

# 8.2 인덱스란? 
SELECT 문의 성능을 위해서   
테이블을 어떤 기준을 잡고 정렬해둔 것을 말한다.  
  
예를들어 어떤 테이블의 name 칼럼에 kim lee park ... 이렇게 10만명의 이름이 저장되어 있다고 해보자.  
그러면 여기서 where='park' 으로 찾을려면  
SQL이 어떻게 동작하게 될까?      
  
### 1. 만약 name이 정렬되어 있지 않다면?  
처음부터 끝까지 일일이 name 이 뭔지 보고 비교해야한다.  
즉 10만개의 행이 있다면, 10만개를 일일이 비교해야한다.  
  
### 2. 만약 name이 정렬되어 있다면?   
a b c 순서대로 name이 정렬되어 있다면  
k인 부분으로 바로 가서 kim을 찾는게 더 빠르지 않겠는가?  
또 만약 ki까지 정렬되어 있는걸 바로 찾고  
kim을 찾으면 더 빠를것이다.  
따라서 정렬되어 있다면, 적어도 10만개를 일일이 확인하지는 않아도 된다.  
  
### 결론  
데이터를 정렬해놓으면, 특정 데이터를 찾을 때 더 빨리 찾을 수 있다.  
  
따라서 적절한 인덱스 사용으로  
select문의 성능을 향상시킬 수 있다.  
  
<br>  
  
## 근데 왜 인덱스에 대해 깊게 알아야 할까?  
앞서 **"적절한 인덱스 사용"** 이라고 했다.  
그럼 반대로 **"적절하게 사용하지 않는다면"** 무슨 일이 생길 수 있다는 것이다.  
  
당연히 인덱스는 성능에 관한 사항이니까    
잘 못 사용하면 인덱스를 제대로 활용할 수 없다는 말이다.  
  
### 제대로 사용하려면?  
1. 인덱스를 적절하게 만들고  
2. 쿼리문을 적절하게 써야 한다  
  
제대로된 인덱스를 활용했다면 0.1초면 끝날 작업을  
쿼리문을 잘 못 써서 인덱스를 활용하지 못하고 10만개를 다 탐색하는 경우도 있다.  
  
### 따라서, 인덱스 원리를 알고 제대로 써야한다  
그냥 인덱스 달아둔다고 DBMS가 다 알아서 해주는 게 아니다  
DBMS의 옵티마이저가 작동해서 쿼리문을 어느정도 최적화해주기도 하지만  
그렇다고 옵티마이저가 무적은 아니다.  
  
예를들어  
index가 name으로만 정렬되어 있는데  
where문에서 age 조건으로 찾는다면?  
당연히 name과 age는 무관하니까 10만개를 다 찾아봐야 할 것이다.  
  
또한 name과 age 둘 다 정렬되어 있다고 하더라도  
name = 'kim' AND age > 20  
이렇게 되어 있다면   
name과 age 인덱스는 따로따로 정렬되어 있기 때문에  
한번에 딱 여기서부터 여기까지라고 정할 수 없을 것이다.  
  
몇 가지 더 추가적인 의문이 들 수 있지만  
일단은 간단히 이 말만 알아두자  
### 인덱스는 적절한 사용법을 알지 못하면 의미가 없다. 따라서 작동원리를 알아야 한다.    

<br>

### 인덱스 장단점  
장점 : SELECT문이 빨라진다 
단점 : 데이터 저장(INSERT UPDATE DELETE)이 느려진다. (추가될때마다 인덱스를 다시 정렬해줘야 하니까)  
  
<br><br><br>

---

# 미리 훑어보기  
  
### 8.3 B-Tree(Balanced) 인덱스  
먼저 가장 흔히 사용되는 B-Tree 인덱스에 대해서  
어떤 구조로 이루어져 있고 어떻게 동작하는지 본다.  
   
당연하게도 자료구조에 따라서 데이터 입출력 비용이 달라진다.  
그러므로 인덱스의 기본적 구조인 B-Tree에 대해서 먼저 알아본다.  
    
그다음 B-Tree 인덱스를 통한 읽기 방법들에 대해 본다.  
1. 인덱스 레인지 스캔  
2. 인덱스 풀 스캔  
3. 루스 인덱스 스캔  
4. 인덱스 스킵 스캔  
  
이후 B-Tree 다중 칼럼, 정렬, 가용성과 효율성에 대해 알아본다.  
  
  <br>  
  
### 8.4 R-Tree 인덱스  
여기서 R은 Rectangle을 뜻하며  
B-Tree 방식을 공간 정보 저장에 활용한 것이다.  
공간 인덱스(Spatial Index)를 통해 2차원 데이터를 인덱싱하는 방법에 대해 알아본다.  
그리고 R-Tree 용도에 대해서도 살짝~ 본다.  
  
  <br>  
  
### 8.5 전문 검색 인덱스  
여기서 전문은 Full Text를 뜻한다.    
전문 검색은 엄청 긴 글들이 많은(게시판 내용 검색 등) 데이터 속에서   
키워드를 검색하는데 사용한다.  
  
이럴 때 당연히 Index를 통한 SELECT 성능 향상이 중요하고,    
그렇다고 무작정 이전에 나온 B-Tree 방식으로는 인덱싱하기에는 부적절하다.    
따라서 전문 검색(Full Text) 인덱싱을 위해서 별도의 알고리즘이 필요하다.   
  
전문 검색 인덱스 알고리즘에 대해 알아본다.  
어근 분석 알고리즘 , n-gram 알고리즘 , 불용어 처리에 대해 알아본다.  
  
<br>  
  
### 8.6 함수 기반 인덱스  
일반적으로는 특정 칼럼에 대해서만 인덱싱이 이뤄진다. (예. id 칼럼을 인덱스로 정함)  
하지만 때로는 칼럼의 값을 변형해서 인덱스를 구축해야 할 때도 있다.  
이럴 때 함수 기반 인덱싱을 사용한다.  
  
2가지 방법이 있다  
1. 가상 칼럼을 이용한 인덱스   
2. 함수를 이용한 인덱스   

위 두 방법에 대해 간략히 본다.  
  
<br>  
  
### 8.7 멀티 밸류 인덱스  
전문 검색 인덱스를 제외하곤 모든 인덱스들이 데이터 1개에 1개의 인덱스 값을 가진다.  
즉, 데이터와 인덱스 키가 1:1 관계를 갖는다.  
  
하지만 멀티 밸류 인덱스는  
하나의 데이터가 여러 인덱스 키 값을 갖는다.  
  
이는 사실 정규화에 위배되는 형태다.  
하지만 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서,   
JSON의 배열 안에 있는 값(element)에 대해 인덱스가 필요해졌다.  
따라서 이를 위해 멀티 밸류 인덱스가 등장했다.  
  
멀티 밸류 인덱스에 대해서는   
간단히 어떻게 테이블을 선언하고 또 쿼리에서 인덱스를 사용하는지 본다.  
  
<br>  
  
### 8.8 클러스터링 인덱스  
클러스터링 인덱스 개념은 지금까지 설명한 것과 크게 다르지 않다.   
다만 InnoDB 엔진을 쓰는 MySQL 에서는  
PK(Primary Key)가 비슷한 값들을 동시에 조회한다는 점에서 착안해  
PK 값이 비슷한 레코드들을 묶어서 저장하는데  
이를 클러스터링이라고 한다.  
  
클러스터링 인덱스 챕터에서는  
클러스터링 테이블 구조에 대해서 보고  
PK가 인덱스에 어떤 영향을 미치는지를 중점적으로 본다.  
  
PK 선정이 또 중요한 이유가   
MySQL에서는 PK값이 주어지면 무조건 클러스터링 인덱스를 만든다    
따라서 PK를 잘 못 잡으면 당연히 성능상에도 문제가 발생할 수 있으니  
클러스터링 인덱스에 대해서 잘 이해하고 PK를 선정해야 한다.  
    
<br>  
  
### 8.9 유니크 인덱스  
MySQL에서는 또 특이한게  
유니크 조건을 붙이면 자동으로 인덱스가 생성된다.  
따라서 그냥 유일한 값이라고 무작정 유니크 조건을 붙이게 되면  
당연하게 문제가 생길수도 있다.  
  
따라서 유니크 인덱스와 일반 세컨더리 인덱스가 어떻게 다른지 비교해보고  
성능 관점을 비롯한 주의사항에 대해서 알아본다.  
    
<br>  
  
### 8.10 외래키  
외래키 제약이 설정되면  
자동으로 연관되는 테이블까지 인덱스가 생성된다.  
  
여기서 외래키 인덱스가 대해 갑자기 등장한 이유는  
부모 - 자식 테이블 간에서  
한쪽 테이블이 외래키 관련 컬럼을 변경(ex.UPDATE) 하는 중이라면(트랜잭션)      
다른 한쪽에서는 접근할 수 없게 락이 걸린다.  
  
따라서 외래키와 인덱스 락 등에 대해 이해 해야지  
락으로 인해서 발생할 문제를 예상하고 DB를 설계할 수 있다.  
  
  
  
---
  
 
# 8.3 B-Tree 인덱스  
  
### 1. 기본 개요  
![image](https://user-images.githubusercontent.com/101965836/185101485-f9c8cb7f-bace-4e34-8de3-adf7c4a2b8de.png)  
[출처](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)  
   
위 그림은 숫자를 B-Tree에 따라서 정렬한 예시이다.   
데이터를 찾아들어가는 과정과 함께 B-Tree에 대해 알아보자.  
  
먼저, 제일 처음 들어오면 10과 20이 보인다.   
여기를 **루트 노트(Root Node)** 라고 한다.   
  
1. 만약 5를 찾을려 했다면, 10보다 작으니 왼쪽으로 가면 된다.  
2. 만약 15를 찾으려 했다면, 10초과 20미만이니 10 오른쪽 20 왼쪽으로 가면 된다.  
3. 만약 20을 찾으려 했다면, 곧바로 20이 있으니 20으로 가면 된다.  
  
딱 직관적으로 어떤 구조인지 이해가 될 거다.  
  
<br>  
   
### 2. 일반 B-Tree 구조와 SQL의 B-Tree 인덱스간의 차이점
![image](https://user-images.githubusercontent.com/101965836/185111664-4933d5c8-2b14-4b3b-b04f-2f69d64b6f22.png)  
[출처](https://12bme.tistory.com/138)   
   
1. 위 그림에서는 **정렬 기준이 곧 데이터지만**     
SQL의 B-Tree 인덱스에서는 **정렬 기준이 별도의 인덱스 키** 이다    
    
2. 위 그림에서는 **마지막 노드 전에 찾으려는 값이 있으면 바로 꺼낼 수 있지만**    
SQL의 B-Tree 인덱스에서는 **앞쪽 노드들은 "키-자식노드 주소" 구조이고, 마지막 노드만 "키-프라이머리 키" 구조로 직접 데이터로 접근 가능하다**  
  
  <br>  
  
### 3. 구조 & 이름  
앞선 그림처럼 B-Tree는  
1️⃣ -> 2️⃣ -> 3️⃣ -> ... -> N    
이렇게 1층부터 3층 ... N층까지 계속 값을 찾아들어가는 식이다.  
**B-Tree는** Binary가 아니라 **Balanced** Tree 이며  
**각 노드**에다가는 2개만 저장하는 게 아니라 **여러 개씩 저장**할 수 있다.  
  
제일 먼저 접근하는 1층을 앞서 말했듯 **루트 노트(Root Node)**  
중간에 있는 2층 ... N-1층 을 **브랜치 노드(Branch Node)**  
마지막 N층은 **리프 노트(Leaf Node)** 라고 한다.   
    
<br>  
  
### 4. SQL에서 B-Tree 인덱스 
앞서 3. 에서 차이점 비교로 잠깐 봤던 내용인데,  
마지막 층인 리프 노트만 직접 데이터로 접근할 수 있는 PK 값을 갖고 있다.   
  
> ### 왜 SQL B-Tree 인덱스는 다른지 추측   
> 아마 DB에는 10만건 100만건씩 저장되고, 각 노드는 엄청 많은 인덱스를 갖고 있을 것이다.
> 무슨 말이냐면,  
> 예를 들어 각 노드가 100개씩 인덱스-자식노드 주소 를 갖고 있을 것이다.  
> 그러면 루트에 100개, 브랜치에 100개, 리프에 100개 이런식으로 가질 수 있다. (실제로 그런게아니라 예를들어서)  
> 그러면 총 100 * 100 * 100 = 100만 개의 데이터가 저장되어 있다.           
> 따라서 대부분의 경우에는 리프노트까지 가야지 찾고자 하는 값이 있을 것이다.  
> (리프 전에 찾을 확률은 1만/100만 이므로 1%밖에 안된다)  
> 그러므로 루트와 브랜치에는 PK를 저장해봤자 고작 1% 케이스에서만 효율적여지므로    
> 그냥 리프노트에만 값을 두는 것 같다.    
  
<br><br>

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제  
결론부터 말하면  
인덱스 키에 변경이 있으면,   
경우에 따라 노드에 저장된 데이터들을 빼고 넣고 막 자리 바꾸기를 해야해서  
비용이 많이 발생할 수 있다.  
  
이를 이해하려면   
  
1. SQL B-Tree 노드는 어떻게 생겼고, 얼마만큼 저장할 수 있는가
2. 만약 노드가 가득차면, 어떤 일이 생길까?  
  
위 내용들을 알아야 한다.  
  
### 왜 위에 2가지 내용들을 알아야 할까?  
결국 자료 구조의 성능 문제는 a. 데이터 읽기 b. 데이터 I/O 에서 발생한다  
근데 B-Tree는 앞서 대충 알아봤듯  
정렬 + 트리 구조를 통해서 데이터에 빨리 접근하려고 만들어낸 구조다.  
그러면 빨리 접근할려면 반대로 데이터 I/O 성능에서 문제가 있지 않겠는가?  
대게는 Trade Off 관계니까.  
  
따라서 B-Tree I/O를 이해하기 위해서 각 노드는 어떤 구조인지 다시 알아야 하고,    
B-Tree I/O 과정에서 발생하는 "노드가 가득 차면?" 에 대해서 알아본다.  
  
