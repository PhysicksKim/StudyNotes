# Chapter 8. 인덱스  
  
DB 쿼리 성능을 향상시키려면 인덱스 활용이 중요할 것이다.  
반대로 인덱스의 남용 오용은 오히려 Insert Update 성능을 떨어뜨릴 수 있다.  
따라서 개발자는  
인덱스가 어떻게 동작하는지 이해해야지  
이를 바탕으로 쿼리문을 쓸 때 인덱스가 잘 활용될 수 있는 형태로 쓰고,  
DB 모델링도 인덱스 활용 방식을 고려해서 잘 쓸수 있다.  
  
그러므로 인덱스는 성능 향상을 위해 꼭 탄탄히 짚고 넘어가야 한다고 생각한다.  
  
> 미래의 누군가를 위해 글을 남겨두자면   
> 기본적인 SQL 공부를 마치고 나서 realMySQL을 처음 공부했을 때,      
> 제일 처음으로 08. 인덱스 단원부터 공부했다.  
> 딱히 어떤 의도가 있는건 아니고  
> 그냥 인덱스쪽이 도대체 어떻게 동작하는지 너무 궁금해서  
> 앞단원 스킵하고 인덱스부터 봤다.  
>   
> 근데 막상 인덱스 단원을 공부하면서 느낀건  
> 자신이 **궁금한 부분**이 있으면, **그 부분부터 공부**하는게 좋은것 같다.  
> 인덱스부분을 공부하다가 InnoDB엔진 같은 앞단원에 관한 단어가 나오면  
> "어? InnoDB가 뭐지" 하고 자연스러운 흐름속에서 궁금증을 갖게되고  
> 이런 호기심이 받쳐줘서 내용이 머릿속에 더 잘 들어온다  
>   
> realMySQL **책 자체**가  
> MySQL에 대한 아주 **심층적인 내용**을 다루고 있기 때문에  
> 이렇게 호기심 바탕으로 퍼져나가는게 좋은 것 같다.  
  
---

# 8.1 디스크 읽기 방식   
  
#### Q. DB 테이블은 어디에 저장되어있을까?  
#### A. 저장장치에 저장되어있다.  
따라서 DB 성능을 올리기 위해서는 저장장치에 최소한으로 접근하는 것이 중요하다.  
이말인 즉, 최소한으로 테이블을 읽는것이 성능상 유리하다는 것이다.  
사실 어찌보면 당연한 말이지만 좀 더 풀어서 이야기해보자.  
   
실행중인 **앱은 메모리**에 올라가있지만  
**DB 테이블** 데이터들은 **저장장치**에 들어있다.  
근데 **이게 왜 중요하냐??** 하면   
저장장치(HDD, SSD)는 CPU나 메모리보다 훨씬 느리기 때문이다.  
따라서 저장장치에 요청이 더 많을수록 쿼리의 성능은 더 느려질것이다.   
  
하지만 이렇게 느린 저장장치일지라도  
속도가 **빠른** 접근 방법이 있고  
속도가 **느린** 접근 방법이 있다.  
**순차 I/O** 와 **랜덤 I/O** 가 바로 그 두 방법이다.  
  
## - 순차 I/O vs 랜덤 I/O
  
![image](https://user-images.githubusercontent.com/101965836/184498411-b9032b27-3c1c-4fea-b08b-839a231c1ce3.png)   
위 그림을 보자.  
순차(Sequential) I/O 는 그림의 위 처럼    
1 2 3 4 5 이렇게 순서대로 이동한다.  
  
하지만 랜덤(Random) I/O 는 그림의 아래 처럼    
하나를 읽은 다음에 어디로 가야할지 데이터를 얻고 이동해야 한다.  
  
따라서 쉽게 집작할 수 있듯  
랜덤 I/O가 더 오래걸린다.  
  
물론 깊게 들어가서 성능 비교를 한다면  
굉장히 복잡한 부분이 있다고 한다.    
하지만 일단 간단하게 이렇구나 정도로만 알아두자  
  
---

# 8.2 인덱스란? 
SELECT 문의 성능을 위해서   
테이블을 어떤 기준을 잡고 정렬해둔 것을 말한다.  
  
예를들어 어떤 테이블의 name 칼럼에 kim lee park ... 이렇게 10만명의 이름이 저장되어 있다고 해보자.  
그러면 여기서 where='park' 으로 찾을려면  
SQL이 어떻게 동작하게 될까?      
  
### 1. 만약 name이 정렬되어 있지 않다면?  
처음부터 끝까지 일일이 name 이 뭔지 보고 비교해야한다.  
즉 10만개의 행이 있다면, 10만개를 일일이 비교해야한다.  
  
### 2. 만약 name이 정렬되어 있다면?   
a b c 순서대로 name이 정렬되어 있다면  
k인 부분으로 바로 가서 kim을 찾는게 더 빠르지 않겠는가?  
또 만약 ki까지 정렬되어 있는걸 바로 찾고  
kim을 찾으면 더 빠를것이다.  
따라서 정렬되어 있다면, 적어도 10만개를 일일이 확인하지는 않아도 된다.  
  
### 결론  
데이터를 정렬해놓으면, 특정 데이터를 찾을 때 더 빨리 찾을 수 있다.  
  
따라서 적절한 인덱스 사용으로  
select문의 성능을 향상시킬 수 있다.  
  
<br>  
  
## 근데 왜 인덱스에 대해 깊게 알아야 할까?  
앞서 **"적절한 인덱스 사용"** 이라고 했다.  
그럼 반대로 **"적절하게 사용하지 않는다면"** 무슨 일이 생길 수 있다는 것이다.  
  
당연히 인덱스는 성능에 관한 사항이니까    
잘 못 사용하면 인덱스를 제대로 활용할 수 없다는 말이다.  
  
### 제대로 사용하려면?  
1. 인덱스를 적절하게 만들고  
2. 쿼리문을 적절하게 써야 한다  
  
제대로된 인덱스를 활용했다면 0.1초면 끝날 작업을  
쿼리문을 잘 못 써서 인덱스를 활용하지 못하고 10만개를 다 탐색하는 경우도 있다.  
  
### 따라서, 인덱스 원리를 알고 제대로 써야한다  
그냥 인덱스 달아둔다고 DBMS가 다 알아서 해주는 게 아니다  
DBMS의 옵티마이저가 작동해서 쿼리문을 어느정도 최적화해주기도 하지만  
그렇다고 옵티마이저가 무적은 아니다.  
  
예를들어  
index가 name으로만 정렬되어 있는데  
where문에서 age 조건으로 찾는다면?  
당연히 name과 age는 무관하니까 10만개를 다 찾아봐야 할 것이다.  
  
또한 name과 age 둘 다 정렬되어 있다고 하더라도  
name = 'kim' AND age > 20  
이렇게 되어 있다면   
name과 age 인덱스는 따로따로 정렬되어 있기 때문에  
한번에 딱 여기서부터 여기까지라고 정할 수 없을 것이다.  
  
몇 가지 더 추가적인 의문이 들 수 있지만  
일단은 간단히 이 말만 알아두자  
### 인덱스는 적절한 사용법을 알지 못하면 의미가 없다. 따라서 작동원리를 알아야 한다.    

<br>

### 인덱스 장단점  
장점 : SELECT문이 빨라진다 
단점 : 데이터 저장(INSERT UPDATE DELETE)이 느려진다. (추가될때마다 인덱스를 다시 정렬해줘야 하니까)  
  
<br><br><br>

---

# 미리 훑어보기  
  
### 8.3 B-Tree(Balanced) 인덱스  
먼저 가장 흔히 사용되는 B-Tree 인덱스에 대해서  
어떤 구조로 이루어져 있고 어떻게 동작하는지 본다.  
   
당연하게도 자료구조에 따라서 데이터 입출력 비용이 달라진다.  
그러므로 인덱스의 기본적 구조인 B-Tree에 대해서 먼저 알아본다.  
    
그다음 B-Tree 인덱스를 통한 읽기 방법들에 대해 본다.  
1. 인덱스 레인지 스캔  
2. 인덱스 풀 스캔  
3. 루스 인덱스 스캔  
4. 인덱스 스킵 스캔  
  
이후 B-Tree 다중 칼럼, 정렬, 가용성과 효율성에 대해 알아본다.  
  
  <br>  
  
### 8.4 R-Tree 인덱스  
여기서 R은 Rectangle을 뜻하며  
B-Tree 방식을 공간 정보 저장에 활용한 것이다.  
공간 인덱스(Spatial Index)를 통해 2차원 데이터를 인덱싱하는 방법에 대해 알아본다.  
그리고 R-Tree 용도에 대해서도 살짝~ 본다.  
  
  <br>  
  
### 8.5 전문 검색 인덱스  
여기서 전문은 Full Text를 뜻한다.    
전문 검색은 엄청 긴 글들이 많은(게시판 내용 검색 등) 데이터 속에서   
키워드를 검색하는데 사용한다.  
  
이럴 때 당연히 Index를 통한 SELECT 성능 향상이 중요하고,    
그렇다고 무작정 이전에 나온 B-Tree 방식으로는 인덱싱하기에는 부적절하다.    
따라서 전문 검색(Full Text) 인덱싱을 위해서 별도의 알고리즘이 필요하다.   
  
전문 검색 인덱스 알고리즘에 대해 알아본다.  
어근 분석 알고리즘 , n-gram 알고리즘 , 불용어 처리에 대해 알아본다.  
  
<br>  
  
### 8.6 함수 기반 인덱스  
일반적으로는 특정 칼럼에 대해서만 인덱싱이 이뤄진다. (예. id 칼럼을 인덱스로 정함)  
하지만 때로는 칼럼의 값을 변형해서 인덱스를 구축해야 할 때도 있다.  
이럴 때 함수 기반 인덱싱을 사용한다.  
  
2가지 방법이 있다  
1. 가상 칼럼을 이용한 인덱스   
2. 함수를 이용한 인덱스   

위 두 방법에 대해 간략히 본다.  
  
<br>  
  
### 8.7 멀티 밸류 인덱스  
전문 검색 인덱스를 제외하곤 모든 인덱스들이 데이터 1개에 1개의 인덱스 값을 가진다.  
즉, 데이터와 인덱스 키가 1:1 관계를 갖는다.  
  
하지만 멀티 밸류 인덱스는  
하나의 데이터가 여러 인덱스 키 값을 갖는다.  
  
이는 사실 정규화에 위배되는 형태다.  
하지만 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서,   
JSON의 배열 안에 있는 값(element)에 대해 인덱스가 필요해졌다.  
따라서 이를 위해 멀티 밸류 인덱스가 등장했다.  
  
멀티 밸류 인덱스에 대해서는   
간단히 어떻게 테이블을 선언하고 또 쿼리에서 인덱스를 사용하는지 본다.  
  
<br>  
  
### 8.8 클러스터링 인덱스  
클러스터링 인덱스 개념은 지금까지 설명한 것과 크게 다르지 않다.   
다만 InnoDB 엔진을 쓰는 MySQL 에서는  
PK(Primary Key)가 비슷한 값들을 동시에 조회한다는 점에서 착안해  
PK 값이 비슷한 레코드들을 묶어서 저장하는데  
이를 클러스터링이라고 한다.  
  
클러스터링 인덱스 챕터에서는  
클러스터링 테이블 구조에 대해서 보고  
PK가 인덱스에 어떤 영향을 미치는지를 중점적으로 본다.  
  
PK 선정이 또 중요한 이유가   
MySQL에서는 PK값이 주어지면 무조건 클러스터링 인덱스를 만든다    
따라서 PK를 잘 못 잡으면 당연히 성능상에도 문제가 발생할 수 있으니  
클러스터링 인덱스에 대해서 잘 이해하고 PK를 선정해야 한다.  
    
<br>  
  
### 8.9 유니크 인덱스  
MySQL에서는 또 특이한게  
유니크 조건을 붙이면 자동으로 인덱스가 생성된다.  
따라서 그냥 유일한 값이라고 무작정 유니크 조건을 붙이게 되면  
당연하게 문제가 생길수도 있다.  
  
따라서 유니크 인덱스와 일반 세컨더리 인덱스가 어떻게 다른지 비교해보고  
성능 관점을 비롯한 주의사항에 대해서 알아본다.  
    
<br>  
  
### 8.10 외래키  
외래키 제약이 설정되면  
자동으로 연관되는 테이블까지 인덱스가 생성된다.  
  
여기서 외래키 인덱스가 대해 갑자기 등장한 이유는  
부모 - 자식 테이블 간에서  
한쪽 테이블이 외래키 관련 컬럼을 변경(ex.UPDATE) 하는 중이라면(트랜잭션)      
다른 한쪽에서는 접근할 수 없게 락이 걸린다.  
  
따라서 외래키와 인덱스 락 등에 대해 이해 해야지  
락으로 인해서 발생할 문제를 예상하고 DB를 설계할 수 있다.  
  
  
  
---
  
 
# 8.3 B-Tree 인덱스  
  
### 1. 기본 개요  
![image](https://user-images.githubusercontent.com/101965836/185101485-f9c8cb7f-bace-4e34-8de3-adf7c4a2b8de.png)  
[출처](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)  
   
위 그림은 숫자를 B-Tree에 따라서 정렬한 예시이다.   
데이터를 찾아들어가는 과정과 함께 B-Tree에 대해 알아보자.  
  
먼저, 제일 처음 들어오면 10과 20이 보인다.   
여기를 **루트 노트(Root Node)** 라고 한다.   
  
1. 만약 5를 찾을려 했다면, 10보다 작으니 왼쪽으로 가면 된다.  
2. 만약 15를 찾으려 했다면, 10초과 20미만이니 10 오른쪽 20 왼쪽으로 가면 된다.  
3. 만약 20을 찾으려 했다면, 곧바로 20이 있으니 20으로 가면 된다.  
  
딱 직관적으로 어떤 구조인지 이해가 될 거다.  
  
<br>  
   
### 2. 일반 B-Tree 구조와 SQL의 B-Tree 인덱스간의 차이점
![image](https://user-images.githubusercontent.com/101965836/185111664-4933d5c8-2b14-4b3b-b04f-2f69d64b6f22.png)  
[출처](https://12bme.tistory.com/138)   
   
1. 위 그림에서는 **정렬 기준이 곧 데이터지만**     
SQL의 B-Tree 인덱스에서는 **정렬 기준이 별도의 인덱스 키** 이다    
    
2. 위 그림에서는 **마지막 노드 전에 찾으려는 값이 있으면 바로 꺼낼 수 있지만**    
SQL의 B-Tree 인덱스에서는 **앞쪽 노드들은 "키-자식노드 주소" 구조이고, 마지막 노드만 "키-프라이머리 키" 구조로 직접 데이터로 접근 가능하다**  
  
  <br>  
  
### 3. 구조 & 이름  
앞선 그림처럼 B-Tree는  
1️⃣ -> 2️⃣ -> 3️⃣ -> ... -> N    
이렇게 1층부터 3층 ... N층까지 계속 값을 찾아들어가는 식이다.  
**B-Tree는** Binary가 아니라 **Balanced** Tree 이며  
**각 노드**에다가는 2개만 저장하는 게 아니라 **여러 개씩 저장**할 수 있다.  
  
제일 먼저 접근하는 1층을 앞서 말했듯 **루트 노트(Root Node)**  
중간에 있는 2층 ... N-1층 을 **브랜치 노드(Branch Node)**  
마지막 N층은 **리프 노트(Leaf Node)** 라고 한다.   
    
<br>  
  
### 4. SQL에서 B-Tree 인덱스 
앞서 3. 에서 차이점 비교로 잠깐 봤던 내용인데,  
마지막 층인 리프 노트만 직접 데이터로 접근할 수 있는 PK 값을 갖고 있다.   
  
> ### 왜 SQL B-Tree 인덱스는 다른지 추측   
> 아마 DB에는 10만건 100만건씩 저장되고, 각 노드는 엄청 많은 인덱스를 갖고 있을 것이다.
> 무슨 말이냐면,  
> 예를 들어 각 노드가 100개씩 인덱스-자식노드 주소 를 갖고 있을 것이다.  
> 그러면 루트에 100개, 브랜치에 100개, 리프에 100개 이런식으로 가질 수 있다. (실제로 그런게아니라 예를들어서)  
> 그러면 총 100 * 100 * 100 = 100만 개의 데이터가 저장되어 있다.           
> 따라서 대부분의 경우에는 리프노트까지 가야지 찾고자 하는 값이 있을 것이다.  
> (리프 전에 찾을 확률은 1만/100만 이므로 1%밖에 안된다)  
> 그러므로 루트와 브랜치에는 PK를 저장해봤자 고작 1% 케이스에서만 효율적여지므로    
> 그냥 리프노트에만 값을 두는 것 같다.    
  
<br><br><br>  

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제  
결론부터 말하면  
인덱스 키에 변경이 있으면,   
경우에 따라 노드에 저장된 데이터들을 빼고 넣고 막 자리 바꾸기를 해야해서  
비용이 많이 발생할 수 있다.  
  
이를 이해하려면   
  
1. SQL B-Tree 노드는 어떻게 생겼고, 얼마만큼 저장할 수 있는가
2. 만약 노드가 가득차면, 어떤 일이 생길까?  
  
위 내용들을 알아야 한다.  
  
### 왜 위에 2가지 내용들을 알아야 할까?  
결국 자료 구조의 성능 문제는 a. 데이터 읽기 b. 데이터 I/O 에서 발생한다  
근데 B-Tree는 앞서 대충 알아봤듯  
정렬 + 트리 구조를 통해서 데이터에 빨리 접근하려고 만들어낸 구조다.  
그러면 빨리 접근할려면 반대로 데이터 I/O 성능에서 문제가 있지 않겠는가?  
대게는 Trade Off 관계니까.  
  
따라서 B-Tree I/O를 이해하기 위해서 각 노드는 어떤 구조인지 다시 알아야 하고,    
B-Tree I/O 과정에서 발생하는 "노드가 가득 차면?" 에 대해서 알아본다.  
  
<br>  

## 1. SQL B-Tree 구조 / 얼마나 저장 가능?   
![image](https://user-images.githubusercontent.com/101965836/185111664-4933d5c8-2b14-4b3b-b04f-2f69d64b6f22.png)  
[출처](https://12bme.tistory.com/138)     
  
노드 타고 들어가서 데이터로 접근하는 개념은 앞서 설명했다.   
이때 더 중요한건 "각 노드가 얼마만큼 저장하는가?" 이다.  
  
### 페이지
Inno DB 엔진에서는  
데이터를 저장하는 기본 단위를 페이지(Page) 또는 블록(Block) 이라고 한다.  
디스크의 모든 I/O와 Read 의 기본이 페이지가 된다.  
당연히 인덱스도 페이지 단위로 관리되며,  
루트, 브랜치, 리프 노드들 모두 페이지로 구분된다.  
  
<br>  
  
### 이진 트리 vs B-Tree
이진 트리는 자식 노드를 2개만 가지는데 반해서  
B-Tree는 여러 자식 노드를 가질 수 있다.  
  
<br>  
  
### B-Tree 자식 노드는 가변적이다   
각 데이터의 크기가 클수록  
한 페이지에 담을 수 있는 자식 노드들도 적어질 것이다.  
  
각 페이지의 크기는 default 16KB 이며,  
innodb_page_size 라는 시스템 변수를 이용해서 4KB ~ 64KB 사이 값으로 조절할 수 있다.  
  
<br>  
  
### 한 페이지에 저장할 수 있는 데이터 수는?  
예를 들어  
  
| 인덱스 (사용자 ID) | 자식 노드 주소 |
|---|---|
|abcdef|&000100|
|aaa123|&000200|
|...|...|
  
이런식으로 구성되어 있다고 해보자.     
각각은 16바이트, 12바이트로 구성되어 있으면  
하나의 데이터는 각각 28바이트이며  
16\*1024/28 = 585 개의 인덱스를 저장할 수 있다.  
    
만약 여기서 인덱스가 길어져서 각각 데이터 하나의 용량이 커지면  
그만큼 저장할 수 있는 인덱스가 적어지고  
이는 곧 가장 느린 "디스크 읽기"를 더 많이 해야한다는 뜻이 된다.  
  
<br>  
  
## 2. 만약 노드가 가득차면, 어떤 일이 생길까?  
데이터가 추가되면 인덱스 키도 인덱스 페이지에 추가될 것이다.  
그러다가 인덱스 페이지가 가득 차면 어떻게 될까?  
  
### 인덱스 키 추가 / 만약 가득 차면  
새로운 키가 Leaf 노드에 저장되어야 하는데  
만약 가득찬다면 Leaf 노드를 분리(Split)해야 할 것이다.  
  
그러면 상위 브랜치 노드까지 처리 작업이 또 이뤄져야 한다.  
분리되는 노드의 주소와 인덱스도 상위 브랜치 노드에 추가되어야 하고,  
이러면 또 다시 루트 노드까지 작업이 확장된다.  
  
이러한 탓에   
인덱스 키 추가로 노드가 가득차서 분리해야 한다면  
단순히 Leaf 노드만 분리되고 끝이 아니라  
그 위에 브랜치, 루트 노드까지 추가 작업이 이루어 진다.  
  
따라서 쓰기 작업에는 비용이 많이 발생한다.  

<br><br>  

## 삭제도 알아보자  
좀 간단하다.  
리프 노드에서 찾아서 그냥 삭제 마킹만 하면 된다.   
삭제 마킹된 곳은 그대로 방치해도 되고 재활용할 수도 있다.  
    
키를 삭제한다고 마킹하는 작업도 디스크 쓰기작업으로 이뤄진다.  
따라서 키 삭제에도 디스크 I/O가 이뤄진다.  
  
하지만 이런 부분들은 Inno DB 엔진에서 버퍼링되어 지연 처리된다.  
지연 처리? 뭔말일까  
  
<br><br>  

## 지연 처리  
인덱스가 변하면 이리저리 인덱스 페이지들을 건드려야 하므로  
디스크 I/O 작업이 이리저리 이뤄진다.  
  
따라서 얼마나 오래걸릴지 확신할 수 없는 작업이므로 (뇌피셜)  
INSERT, UPDATE, DELETE 같은 작업들은  
인덱스 관리를 위해서 추가 작업이 이뤄질 수 있으므로  
Inno DB 엔진 같은 경우에는 지연시켜서 나중에 처리한다  
이에 대해서는 "체인지 버퍼"(책 4.2.10)를 알아보면 된다.   
  
<br><br><br>  

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소  
1. 인덱스 키 값의 크기
페이지 단위로 데이터를 읽음.
인덱스 크기가 커지면 한 페이지에 들어가는 레코드 수가 줄어듦.
따라서 인덱스 키의 크기가 크면 효율이 떨어짐.  
  
2. B-Tree 깊이 :
Tree의 깊이를 말한다.  
근데, 어차피 아무리 큰 DB라도 5단계 이상 깊어질 일은 없으니, 깊이는 큰 의미 없다.   
   
3. 기수성(선택도) :
유니크한 값의 수.  
극단적으로 인덱스 키 값은 10개 뿐인데 데이터가 100만건이라면, 인덱스가 의미 없어진다  
  
4. 읽어야 하는 레코드 수
예를 들어 100만 건이 있는 테이블에서 50만건을 가져와야 한다고 해보자.
인덱스로 50만건을 가져오기 vs 그냥 테이블을 50만건 읽기    
라고 했을 때 그냥 테이블 50만건 읽는 게 더 빠르다.  
보통의 DB는 인덱스 1건 읽는게 직기보다 4~5배 비용이 드는 것으로 판단한다.  
따라서 전체 레코드의 20~25%를 넘어서면, 그냥 Full Scan을 해버리는 게 더 좋다고 판단한다.  

<br><br><br>  

## 8.3.4 인덱스 Scan의 종류  

### 1) 인덱스 유니크 스캔
인덱스로 딱 1건 찾을 때 사용함.  
가장 인덱스의 강한 효과를 볼 수 있음.  
  
```sql
SELECT * FROM employees
	WHERE first_name = 'Ebbe';
```
  
<br>  

### 2) 인덱스 레인지 스캔  

범위를 찾을 때 사용하는 방법.  
비교 연산자(\<, \>, \<=, \>=)나 BETWEEN, IN 등에 사용됨.  
시작점을 인덱스로 찾고, 조건을 만족할 때까지 행을 찾는 방식이다.  

```sql
SELECT * FROM employees
	WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

위 예시를 바탕으로 설명하면    
(1) 인덱스로 'Ebbe'를 먼저 찾음    
(2) 이후 순차적으로 다음 데이터가 조건에 맞는지 체크해나감.    
  
여기서 아래와 같은 의문이 들 수 있다.  
  
> "그냥 'Ebbe' 찾고 'Gad' 찾은 다음,  
> 그 중간은 체크 안하고 전부 긁어오면 되는 거 아냐?"  
    
이에 대해 두 가지 답변을 할 수 있는데.  
  
1. 혹시, 루스 인덱스 스캔이나 인덱스 스킵 스캔 방식을 생각한 것일 수 있다. 곧바로 다음에 나오니까 그걸 읽어보자.  
  
2. 위 방법을 적용할 수 있는지를 한방에 판별할 방법이 없다. 예를들어 age BETWEEN 20 AND 30 했다면, 만족하는 값이 3개라면 순차읽기가 더 나을테고, 테이블 전체라면 당연히 앞서 설명한 방법이 더 낫다. 하지만 이를 알 방법이 없으니, 차라리 그냥 쭉 읽어나가는 게 일반적으로 더 빠르다고 DBMS들이 생각하는 것 같다.  
  
> ### 추가 뇌피셜  
> 전부 긁어올 수 있다면 그게 나을 수 있다.  
> 하지만 DB 특성상(HDD에 저장되므로) Random Access가 안되고 I/O 비용이 크므로     
> 앞서 말한 더 나은 방법은 오히려 비용이 더 들수 있다.    
> 즉, DB는 가능한 한 I/O를 피하도록 설계되므로,    
> 그냥 Sequential Access 최대한 이용하는 방향으로 동작한다.    
> 다만 절대적인 것은 아니다.   
> DBMS 정책, 데이터 분포, 테이블 크기, 하드웨어 성능 등에 따라서 동작 방식이 달라질 수 있다.  
  
<br>  
  
### 3) 인덱스 풀 스캔   
테이블 풀 스캔처럼 전부 스캔하지만, 인덱스 키를 스캔한다.      
이는 인덱스의 크기가 테이블 보다 작으므로 더 효율적이다.  
   
구체적인 이유는    
테이블 전체를 불러오는 것 보다 인덱스 전체를 불러오는 게     
더 적은 I/O 로 전체를 가져올 수 있기 때문이다.   
    
그러나 **인덱스 풀 스캔**의 경우    
일반적으로 인덱스를 사용한다고 표현하지 않는다.    
인덱스 풀 스캔은 인덱스를 효율적으로 사용하지 못해서 전부 다 탐색해야 하는 어쩔 수 없는 경우에 일어난 것이기 때문이다.   
  
<br>  

### 4) 루스 인덱스 스캔 (Loose Index Scan)  
GROUP BY + MIN() MAX() 쓸 때 사용함  

(1) 인덱스로 GROUP별 첫 row 찾음    
(2) GROUP에서 MIN() 또는 MAX()의 ROW 갖고옴 (인덱스로 찾은 첫 row가 MIN 또는 MAX니까)
(3) GROUP의 그 외의 ROW는 찾을 필요 없으니 바로 다음 GROUP 으로 넘어감  
  
핵심은, 중간에 필요하지 않은 인덱스 키 값은 무시하고 넘어가는 방식이다.   
  
> Oracle 에서는 Index Skip Scan 이라 한다.  
    
- 예시  
    
Student 테이블에서 year(학년) 별로 가장 height(키)가 작은 학생을 찾는다고 해보자.  
그러면 GROUP BY year 로 아래와 같은 쿼리가 짜여질거다.  

```sql
SELECT year, MIN(height) FROM Student
	GROUP BY year;
```
  
이때 인덱스가 year과 height에 둘 다 걸려있다면  
year로 첫 번째 요소 찾은 후 height 도 처음꺼 딱 짚고  
바로 다음 year로 넘어가는 방식이다.  
    
<br>  

### 5) 인덱스 스킵 스캔  
예시부터 보자.  
    
아래와 같은 인덱스와 쿼리가 있다고 하자  
    
```sql
ADD INDEX ix_gender_birthdate (gender, birth_date)
```
  
```sql  
SELECT gender, birth_date FROM employees
	WHERE birth_date >= '1965-02-01';
```

|gender|birth_date|
|---|---|
|M|'1965-01-20'|
|M|'1965-02-01'|
|M|'1965-02-12'|  
|M| ... |

|중간생략|중간생략|
|---|---|
|F|'1965-01-03'|
|F|'1965-02-01'|
|F|'1965-03-24'|
|F|...|

이런 경우에 앞선 쿼리는 아래와 같이 2개로 나눠서 실행하는 게 더 좋을거다  
  
```sql  
SELECT gender, birth_date FROM employees
	WHERE gender='M' AND birth_date >= '1965-02-01';
SELECT gender, birth_date FROM employees
	WHERE gender='F' AND birth_date >= '1965-02-01';
```

이러한 작업을 DB가 알아서 판단하고 해주는 게 인덱스 스킵 스캔이다  

<br><br>  

## 루스 인덱스 스캔 VS 인덱스 스킵 스캔  
두 방식은 유사하지만 다르다.  

- 루스 인덱스 스캔 : group별로(GROUP BY) 첫 row 찾아 읽은 다음, 다음 group으로 바로 넘어감  
- 인덱스 스킵 스캔 : group별로(다중 INDEX의 상위 index) 첫 row 찾아 읽은 다음, 조건에 맞지 않을 때 까지 순차적으로 읽고, 조건에 어긋나는 row 찾은 순간 다음 group으로 넘어감.   
  
둘의 같은 점은 index를 써서 첫 row 를 찾아 들어간다는 점이고  
차이점은 첫 row 이후에 바로 다음 group으로 넘어갈 것인지,  
아니면 순차읽기로 range를 scan해야 하는지에 차이가 있다.  
  
두 방식이 비슷하게 동작하지만 이름은 유사하지 않은데  
그 이유는 명확히 모르겠지만   
아마도 두 방식이 적용되는 쿼리 예시가 좀 상황이 다르기 때문이라고 생각한다.  

루스 인덱스 스캔은 GROUP BY + MIN 또는 MAX 를 쓸 때 사용되는 최적화 방식이고,  
인덱스 스킵 스캔은 다중 Column 인덱스가 잡혀있지만 모든 column에 대해서 조건문을 걸어주지 않았을 때 최적화 하는 방식이다.  
  
그래서 두 방식이 적용되는 맥락이 연관이 없어서 이름을 통일성있게 맞추지 않은 것 같다.  
  
> 근데 중간에 row를 스킵한다는거나 
> 인덱스 덕분에 첫 row 를 쉽게 찾을 수 있다는 점을 활용한 게 비슷하니까  
> 두 방식의 이름을 좀 유사하게 지었으면 좋았을텐데 싶은 생각이 든다.  
  
<br><br><br>

## 8.3.5 다중 칼럼 인덱스  
