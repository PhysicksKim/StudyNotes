# CH5 트랜잭션과 잠금  
  
동시성에 영향을 미치는 잠금과 트랜잭션 격리 수준(Isolation Level) 에 대해 알아본다  
  
---

# 5.1 트랜잭션  

스토리지 엔진별로 보면    
InnoDB는 트랜잭션을 지원하고    
MyISAM이나 MEMORY 는 트랜잭션을 지원하지 않는다  
    
InnoDB는 트랜잭션 덕분에  
데이터 무결성, 동시성 문제, 복구 문제 등을 해결할 수 있다.  
  
반면 MyISAM 이나 MEMORY 는 트랜잭션이 없어서 대안이 필요한데  
트랜잭션과 같은 로직을 애플리케이션 레벨에서 구상해내야 한다  
  
```
...
if(data_insert1_succeed) {
  ...
  if(data_insert2_succeed) {
    ...
    if(data_insert3_succeed) {
    ...
    }
  }
}
```
   
이렇게 if문을 중첩해주지 않으면 부분 업데이트(Partial Update) 문제가 발생한다.  
  
그래서    
잘 모른다면 트랜잭션 때문에 너무 번거롭다고 생각할 수 있겠지만     
반대로 트랜잭션이 없으면 데이터에 문제가 생기거나 위처럼 애플리케이션 차원에서 코드가 지저분해진다.  
  
<br>  

# 5.2 MySQL 엔진 잠금  
   
제목에서 엔진 잠금이라고 했는데   
잠금 레벨에 따라서     
    
1. MySQL 엔진 레벨 잠금     
2. 스토리지 엔진 레벨 잠금    
    
두 가지로 나뉜다.  
  
![image](https://github.com/PhysicksKim/TIL/assets/101965836/b21f98ea-7b3f-45f6-96c1-8c253a785254)   

<br><br>  
  
## 5.2.1 글로벌 락  
  
가장 범위가 크다.  
MySQL 전체, 즉 서버에 존재하는 모든 테이블이 잠그고    
MySQL 서버의 모든 변경 작업을 멈춘다.  

MySQL 8.0 부터는 백업 툴들의 안정적인 실행을 위해 백업 락을 도입했다.  
백업 락은 테이블 스키마나 사용자 인증 정보를 변경할 수 없도록 한다.  
백업 락은 글로벌 락과 대조적으로 **일반적인 테이블의 데이터 변경은 허용**한다.  
  
<br><br>  

## 5.2.2 테이블 락  
개별 테이블 단위로 잠근다  
특별한 상황이 아니면 애플리케이션 레벨에서는 사용할 일이 없다.  

<br><br>  

## 5.2.3 네임드 락  
    
잘 쓰이지 않음.    
네임드 락은 특정 데이터를 잠그는 게 아니라     
그냥 DB에서 하나의 작업만 일어나도록 유도하는 락이다.   
    
![image](https://github.com/PhysicksKim/TIL/assets/101965836/21e8e0ae-f4ab-44ba-8462-20a1257e08e7)   
   
예를 들어  
Special_Work 라는 작업이 DB에서 동시에 하나만 수행되어야 한다고 하자.    
그럴 때 <code>GET_LOCK('Special_Work', 10)</code>  이렇게 해서   
DB에다가 "Special_Work 가 진행중이니 다른 웹서버는 이거 하지 마라" 라는 식으로 표시해둘 수 있다.    
   
<br><br>  
  
## 5.2.4 메타데이터 락  
테이블의 뷰 같은 데이터베이스 객체의 이름이나 구조를 변경할 때 획득하는 락이다.   
  
명시적으로 획득/해제 하는 게 아니고  
<code>RENAME</code> 같은 것들을 할 때 자동으로 획득하게 된다.  
  
<br><br><br>  
  
# 5.3 InnoDB 스토리지 엔진 잠금  

스토리지 엔진 내부에서 동작하는 레코드 기반 잠금 방식  
  
레코드 기반 잠금 덕분에 MyISAM 보다 동시성 처리에서 더 뛰어남    
  
<br>  
  
## 5.3.1 InnoDB 스토리지 엔진의 잠금  
   
InnoDB는 매우 작은 단위로 효율적이게 락을 관리해서  
락 에스컬레이션을 필요로 하지 않는다   
  
> ### 락 에스컬레이션이란
> DBMS에서 최적화를 위해서 작은 단위의 락이 많아지면 그냥 큰 단위로 락을 거는 것을 말한다
> 예를 들어 레코드 락이 너무 많아서 그냥 테이블 락으로 한번에 해결하는 식으로 성능을 최적화 한다    
   
그리고  
InnoDB 엔진은 레코드락 뿐만 아니라 갭 락 이라는 특이한 락을 제공하기도 한다.    
이에 대해 이어서 설명하겠다.   
  
<br> 

### 5.3.1.1 레코드 락 (인덱스 레벨에서)  
  
레코드 자체에 락을 거는 것을 말한다.  
여기에 추가로 알아둬야 할 점이  
InnoDB 에서는 레코드 자체에 락을 걸지 않고 인덱스에다가 락을 건다는 것이다. 
인덱스 락에 대해서는 조금 뒤에서 다시 자세히 본다.  
   
> InnoDB에는 테이블마다 항상 PK와 클러스터링 인덱스가 있다.   
> 따라서 항상 데이터로 접근이 적어도 클러스터링 인덱스로 유도되기 때문에    
> InnoDB에서는 인덱스에 락을 거는 방식을 택할 수 있다.
   
### 5.3.1.2 갭 락  
일반적 DBMS와 다른 InnoDB 만의 특징이다  
레코드와 인접 레코드 사이를 잠근다.  
이렇게 해서 레코드 사이에 새로운 레코드가 Insert 되는 것을 제어한다.  
  
### 5.3.1.3 넥스트 키 락 
넥스트 키 락 = 레코드 락 + 갭 락  
넥스트 키 락을 사용하는 이유는 곧  
'레코드 락 거는 이유' + '갭 락 거는 이유' 와 동일하다  

> - 레코드락 거는 이유   
> 데이터 무결성, 동시성 유지, 트랜잭션 격리   
  
> - 갭 락 거는 이유   
> 레코드 사이 다른 트랜잭션의 삽입 방지, 레인지 검색의 일관성
  
### 5.3.1.4 자동 증가 락  
  
AUTO_INCREMENT 속성을 가지는 칼럼에 동시에 여러 레코드가 INSERT 되면 증가 값이 문제가 생길 수 있다  
그래서 AUTO_INCREMENT LOCK 이라는 "테이블 레벨 잠금" 을 사용한다    
따라서 동시에 하나의 쿼리만 AUTO_INCREMENT 가 가능해서 성능 문제가 있지 않을까 우려할 수 있지만  
AUTO_INCREMENT LOCK 은 아주 짧은 시간 동안 걸렸다가 해제되므로  
대부분 문제되지 않는다고 한다  
   
AUTO_INCREMENT LOCK 은   
INSERT REPLACE 쿼리에만 필요하며  
UPDATE DELETE 등 쿼리에는 필요하지 않다  
  
> - innodb_autoinc_lock_mode = { 0, 1, 2 }
> autoinc lock mode 는 0,1,2로 세 종류가 있다.  
> 0 : 모든 INSERT에 자동 증가 락
> 1 : INSERT 레코드 건수를 정확히 예측할 수 있을 때 래치(뮤텍스)를 이용해 처리하고, 예측할 수 없을 때는 자동 증가 락을 사용한다  
> 2 : 래치(뮤텍스)만 사용한다. 자동 증가 락을 절대 사용하지 않는다.    

<br><br>  

## 5.3.2 인덱스와 잠금 
  
매우 중요하다  
왜? 잠금 때문에 동시성 문제가 생길 수 있기 때문이다.  
    
![image](https://github.com/PhysicksKim/TIL/assets/101965836/5bb1a86d-5bc6-4f22-9d59-be9da36f098c)  
  
### 조건  
1. UPDATE 쿼리는 다음과 같다 <code>UPDATE employees SET hire_date=NOW() WHERE first_name='Smith' AND last_name='Ava';</code>
2. 인덱스는 first_name 에만 걸려 있다   
  
### 설명  
위 쿼리가 날아갔을 때 LOCK이 어떻게 걸릴까?  
정답은 <code>first_name='Smith'</code> 인 모든 레코드에 걸린다    
단지 레코드 1개만 수정하려는데 <code>first_name='Smith'</code> 인 모든 레코드에 LOCK 걸리는 것이다  
  
이에 따라서 인덱스가 적절히 걸려있지 않다면 동시성 문제가 발생할 수 있고  
심지어 인덱스가 없다면 모든 레코드를 다 잠궈서 마치 테이블 락 처럼 동작할 수도 있게 된다.  
  
그러므로 인덱스와 잠금을 이해해야지  
락으로 인한 동시성 문제를 예상할 수 있다  

