# CH07 데이터 암호화  
  
> 데이터베이스 보안은 중요한데  
> 개발자 입장에서 크게 중요하다기 보다는  
> 큰 흐름만 이해하는 게 좋아보인다.
  
  
# 7.1 MySQL 서버의 데이터 암호화  

당연히 디스크에 저장될 때만 암호화 하면 된다.  
따라서  
MySQL 서버에서 디스크 I/O 과정에서만 데이터 암호화/복호화가 일어난다.    
   
> 공격자가 DB 데이터를 채간다고 해보자.   
> 그러면 Application 내부로 당연히 침투할 수 없을테고,   
> Disk에 저장된 DB 파일을 노리려고 할 것이다.   
> 그러므로    
> 메모리 침투는 OS가 막으니까 디스크 저장될 때만 암호화 하면 된다.     
  
따라서 데이터 암호화를 설정한다고 해서  
DB를 사용하는 개발자 입장에서는 별 차이 없다.  
이러한 방식을 내부 사용자 입장에서는 차이가 없다고 해서 TDE(Transparent Data Encryption) 또는 "Data at Rest Encryption" 이라고 한다.  
  
> Data at Rest 에서 at Rest는  
> 디스크에 저장되어 있다는 뜻에서 at Rest 라고 한다.
  
<br><br>  

## 7.1.1 2단계 키 관리  
  
MySQL 서버의 데이터 암호화는 2가지 방식이 있다.  
  
1. 마스터 키  
2. 테이블스페이스 키
  
테이블 스페이스 키는 MySQL 서버 내부에서 프라이빗 키로 동작해서 외부로 노출되지 않는다.  
따라서 변경하지 않아도 보안 취약점이 없다.  
  
반면 마스터 키 경우 **외부 파일**을 이용하기 때문에 파일 자체가 노출되어서 암호를 뚫을 수 있다.  
따라서 마스터 키는 주기적으로 변경해야 한다.  
  
> 마스터 키 변경시  
> 기존 마스터 키로 복호화 한 다음
> 새 마스터키로 암호화 한다.  
  
 
<br><br>  

## 7.1.2 암호화와 성능  
  
디스크로부터 한 번 읽은 페이지는 버퍼 풀에 적재되는데  
이 때 복호화 된 상태로 적재되기 때문에 성능상에서 최적화 되어있다고 볼 수 있다.  
  
단, 최초로 디스크에 적재되는 경우에는 복호화가 필요하므로  
이 경우 추가로 시간이 걸린다.  
  
> 디스크 저장시에도 복호화 지연이 걸리는데  
> 어차피 디스크에 쓰기 동작은 백그라운드에서 알아서 돌아가므로 쿼리 반응속도에 대한 사용자 경험 입장에서는 지연이 느껴지지는 않는다.
  
<br>  
   
### 압축 후 암호화 된다    
  
![image](https://github.com/PhysicksKim/TIL/assets/101965836/c069f552-976b-4bfc-ab4d-77cee6843e5d)  
  
테이블 - 암호화 - 압축 - Disk  
순서로 일어난다면  
버퍼 풀에 암호화된 상태로 테이블이 저장되어 있는 모양이 된다.  
이렇게 되면 버퍼풀에서 테이블을 가져올 때마다 복호화 해야하므로 오버헤드가 생긴다.  
  
또한 암호화하게 되면 데이터가 규칙을 잃게 되므로 암호화 효율이 줄어든다.  
따라서 압축 효율 측면에서도 암호화 전에 압축하는 게 좋다.  
  
<br><br>  

## 7.1.3 암호화와 복제  
  
MySQL 서버를 복제해서 레플리카 서버를 만든다면 암호화는 어떻게 될까?  
  
원본 서버와 레플리카 서버는 각자 다른 마스터 키와 테이블 스페이스 키를 관리한다.  
따라서 데이터가 동일하더라도 암호화 후에는 서로 키가 다르므로 파일 내용도 달라진다.  
  
### Key Ring 파일 백업  
MySQL 서버 백업시에 Key Ring 파일을 같이 백업해둬야   
암호화된 테이블을 복호화 할 수 있다.  
  
백업시에 키링 파일도 같이 백업할 것을 명심해두자.  
  
<br><br><br>  

# 7.2 keyring_file 플러그인 설치  
  
별 어려운 내용은 없고  
주의할 점 하나는 마스터 키를 디스크에 파일로 저장하고 관리한다는 점이다.  
마스터 키 파일이 노출된다면 암호화가 무용지물이 된다.  
  
<br><br><br>  
  
# 7.3 테이블 암호화  

## 7.3.1 암호화된 테이블 생성  
  
키링 플러그인에 상관없이 암호화 테이블을 생성하는 방식은 동일하다.  
  
```SQL
CREATE TABLE test_ecrypted_table (
  id INT,
  data VARCHAR(100),
  PRIMARY KEY(id)
) ENCRYPTION='Y';
```

테이블 생성 명령 끝에 <code>ENCRYPTION='Y';</code>만 적어주면 된다  
  
### default 로 테이블 암호화 설정  
기본적으로 모든 테이블에 암호화 하고 싶다면 <code>default_table_encryption</code> 시스템 변수를 ON 으로 설정해주면 된다.  
  
<br>  

## 7.3.2 응용 프로그램 암호화  
  
애플리케이션 차원에서 데이터를 암호화 할 수도 있다.  
하지만 이 경우 MySQL 입장에서는 문자열이 그냥 들어온 것과 다를 바 없다.  

---

### 애플리케이션 암호화 X  

|id|password|
|---|---|
|kim|123456|
|park|000111|

### 애플리케이션 암호화 O  

|id|password|
|---|---|
|kim|8D969EEF6ECAD3C29A3A629280E686CF0C3F5D5A86AFF3CA12020C923ADC6C92|
|park|4718021FE01050DBDE3316FB352F7F00769BA43127B16224FAD4485EFAA7DAE8|
  
---
    
위 예시는 애플리케이션 차원에서 Password를 SHA256 으로 암호화 한 것과 안 한 것의 차이를 보여준다.  
DB 입장에서는 애플리케이션에서 암호화 했더라도 그냥 문자열로 취급하는것과 다를 바 없다.  
  
<br>  
    
### 애플리케이션 암호화의 장단점  
미리 암호화해서 저장된다면  
DB 암호화가 뚫려서 유출되더라도 패스워드가 유출되는 문제를 막을 수 있다.  
  
하지만 <code>BETWEEN</code> 이나 <code>ORDER BY</code> 를 사용할 때 의미가 없어진다.    
암호화 된 값에다가 범위 조회나 정렬을 하게 되기 때문이다.  
  
<br>

## 7.3.3 테이블 스페이스 이동  

> 테이블 스페이스 : 테이블의 물리적인 저장 데이터와 저장 공간을 말함
  
테이블 데이터를 다른 서버로 이동하기 위해 Export&Import 할 일이 생긴다.  
이 때 암호화된 테이블의 경우, 원본 서버와 목적지 서버의 암호화 키가 다르다.     
따라서 암호화된 테이블 Export 과정에서 생성되는 임시 마스터 키 .cfp 파일도 같이 복사해야 한다.    
  
<br><br><br>  

# 7.4 언두 로그 및 리두 로그 암호화  
  
과거에는 언두 로그와 리두 로그는 디스크에 그냥 평문으로 저장됐었다.   
하지만 MySQL 8.0.16 부터는 리두 로그와 언두 로그도 암호화된 상태로 저장할 수 있게 됐다.  
  
언두/리두 로그 암호화를 설정하면  
테이블에 사용되는 테이블스페이스 키와 다른, 별도의 언두/리두 로그용 암호화 키가 각각 생성된다.  
    
### 주의할 점  
암호화를 활성화 했다가 비활성화 하면 기존의 암호화 되어있던 언두/리두 로그는 어떻게 될까?  
정답은 암호화 된 채로 그대로 있다.  
  
따라서 언두/리두 로그 암호화를 비활성화 했더라도  
기존의 언두/리두 로그는 여전히 암호화 되어 있기 때문에  
기존 암호화 키를 계속해서 가지고 있어야 한다.  
    
<br><br><br>  

# 7.5 바이너리 로그 암호화  

> ### 바이너리 로그란  
> DB의 모든 변화들이 기록되는 로그.
> 데이터 복구나 Replication 에 사용한다.  
  
> ### 바이너리 로그 와 리두/언두 로그의 차이점
> 리두/언두 로그는 트랜잭션이나 갑작스런 시스템 장애 복구에 사용한다.  
> 바이너리 로그는 서버를 특정 시점으로 다시 되돌릴 때 쓴다.   
> 트랜잭션 단위보다 더 큰 규모로 롤백 해야 할 일이 생길 때 쓴다.  
  
언두/리두 로그는 짧은 트랜잭션 정도 동안만 보관하므로  
조금 유출되더라도 보안에 큰 문제가 있지 않을 수 있다.  
  
하지만 바이너리 로그는 서버의 긴 시간 이전으로 복구하는데에 사용하기 때문에  
더 많고 상세한 정보를 담고 있으므로 보안상 더 중요해진다.  
  
또한 바이너리 로그는 레플리카 서버간 데이터를 맞추기 위해 통신으로 로그가 전송되기도 하므로  
네트워크 전송 데이터를 암호화 해야 하기도 한다.  
  
<br>  

바이너리 로그 암호화 챕터는  
구체적인 설정법 및 도구 설명이 대부분이므로   
필요한 상황에서 찾아보는게 좋겠다.  
