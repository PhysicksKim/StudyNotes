# CH09 옵티마이저와 힌트  

쿼리 최적화 과정은 단순히 쿼리 문법만 보는 게 아니라  
데이터 저장된 통계도 보고 최적의 실행 계획을 수립한다.  
  
그리고 EXPLAIN 명령으로 쿼리의 실행 계획을 보고 이해하기 위해서  
옵티마이저가 어떻게 동작하는지에 대해서 어느정도 지식을 갖춰야 한다.  
  
따라서 이번 단원은  
MySQL 쿼리 최적화를 이해하기 위해서 충분히 익혀야 한다.    
  
<br><br><br> 
  
---

<br><br><br>  
  
# 9.1 개요  

DBMS 에서 옵티마이저의 동작을 온전히 이해하려면 쉽지않다.    
하지만 실행 계획을 이해해야 쿼리의 문제를 찾고 최적화를 할 수 있다.    
9.1 에서는 실행 계획을 살펴보기 전에 먼저 알고 있어야 할 사항을 보자.  
  
<br><br><br>  

## 9.1.1 쿼리 실행 절차  
  
MySQL 서버에서 쿼리가 실행되는 과정은 아래와 같다.  
  
1. 개발자가 날린 SQL문을 분해한다 - Parse Tree 만들기  
2. Parse Tree를 보고, 어떤 테이블과 어떤 인덱스를 쓸지 결정한다 - 최적화 및 실행 계획 수립
3. 실행 계획을 보고 스토리지 엔진이 데이터를 가져온다

> 두 번째 단계는 구체적으로 아래와 같은 동작을 처리한다  
> 1. 불필요한 조건 제거, 단순화
> 2. 조인이 있으면, 어떤 순서로 읽을지 결정
> 3. 조건과 인덱스 통계 정보로 인덱스 뭐 쓸지 결정
> 4. 가져온 레코드를 임시 테이블에 넣고 다시 가공할지 결정
  
<br><br><br>  
  
## 9.1.2 옵티마이저의 종류   
    
### 1. 규칙 기반 최적화(Rule-based optimizer, RBO)     
**"쿼리만"** 보고 최적화 함     
-> 최근에는 잘 사용하지 않음   
    
> (옛날에 오라클 DBMS 에서 사용했다함)     
     
<br>     
      
### 2. 비용 기반 최적화(Cost-based optimizer, CBO)  
데이터 **통계**와 **쿼리**를 **같이** 보고 실행계획 수립    
-> 쿼리 바탕으로 여러 계획을 만들고, 통계를 넣어서 cost를 계산한다      
  
<br><br><br>  
   
## 9.2 기본 데이터 처리    
    
DB에서 데이터를 어떤 알고리즘으로 처리하는지 본다.    
    
- 풀 테이블 스캔, 풀 인덱스 스캔
- 병렬 처리
- ORDER BY
- GROUP BY
- DISTINCT
- 내부 임시 테이블 활용
  
## 9.2.1 풀 테이블 스캔 / 풀 인덱스 스캔  

### 풀 테이블 스캔  
다음과 같은 조건에서 풀 테이블 스캔을 한다  
  
- 대상 테이블에 있는 레코드 수가 너무 적어서, 그냥 풀 테이블 스캔이 더 빠른 경우
- 조건에 해당하는 레코드가 너무 많아서, 그냥 풀 테이블 스캔이 더 빠른 경우
- 인덱스를 이용할 수 있는 조건이 없는 경우  

간단히 말해서  
너무 적거나, 너무 많거나, 인덱스를 쓸 수 없거나  
3가지로 보면 된다.  
  
<br>  

### "리드어헤드" 최적화 - 한꺼번에 여러 페이지 읽어오는 기능  

- 리드 어헤드(Read Ahead)  
데이터가 앞으로 필요해지리라는 것을 예측해서 디스크에서 미리 읽어 버퍼 풀에 가져다 두는 것   
  
InnoDB 엔진에는 리드 어헤드 라는 기능을 통해서    
미리미리 버퍼 풀에다가 페이지를 가져다 둔다.    
리드 어헤드가 시작되면 **백그라운드 스레드**가 데이터를 가져오도록 넘기므로    
**포그라운드 스레드**는 **백그라운드** 스레드가 버퍼 풀에 적재해둔 데이터를 가져다 쓰기만 하면 된다.    

<br>  
  
> 래퍼런스를 찾지 못했는데   
> 책에서는 리드 어헤드 작업이 처음부터 16개씩 막 가져오는 게 아니라   
> 처음에는 몇 개 가져오다가 계속해서 4개 8개 16개씩 한번에 가져오는 수를 늘려나간다고 한다.   
> 이로 미루어 봤을 때, 리드 어헤드는 처음부터 많이 읽어오는 게 아니라   
> 작업이 반복되면 이를 인식하고 다음번에 가져올 때는 한번에 뭉텅이로 가져오는 것 같다.   
    
<br><br>  

### 풀 인덱스 스캔   
인덱스를 처음부터 끝까지 스캔할 때 더 빠른 경우 사용한다.  

[참고](https://blog.naver.com/gglee0127/221336088285)  
   
```SQL
create index emp_ename_sal_idx on scott.emp(ename, sal);
```

```SQL
SELECT * FROM scott.emp
    WHERE sal > 2000
    ORDER BY ename;
```

인덱스 테이블에 ename 과 sal이 있으므로  
풀 인덱스 스캔을 한다.  

### 더 작으므로 한번에 더 많이 가져온다  
인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에    
그냥 테이블 풀 스캔보다 한번에 더 많은 레코드를 가져올 수 있다.  
따라서 용량이 작으므로 더 빠르게 디스크에서 읽을 수 있으므로 빠른 처리가 가능하다.  
  
<br><br><br>    
  
## 9.2.2 병렬 처리  
