# CH09 옵티마이저와 힌트  

쿼리 최적화 과정은 단순히 쿼리 문법만 보는 게 아니라  
데이터 저장된 통계도 보고 최적의 실행 계획을 수립한다.  
  
그리고 EXPLAIN 명령으로 쿼리의 실행 계획을 보고 이해하기 위해서  
옵티마이저가 어떻게 동작하는지에 대해서 어느정도 지식을 갖춰야 한다.  
  
따라서 이번 단원은  
MySQL 쿼리 최적화를 이해하기 위해서 충분히 익혀야 한다.    
  
<br><br><br> 
  
---

<br><br><br>  
  
# 9.1 개요  

DBMS 에서 옵티마이저의 동작을 온전히 이해하려면 쉽지않다.    
하지만 실행 계획을 이해해야 쿼리의 문제를 찾고 최적화를 할 수 있다.    
9.1 에서는 실행 계획을 살펴보기 전에 먼저 알고 있어야 할 사항을 보자.  
  
<br><br><br>  

## 9.1.1 쿼리 실행 절차  
  
MySQL 서버에서 쿼리가 실행되는 과정은 아래와 같다.  
  
1. 개발자가 날린 SQL문을 분해한다 - Parse Tree 만들기  
2. Parse Tree를 보고, 어떤 테이블과 어떤 인덱스를 쓸지 결정한다 - 최적화 및 실행 계획 수립
3. 실행 계획을 보고 스토리지 엔진이 데이터를 가져온다

> 두 번째 단계는 구체적으로 아래와 같은 동작을 처리한다  
> 1. 불필요한 조건 제거, 단순화
> 2. 조인이 있으면, 어떤 순서로 읽을지 결정
> 3. 조건과 인덱스 통계 정보로 인덱스 뭐 쓸지 결정
> 4. 가져온 레코드를 임시 테이블에 넣고 다시 가공할지 결정
  
<br><br><br>  
  
## 9.1.2 옵티마이저의 종류   
    
### 1. 규칙 기반 최적화(Rule-based optimizer, RBO)     
**"쿼리만"** 보고 최적화 함     
-> 최근에는 잘 사용하지 않음   
    
> (옛날에 오라클 DBMS 에서 사용했다함)     
     
<br>     
      
### 2. 비용 기반 최적화(Cost-based optimizer, CBO)  
데이터 **통계**와 **쿼리**를 **같이** 보고 실행계획 수립    
-> 쿼리 바탕으로 여러 계획을 만들고, 통계를 넣어서 cost를 계산한다      
  
<br><br><br>  
   
## 9.2 기본 데이터 처리    
    
DB에서 데이터를 어떤 알고리즘으로 처리하는지 본다.    
    
- 풀 테이블 스캔, 풀 인덱스 스캔
- 병렬 처리
- ORDER BY
- GROUP BY
- DISTINCT
- 내부 임시 테이블 활용
  
## 9.2.1 풀 테이블 스캔 / 풀 인덱스 스캔  

### 풀 테이블 스캔  
다음과 같은 조건에서 풀 테이블 스캔을 한다  
  
- 대상 테이블에 있는 레코드 수가 너무 적어서, 그냥 풀 테이블 스캔이 더 빠른 경우
- 조건에 해당하는 레코드가 너무 많아서, 그냥 풀 테이블 스캔이 더 빠른 경우
- 인덱스를 이용할 수 있는 조건이 없는 경우  

간단히 말해서  
너무 적거나, 너무 많거나, 인덱스를 쓸 수 없거나  
3가지로 보면 된다.  
  
<br>  

### "리드어헤드" 최적화 - 한꺼번에 여러 페이지 읽어오는 기능  

- 리드 어헤드(Read Ahead)  
데이터가 앞으로 필요해지리라는 것을 예측해서 디스크에서 미리 읽어 버퍼 풀에 가져다 두는 것   
  
InnoDB 엔진에는 리드 어헤드 라는 기능을 통해서    
미리미리 버퍼 풀에다가 페이지를 가져다 둔다.    
리드 어헤드가 시작되면 **백그라운드 스레드**가 데이터를 가져오도록 넘기므로    
**포그라운드 스레드**는 **백그라운드** 스레드가 버퍼 풀에 적재해둔 데이터를 가져다 쓰기만 하면 된다.    

<br>  
  
> 래퍼런스를 찾지 못했는데   
> 책에서는 리드 어헤드 작업이 처음부터 16개씩 막 가져오는 게 아니라   
> 처음에는 몇 개 가져오다가 계속해서 4개 8개 16개씩 한번에 가져오는 수를 늘려나간다고 한다.   
> 이로 미루어 봤을 때, 리드 어헤드는 처음부터 많이 읽어오는 게 아니라   
> 작업이 반복되면 이를 인식하고 다음번에 가져올 때는 한번에 뭉텅이로 가져오는 것 같다.   
    
<br><br>  

### 풀 인덱스 스캔   
인덱스를 처음부터 끝까지 스캔할 때 더 빠른 경우 사용한다.  

[참고](https://blog.naver.com/gglee0127/221336088285)  
   
```SQL
create index emp_ename_sal_idx on scott.emp(ename, sal);
```

```SQL
SELECT * FROM scott.emp
    WHERE sal > 2000
    ORDER BY ename;
```

인덱스 테이블에 ename 과 sal이 있으므로  
풀 인덱스 스캔을 한다.  

### 더 작으므로 한번에 더 많이 가져온다  
인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에    
그냥 테이블 풀 스캔보다 한번에 더 많은 레코드를 가져올 수 있다.  
따라서 용량이 작으므로 더 빠르게 디스크에서 읽을 수 있으므로 빠른 처리가 가능하다.  
  
<br><br><br>    
  
## 9.2.2 병렬 처리  

병렬 처리 : 하나의 쿼리 작업을 여러 스레드가 나눠서 동시에 처리하는 것  
  
> innodb_parallel_read_threads 시스템 변수를 통해서 몇 개의 스레드를 처리할지 변경할 수 있다.

병렬 처리용 스레드 개수는 CPU 코어 개수를 넘어서는 경우 성능이 떨어질 수 있다.  
  
<br><br><br>  
  
## 9.2.3 ORDER BY 처리  
  
### ORDER BY 이해는 중요하다  
<code>ORDER BY</code>는 거의 필수적으로 사용되는 반면   
정렬 자체가 비용이 많이 드는 값이니까   
DB에서 레코드 정렬이 어떻게 이뤄지는지 이해하는 게 중요하다.      
  
<br>    
    
### 인덱스 이용 vs Filesort 처리  
  
| |장점|단점|  
|---|---|---|
|인덱스 이용|이미 정렬되어 있으므로 읽기 매우 빠름|1. 인덱스 추가수정삭제 비용 <br> 2. 공간 많이 차지(디스크 & 버퍼 풀 메모리)|
|filesort 처리|1. 인덱스 비용이 없음 (추가수정삭제 비용 & 메모리 비용) <br> 2. 레코드 많지 않으면 충분히 빠름|레코드 많으면 느려짐|    

<br><br>
  
### 현실적으로 모든 정렬을 인덱스로 커버하기는 어렵다     
    
> "그냥 사용되는 모든 정렬에 맞춰 인덱스 생성하면 되는 거 아닌가?"  
    
모든 <code>ORDER BY</code>를 인덱스로 커버할 수 없다.      
    
1. 모든 정렬 케이스에 맞춰 인덱스를 만들면, 메모리 비용 증가 & 추가/삭제 비용 증가      
2. 인덱스로 커버할 수 없는 경우도 있음    
  
### 인덱스로 커버할 수 없는 정렬  
GROUP BY , DISTINCT , UNION 같은 추가적인 연산이 필요한 경우   
인덱스에 정렬된 그대로 가져오는 방법을 사용할 수 없다.  
  
<br><br>  

### "ORDER BY 처리"의 하위 목차 
<pre>
1. 소트 버퍼  

2. 정렬 알고리즘  
  1) 싱글 패스 정렬   
  2) 투 패스 정렬 방식  

3. 정렬 처리 방법  
  1) 인덱스를 이용한 정렬  
  2) 조인의 드라이빙 테이블만 정렬  
  3) 임시 테이블을 이용한 정렬  
  4) 정렬 처리 방법의 성능 비교  
    스트리밍 방식 vs 버퍼링 방식 

4. 정렬 관련 상태 변수  
</pre>

---

<br><br><br>  

### ORDER BY 목차 1
## 1. 소트 버퍼(Sort Buffer)    
: 정렬을 위해 할당된 메모리 공간     
  
- 시스템 변수 sort_buffer_size  
최대 사용 가능한 소트 버퍼 공간   
  
<br>  
  
### 데이터가 너무 크면 문제된다  
정렬할 데이터가 Sort Buffer 공간을 초과하면     
Memory - Disk 간의 I/O가 발생한다.     
   
### Sort Buffer 크기 키워도 빨라지지 않음  
> "Disk I/O 때문에 느려지니까, 그냥 Sort Buffer 가 충분히 크면 되는 거 아냐?"
  
라고 생각했는데 **아니었다**.  
한번에 데이터를 담을만큼 충분하면 무조건 빠를 것이라 생각했다.      
  
그런데 책의 벤치마크 결과를 보면   
소트 버퍼 크기가 너무 커지면  
심지어 버퍼 크기가 작을 때 만큼이나 느려지는 결과를 보인다.  
  
따라서   
소트 버퍼는 책의 추천에 따르면 56KB ~ 1MB 크기가 적절하다고 한다.  
    
> 이는 Disk I/O 속도나 Memory 속도, 운영체제 등      
> 하드웨어/소프트웨어 상태에 따라 다 달라질 수 있다.  
    
<br><br><br>  

### ORDER BY 목차 2
## 2. 정렬 모드     
  
소트 버퍼에 어떻게 레코드를 담는지에 따라 구분된다.  
   
1. 싱글 패스 : 레코드 전체를 소트 버퍼에 담음  
2. 투 패스 : 정렬 기준 칼럼만 소트 버퍼에 담음  
  
<br><br>  

### 정렬 모드 확인 방법  
```
"sort_mode": "<fixed_sort_key, additional_fields>"  
```
  
옵티마이저 트레이스 기능을 사용하면 위와 같이 <code>sort_mode</code> 에서 확인할 수 있다.  

#### 투 패스 방식 (정렬 기준만)   
- \<sort_key, rowid>  
정렬 키 + 로우 아이디 만 가져옴  

<br>  

### 원 패스 방식 (레코드 전체)  
- \<sort_key, additional_fields>     
정렬 키 + 레코드 전체 , **고정 사이즈**로 메모리 저장  
  
- \<sort_key, packed_additional_fields>
정렬 키 + 레코드 전체 , **가변 사이즈**로 메모리 저장
  
> 가변 사이즈로 메모리 저장하는 방식은
> 메모리 공간을 효율적으로 사용하기 위해 추가된 방식이다.

<br><br>  
  
### 싱글 패스 정렬 방식  

  
  
### 투 패스 정렬 방식  
   
<br><br><br>  

