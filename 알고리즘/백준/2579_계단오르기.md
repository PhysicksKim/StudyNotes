[2579번: 계단 오르기](https://www.acmicpc.net/problem/2579)  
  
# 본질적으로 틀린 이유  
  
문제를 보자마자 DP인건 감 잡았다   
하지만 첫 설계(접근법)에서 잘못한 부분이 있었다.  
  
DP같으면 이제, 2가지 부분을 생각하고 점화식 설계를 들어가야 한다  
  
1. 점화식에 **얼마 이전 항 까지** 포함해야 할까?    
2. 어떻게 **메모이제이션(Memoization)**을 활용할까? 
  
위 두 가지 질문에 대해 견고하게 논리를 세우고 들어가야한다  
  
이번 2579번 문제에서 틀린 이유는  
1번 "얼마 이전 항 까지" 에서 잘못 생각했다  
   
---

## 1. 몇 개의 항이 N번째에 영향을 미칠까?  
  
예를 들어 피보나치라면  
f(N) = f(N-1) + f(N-2) 라는 규칙을 갖게 되므로  
N 번째 항은 N-1 N-2 항이 이를 결정짓는다  
  
"단순히 점화식이 저러니 당연한거지" 라고 생각할 수 있다  
  
하지만 여기에 **관점** 하나를 추가한다면 좀 더 나아질 수 있다   
  
## 관점을 확대해보면  
  
DP 문제중에서는 아래와 같은 식인 경우가 있다  
   
```java
arr[N] = Math.max(arr[N-3] + arr[N-2] , arr[N-1] + 10);
```
  
왜 저런 점화식이 나오는지는 묻지말자. 그냥 아무거나 적은거다.  
  
N 번째 항을 계산할 때, N-1 N-2 N-3 항이 쓰인다  
따라서 N번째 항을 계산하려면 앞선 3개의 항이 영향을 미친다.  
  
    <br><br>  
    
### 하지만 문제를 보자마자 X개의 항이 영향을 미치는지 알 수 없다  
  
당연하다. 이걸 알면 DP문제는 거의 다 풀린거니까.  
그러면 반대로  
**"어떻게 N번째 항 결정에, X개의 항이 영향을 미친다는걸 알 수 있을까"** 라는 생각으로 파고들어 보자  

<br><br>  
  
## 이번 문제에서는 이렇게 해보자  
  
계단을 간단히 1 2 3 4 5 층이 있다고 해보자  
그러면 5층에서 최대값을 얻기 위해서는  
몇 개의 항을 검사해야할까?  
   

"X개 층이 영향을 미친다" 라고 가정하고  
반례를 하나씩 들어가면서   
1부터 늘려나가는 식으로  
경우의 수를 계산해보자  
  
---
  
### X=\[1] : N번째 층 계산에, 이전 \[1] 개 층이 영향을 미친다   
이렇게 되면   
```
DP[N] = DP[N-1] + arr[N]  
```
같은 식만 가능하다.  
  
직관적으로 3계단 연속으로 밟는건 안되는데  
위 같은 식으로는 그냥 단순 합만 가능하므로  
적절하지 않다  
  
---
  
### X=\[2] : N번째 층 계산에, 이전 \[2] 개 층이 영향을 미친다  
2개 층이 영향을 미친다는 말은 곧  
```
DP[N] = Math.max(DP[N-1] + arr[N] , DP[N-2] + arr[N]);
```
이런 식으로 N-2 까지만 들여다 보면 된다는 식이다  
그러나 2개 층만으로도 역시 연속 3계단 밟으면 안된다는 조건을 만족할 수 없다  
  
연속 3계단을 밟으면 안된다는데  
2개만 갖고는 3계단을 밟았는지 아닌지 알 수 없을거다.  
  
따라서 2개로는 안된다.  
  
---  
  
### X=\[3] : N번째 층 계산에, 이전 \[3] 개 층이 영향을 미친다  
  
|Result|⬅| N | N-1 | N-2 | N-3 |
|---|---|---|---|---|---|
|N , N-1 , --- , N-3| ⬅ | ✔ | ✔ | | ✔ |
|N , --- , N-2 , N-3| ⬅ | ✔ | | ✔ | ✔ |
  
3개 층으로는 구분할 수 있지 않을까?  
  
길어지겠지만  
이제 아이디어를 차근히 떠올리면서 정리해보자   
  
---

<br><br>  

# 중요한 것은 ...   
~~꺽이지 않는 마음~~  
  
1. DP 배열이 두 번 들어가면 안된다  
2. DP\[N] 이라면 arr\[N] 은 무조건 포함된다   
   
<br>   
   
## 1. DP 값이 두 번 들어가면 안된다  
  
### DP값이란?  
정식 용어는 아니고 그냥 붙인 이름이다   
피보나치로 예를들면  
```
1, 1, 2, 3, 5, ... 
```
같은 식으로 값이 이어지는데  
먼저 코드로 보면  
```java
int[] fibo = new int[100];

fibo[0] = 1;
fibo[1] = 1;

for(int i = 2 ; i<fibo.length ; i++) {
  fibo[i] = fibo[i-1] + fibo[i-2];
}
```
이렇게 fibo 라는 배열을 만들고 메모이제이션을 사용한다.  
여기서 메모이제이션 된 fibo 배열의 값을 DP 값이라고 하자.  
  
### 왜 DP값이라고 따로 부르냐면  
이 DP값이  
피보나치 같이 DP 값을들 둘 이상 조합해서 점화식을 만들수도 있고  
계단오르기 문제처럼 점화식에 DP 값이 상식적으로 하나만 들어가야하는 경우도 있기 때문이다.  
  
> "DP값이 둘 이상 들어가도 될까?" 라는 관점을 가지면   
> 내가 만든 점화식이 맞는지 생각해볼 때  
> 구체적으로 어떤 기준을 잡고 생각할 수 있으니 도움될 것 같다.  
  
<br><br>  
  
### DP값을 두 번 넣으면 안되는 경우가 있다  
  
계단오르기 문제가 딱 DP가 두 번 들어가면 안되는 경우다   
계단오르기 문제는 N번째 계단을 오를 때 n-1 n-2 n-3 모두 다 정보를 가져다 써야한다  
그래서 처음에 내가 잘 못 생각한게  
```
dp[n] = Math.max(dp[n-3] + dp[n-1] , dp[n-2] ) + arr[n];
```
이렇게 식을 세우는 것이다.  
  
이러면 뭐가 문제가 될까 생각해보니  
```
dp[n] = dp[n-3] + dp[n-1] + arr[n];
```
이렇게 된다면  
  
![image](https://user-images.githubusercontent.com/101965836/202441877-a742eb86-368a-4098-ab5c-6d6c2f8711be.png)  
이런 모습이라고 할 수 있는데  
잘 생각해보면  
![image](https://user-images.githubusercontent.com/101965836/202442616-59c2fc55-1ffc-454d-9173-f7e5e4bbc684.png)  
이렇게 **계단 오른 값이 두 번 더해진셈** 이 된다는 것을 알 수 있다  
  
<br>  
  
### 따라서, 계단오르기 문제에는 DP 값이 두 번 들어가면 안된다  
  
<br><br><br>  
  
## 2. DP\[N] 이라면 arr\[N] 은 무조건 포함된다   

> 이 부분은 사실 엄밀하게 이야기하기 힘든 것 같다.  
> DP\[N] 이 arr\[N] 을 무조건 포함하도록 해야지 정답이 되는 점화식이 나오는지  
> 엄밀하게 "왜 그런가? 유일한 방법인가?"(근거와 유일성) 에 대해서 증명할 아이디어가 떠오르지 않는다  
> 물론 감으로 "그럴 것 같은데..." 식으로 하면 제대로 이해한게 아니니까  
> 계속해서 "근거와 유일성" 에 대해서 생각해봐야겠다  
  
몇 단계로 나눠서 생각해봐야겠다
  
### DP\[N] 이 arr\[N] 을 무조건 포함한다면?  
1. 왜 이렇게 하면 연속 N 회 선택을 막을 수 있지? (근거)    
2. 이 방식이 유일한가? (유일성)  
  
이렇게 두가지로 나눠서 생각해보자  
