[2579번: 계단 오르기](https://www.acmicpc.net/problem/2579)  
  
# 본질적으로 틀린 이유  
  
문제를 보자마자 DP인건 감 잡았다   
하지만 첫 설계(접근법)에서 잘못한 부분이 있었다.  
  
DP같으면 이제, 2가지 부분을 생각하고 점화식 설계를 들어가야 한다  
  
1. 점화식에 **얼마 이전 항 까지** 포함해야 할까?    
2. 어떻게 **메모이제이션(Memoization)**을 활용할까? 
  
위 두 가지 질문에 대해 견고하게 논리를 세우고 들어가야한다  
  
이번 2579번 문제에서 틀린 이유는  
1번 "얼마 이전 항 까지" 에서 잘못 생각했다  
   
---

## 1. 몇 개의 항이 N번째에 영향을 미칠까?  
  
예를 들어 피보나치라면  
f(N) = f(N-1) + f(N-2) 라는 규칙을 갖게 되므로  
N 번째 항은 N-1 N-2 항이 이를 결정짓는다  
  
"단순히 점화식이 저러니 당연한거지" 라고 생각할 수 있다  
  
하지만 여기에 **관점** 하나를 추가한다면 좀 더 나아질 수 있다   
  
## 관점을 확대해보면  
  
DP 문제중에서는 아래와 같은 식인 경우가 있다  
   
```java
arr[N] = Math.max(arr[N-3] + arr[N-2] , arr[N-1] + 10);
```
  
왜 저런 점화식이 나오는지는 묻지말자. 그냥 아무거나 적은거다.  
  
N 번째 항을 계산할 때, N-1 N-2 N-3 항이 쓰인다  
따라서 N번째 항을 계산하려면 앞선 3개의 항이 영향을 미친다.  
  
    <br><br>  
    
### 하지만 문제를 보자마자 X개의 항이 영향을 미치는지 알 수 없다  
  
당연하다. 이걸 알면 DP문제는 거의 다 풀린거니까.  
그러면 반대로  
**"어떻게 N번째 항 결정에, X개의 항이 영향을 미친다는걸 알 수 있을까"** 라는 생각으로 파고들어 보자  

<br><br>  
  
## 이번 문제에서는 이렇게 해보자  
  
계단을 간단히 1 2 3 4 5 층이 있다고 해보자  
그러면 5층에서 최대값을 얻기 위해서는  
몇 개의 항을 검사해야할까?  
   

"X개 층이 영향을 미친다" 라고 가정하고  
반례를 하나씩 들어가면서   
1부터 늘려나가는 식으로  
경우의 수를 계산해보자  
  
---
  
### X=\[1] : N번째 층 계산에, 이전 \[1] 개 층이 영향을 미친다   
이렇게 되면   
```
DP[N] = DP[N-1] + arr[N]  
```
같은 식만 가능하다.  
  
직관적으로 3계단 연속으로 밟는건 안되는데  
위 같은 식으로는 그냥 단순 합만 가능하므로  
적절하지 않다  
  
---
  
### X=\[2] : N번째 층 계산에, 이전 \[2] 개 층이 영향을 미친다  
2개 층이 영향을 미친다는 말은 곧  
```
DP[N] = Math.max(DP[N-1] + arr[N] , DP[N-2] + arr[N]);
```
이런 식으로 N-2 까지만 들여다 보면 된다는 식이다  
그러나 2개 층만으로도 역시 연속 3계단 밟으면 안된다는 조건을 만족할 수 없다  
  
연속 3계단을 밟으면 안된다는데  
2개만 갖고는 3계단을 밟았는지 아닌지 알 수 없을거다.  
  
따라서 2개로는 안된다.  
  
---  
  
### X=\[3] : N번째 층 계산에, 이전 \[3] 개 층이 영향을 미친다  
  
|Result|⬅| N | N-1 | N-2 | N-3 |
|---|---|---|---|---|---|
|N , N-1 , --- , N-3| ⬅ | ✔ | ✔ | | ✔ |
|N , --- , N-2 , N-3| ⬅ | ✔ | | ✔ | ✔ |
  
3개 층으로는 구분할 수 있지 않을까?  
  
길어지겠지만  
이제 아이디어를 차근히 떠올리면서 정리해보자   
