# 참고
[풀이](https://st-lab.tistory.com/269)  

---

# 설명  

이분 탐색 방식을 사용해서 적절한 값을 찾는 문제다  
  
이분 탐색이라고 해서  
정렬된 arr에서 어떤 지정된 값을 찾는 게 아니라  
예를 들어 위 랜선 자르기 같은 경우에는  
랜선 길이를 1cm로 할지 800cm로 할지 모르는 상황에서  
일일이 1cm부터 800cm까지 다 탐색하는 게 아니다.  
  
이분탐색처럼 400cm로 해보고  
안되면 200cm로 해보고 하는 식으로  
반씩 줄여가면서 최적의 값을 찾는다.  
  
---

# 어려웠던 점  
이분 탐색이랑 뭔 상관이냐?? 라고 처음에 오해했던점이 문제였다.  
  
예를 들어 
802    
743    
457  
539  
이렇게 4개의 랜선이 있다고 해보자.  
그러면 최장 길이는 802다.  
그럼 가능한 길이는 1 ~ 802가 되게 된다.  
그리고 각 길이를 기준으로 직접 짜르기를 해보면  
몇 개의 랜선이 나오는지 알 수 있다.  

그러면 2개의 배열이 나란히 있다고 보면 된다  
(마치 key - value 처럼 생각해도 되겠다)    
  
|자를 랜선 길이| 1 | ... | 200 | ... | 802 | 
|---|---|---|---|
|잘랐을 때 랜선 수| 2541개 | ... | 11개 | ... | 1개 |
  
이렇게 2개의 배열이 있다고 생각할 수 있다.  
  
근데 랜선 길이 배열은 딱 나오겠지만   
아래 랜선 수 배열은 일일이 구하게 되면 엄청 연산이 많아진다.  
  
문제의 의의가 최적의 랜선 길이를 빠르게 찾아나가는 것이므로,  
당연히 랜선 수를 다 구하는 게 아니라  
자를 랜선 길이를 이분 탐색으로 해서  
잘랐을 때 랜선 수 계산은 최소한으로 하는 것이 효율적이다.  
  
### 따라서 
**이분 탐색**으로 **랜선 길이**마다 **잘랐을 때 랜선 수 계산**을 **최소로** 하는 것이 핵심인 문제이다.   

---

# 유의할 점 1. upper bound | lower bound

여기서 Upper Bound 와 Lower Bound 둘 중 어디로 처리할 지가 관건이다.    
  
### 코드상에서 Upper Bound와 Lower Bound의 차이는  
조건식에서 등호(=)는 어떻게 처리할건가가 차이다.  
  
간단히 말하면  
조건식 부분에 등호를 붙이면  
그 쪽 방향으로 한칸 더 간다고 생각하면 된다.  
  
예를 들어   
if 부분이 아래와 같다고 해보자   
```java
// 목표 랜선 수 = 11

// 잘못된 코드임
if (잘랐을 때 랜선 수 <= 목표 랜선 수) {
  right = middle;
}
```
이러면    
left - middle - right 에서  
right = middle이 되면 right가 \<- 방향으로 좁혀지니까  
**탐색 범위가 왼쪽으로 좁혀진다**고 말할 수 있다.  
  
여기서 등호를 붙이게 되면  
왼쪽 방향으로 한칸 더 좁혀지게되므로 11쪽으로 잡히게 되고  
이러면 upper bound를 찾을 수 없다.  
  
<br>  
  
### 왜 등호를 붙이면 이렇게 될까?  
값을 딱 적고 설명해보자  
**목표 랜선 수 = 11**  
첫 시행에서 middle 값이 11이 잡혔다고 해보자.  
그러면 upper bound가 되는 처음으로 나오는 12를 찾을려면  
middle에서 왼쪽에 있을까 오른쪽에 있을까?  

| 1 | ... | 10 | 11 | ✅ **11** | 11 | 12 | 12 | ... |  802 |
|---|---|---|---|---|---|---|---|---|---|   
|left| | | | middle | | Upper Bound | | |right|  
  
✅ **11** 이 middle 이다.  
이렇게 보면 어떤가?  
Upper Bound 가 현재 middle에서 오른쪽에 있으니까  
left를 옮겨야 한다.  
  
근데 만약 위의 코드처럼   
```java
// 목표 랜선 수 = 11

// 잘못된 코드임
if (잘랐을 때 랜선 수 <= 목표 랜선 수) 
  // 11 <= 11 
{
  right = middle;
}
```
이렇게 등호를 붙이게 되면?  
right = middle이 되니까  
  
| 1 | ... | 10 | 11 | ✅ **11** | 11 | 12 | 12 | ... |  802 |
|---|---|---|---|---|---|---|---|---|---|   
|left| | | | right | | Upper Bound | | | ~~right~~ |  
  
이렇게 Upper Bound가 left - right 안에 포함되지 않게 된다.  
즉 upper bound 탐색을 엇나가게 된다  
  
따라서 아래와 같이 등호를 없애서   
left = middle 이 되도록 해야한다  

```java
if (잘랐을 때 랜선 수 < 목표 랜선 수) 
  // 11 <= 11 
{
  right = middle;
} else {
  left = middle+1;
}
```
| 1 | ... | 10 | 11 | ✅ **11** | 11 | 12 | 12 | ... |  802 |
|---|---|---|---|---|---|---|---|---|---|   
|~~left~~| | | | left | | Upper Bound | | |right|  
  
<br>  
  
### 근데 솔직히 직관적이지 않다  
어떻게 직관적으로 등호를 다룰지에 대해서 계속 생각해봐야겠다.  
주의깊게 생각하지 않으면 실수가 많이 일어날 것 같다.  
    
---

# 유의할 점 2. max = max + 1 을 먼저 해줘야 한다.  
  
![image](https://user-images.githubusercontent.com/101965836/188117561-4dc0d83d-2fe7-44b8-a9cd-7dec9bb6f6ee.png)
  
가장 긴 랜선 길이가 정답이 되는 경우 때문에  
max = max + 1 을 해주는 것이다.  
