[11053번: 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)  

### 작성 이유  
LIS가 엄청 어려운 DP 알고리즘은 아니지만 스스로 떠올리기는 어려웠다  
결국 정답을 검색해서 공부했는데   
불만이었던점이 대부분 블로그 포스팅들이 LIS코드가 왜 저런지는 설명 안하고  
그냥 "참 쉽죠?" 식으로 코드만 떡하고 던져놓더라   
   
그래서 화를 참지 못하고 ppt로 그렸다  
  
<br><br>  
  
---
  
# 최장증가수열(LIS, Longest Increasing Subsequence) 알고리즘  

> ## 백준 11053 최장 증가 수열 설명
> 최장증가수열 : 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열  
>  
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, **30**, **50**} 이다  
  
# LIS 알고리즘 코드  
[출처](https://chanhuiseok.github.io/posts/algo-49/)  

```java
for (int k = 0; k < n; k++){
	length[k] = 1;
    for (int i = 0; i < k; i++){
        if(arr[i] < arr[k]){
            length[k] = max(length[k], length[i] + 1);
        }
    }
}  
```
  
<br><br><br>  
  
# 원리 설명 

![슬라이드1](https://user-images.githubusercontent.com/101965836/204000236-b58657de-5d03-4602-8c30-6deb0e25d821.PNG)  
![슬라이드2](https://user-images.githubusercontent.com/101965836/204000240-8e3074ab-01a5-462b-8b5d-797eb812b248.PNG)  
![슬라이드3](https://user-images.githubusercontent.com/101965836/204000250-87aec4bb-4e33-47d2-90ca-2dee6ad00e2c.PNG)  
![슬라이드4](https://user-images.githubusercontent.com/101965836/204000253-a2a7f908-28e8-4f61-ba49-18c3d58bdaa3.PNG)  
![슬라이드5](https://user-images.githubusercontent.com/101965836/204000260-5325b4a1-0eb7-423c-b40c-16d52b2be5fa.PNG)  
![슬라이드6](https://user-images.githubusercontent.com/101965836/204000263-2391c23b-6f48-4e3a-9efa-76738d3a1d43.PNG)  
![슬라이드7](https://user-images.githubusercontent.com/101965836/204000265-3454c647-40d1-49b2-8c49-661b4a9668ca.PNG)  

<br><br><br>

# 더 개선된 LIS - 이진탐색 활용  
[참고 1](https://4legs-study.tistory.com/106)  
[참고 2](https://velog.io/@seho100/%EC%B5%9C%EA%B0%95-%EC%A6%9D%EA%B0%80-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4LIS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)  
이진탐색 LIS 구현법은 위 링크를 참조   
    
> 어떻게 푸는지는 위 링크를 참고 바란다.  
> 여기서는 기본적인 구현법이나 동작방식은 설명 안할테니 위 링크로 먼저 알고 오자  
  
어떻게 구현하고 어떤방식인지는 알겠는데  
역시나 **"왜 이렇게 하면 풀리지"** 에 대해서 엄밀하게 답변하기 힘들다.  
  
직관적으로 "음... 그럴 것 같은데" 정도만 느껴진다.  
차근히 어떤 부분이 자명한지 하나하나 퍼즐을 만들다 보면  
어느순간 퍼즐이 싹 짜맞춰 지는 시점이 오리라 기대하고,  
일단 어떤 부분들이 자명한지 나열해보자.  
   
<br><br>
   
### 퍼즐 조각들 나열  
  
(1) 오름차순으로 배열이 들어오면, 그대로 LIS 결과를 얻게됨  
(2) 내림차순으로 배열이 들어오면, 계속 DP\[0] 이 바뀌기만 해서 길이 1로 끝남  
(3) 편의를 위해 arr\[i] 숫자 처리 동작에 이름을 붙이자.  
  
---
  
|첫자리| | | |끝자리|
|---|---|---|---|---|
|2|4|5|7|9|

동작1. 끝자리 교체    
ex. 8이 들어올 경우 끝자리 숫자가 9에서 8로 바뀜  

동작2. 앞자리 교체
ex. 3이 들어올 경우 4가 3으로 바뀜.  
ex2. 1이 들어올 경우 **'첫자리'** 2가 1로 바뀜 (첫자리 교체를 구분할 필요가 없으므로, 앞자리 교체로 통칭)  
  
동작3. 추가  
ex. 10이 들어오면 2 4 5 7 9 10 이 되어서 **길이가 늘어**난다  
  
---  
  
(4) 끝자리 숫자보다 큰 수만 길이를 늘릴 수 있다     
(5) '끝자리 교체' 는 길이를 늘리지는 못한다. 하지만 비교적 작은 숫자가 와도 길이를 늘릴 수 있도록 해주는 역할을 한다.    
(6) 앞자리 교체는 앞선 (5) 의 설명처럼 더 작은 수가 길이를 늘릴 수 있도록 해주는 역할을 한다.   
(6-1) 다만 앞자리 교체가 일어나면 DP\[] 배열이 실제 최장증가부분수열과 일치하지는 않는다  
  
  
<br><br><br>  
  
## 원리 이해
예시를 통해서 왜 이게 가능한지 보자  
  
```
10 11 12 13 14  7 8 9  1 2 3 4 5 6  
```
위와 같은 수열이 있다고 해보자.  
  
그러면 앞쪽까지 보면 10 11 12 13 14 를 LIS로 채택해서 저장하고 있을거다.  
  
### 그러다가 7을 처음 읽게되면?  
가장 쉽게 생각할 수 있는 방법은  
또 다른 수열 저장 공간을 만들어서 7을 저장해두는거다.  

- 왜?  
앞선 LIS 인 10 11 12 13 14 다음에 이어붙일 수 없지만  
혹시 이 7 이 더 나은 LIS의 첫 스타트일수도 있으니까  
  
근데 매번 이런식으로 다른 저장공간을 만들고 저장하고 하는식으로 할려면...  
최악의 경우 X개의 숫자를 읽고 X개의 저장공간이 늘어나서  
X+1 번째 숫자를 추가할려면, X개의 저장공간을 다 돌면서 증가수열을 만들 수 있는지 검사를 해야하는 지경에 이른다.  
  
  <br>  
  
### 근데, 링크에서 본 이분탐색 LIS 방식으로 이런 문제를 해결할 수 있다  
  
링크에서 본 방식은  
10 11 12 13 14 다음에 7이오면   
7 11 12 13 14 형식으로 저장하는거다.  
  
> 어? 그러면 7이 LIS를 만들지 못하고 다음에 15가 오고 끝나면   
> 7 11 12 13 14 15 가 되잖아?  
  
근데 잘 생각해봐라.  
앞에 10이건 7이건 뭐가 중요한가? 어차피 길이만 6이면 되는데  
  
> 근데, 이거 불가능한 형태로 LIS가 짜여질 일은 없나요?  
  
나도 처음에 "이 규칙이 왜 잘못된 수열을 안만들도록 동작하지?" 라고 갸우뚱했다    
  
근데 잘 생각해보면,  
```
수열 : 1 11 12 13 14 3 7 8 4 15
-> 1  11 12 13 14
-> 1  3  7  8  14
-> 1  3  4  8  14
-> 1  3  4  8  14 15
```
이렇게 된다 하더라도 문제가 없다.  
  
더 긴 LIS 를 만들려면    
"더 나은(작은) 숫자들" 을 아래부터 쭉 교체해서 쌓아와서   
끝 길이 까지 도달해야지만    
비로소 더 나은 LIS를 제시할 수 있기 때문이다.   
