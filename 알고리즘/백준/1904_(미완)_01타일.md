[백준 문제 1904번](https://www.acmicpc.net/problem/1904)  
  
이 문서는  
[이 부분](###-중복제거-원리)  
에서 아직 완전하지 않습니다  
추가적인 고찰 필요  
  
# 발상은 좋았지만...   
   ---

### 문제  
00 이랑 1을 무한개 갖고 있을 때  
길이가 N인 수열을 몇 개나 만들 수 있는가?  
  
  ---
  
예를 들면  

### N=1인 경우  
00을 쓰면 길이가 2가 되므로 불가능  
따라서 1 만 가능하므로  
**답은 1**이다  
  
<br>
  
### N=2인 경우  
10 01 은 쓸 수 없다  
0은 꼭 2개짜리로 써야하니까  
따라서  
11 00 만 가능므로  
답은 2
  
<br>  
  
### N=4인 경우  
0000 0011 1001 1100 1111
답은 5  

<br>  
  
---

# 내가 푼 방법  
  
예를 들어 00 00 1 1 1 이렇게 해서  
00 2개 1 3개가 있다고 해보자  
  
이걸 이제 어떻게 배치할건가 문제인데  
다르게 해석하면  
00 00 을 먼저 두고  
00들 양 옆으로 있는 어느 칸에다가 1을 배치할지 문제이다  
  
뭔말인가 다시 아래를 보자.  
빈칸을 ⬜로 표기해보겠다  
```
⬜ 00 ⬜ 00 ⬜
```
이렇게 00 양 옆으로 총 3가지 빈칸이 있다  
  
그럼 이제 문제를 이렇게 바꿀 수 있다  
```
3가지 빈칸중에서  
중복을 포함해서 3개를 선택하는 경우의 수  
```
  
즉 이 문제는
**중복조합 문제**로 바뀌게 된다  
  
<br><br><br>    
 
### 코딩  
이제 중복조합 문제인걸 알았으니 코딩을 하면 된다  
중복조합 H로 쓰고 아래와 같이 표기 및 계산을 한다    
```
aHb = a-1+b C b
```

따라서 이항계수 문제 풀었던 것 처럼 이항개수 배열 쫙 만들어주고  
00의 개수와 1의 개수는 아래와 같이 바뀌는걸 생각해서  
```
ex. N=8일때
00의 개수 | 1의 개수  
0 | 8 => 1H8
1 | 6 => 2H6
2 | 4 => 3H4
3 | 2 => 4H2
4 | 0 => 5H0
```

아래와 같이 코드를 작성했다 (메서드 부분은 이름으로 대충 알 수 있으니 메서드 코드 생략)
```java
public class Main {

  static short[][] binoArr;

  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in, "utf-8"));

    int num = Integer.parseInt(br.readLine());
    int caseCount = 0;

    InitBinoArr(num);

    int temp = 0;
    for (int countOf1 = num; countOf1 >= 0; countOf1 -= 2) {
        caseCount += cal_H_combination(temp+1, countOf1);
        temp++;
    }

    System.out.println(caseCount);
  }
  
  ...
  
}
```
이는 작은 수에서는 정상적으로 작동한다  
  
하지만...  

<br>  

# 에러 발생  
![image](https://user-images.githubusercontent.com/101965836/189481984-da8bc206-8187-4df8-99a3-74b9ce8aa3a1.png)  
![image](https://user-images.githubusercontent.com/101965836/189481975-f1260bf5-56c9-4b0e-ab00-612342a4f856.png)  
  
이렇게 입력 최대값이 1,000,000 이라서  
1,000,000을 넣으면 **OutOfMemoryError**가 발생한다  
  
당연히...  
int 4byte * 1,000,000 * 1,000,000 = 약 3.7TB  
  
말도 안되는 메모리 에러가 된다  
  
만약 1,000,000 짜리 1차원 배열이었으면  
메모리는 3.8MB밖에 안됐겠지만  
아쉽게도....  
  
여기에 2byte short으로 바꾼다고 해도 1.8TB가 되기 때문에 당연히 어림없고  
불필요한 이항계수 삼각형 절반 부분 짤라낼 수 있다고 이상적으로 가정해도 0.9TB니까   
당연히 이런 풀이 방식으로는 메모리 에러는 해결할 수 없다.  
  
<br>  

---

<br>  

# 풀이 방법 
피보나치수열이다.  
N=1 부터 차근히 노가다 해보면  
1 2 3 5 8 13 ... 으로 피보나치 수열임을 알 수 있다  
  
## 근데 왜 피보나치 수열일까?  
(이 풀이법은 여기 [링크의 글](https://blog.naver.com/occidere/220787441430) 을 참고했다)    
  
먼저 예시부터 보자  
    
N=1 일 때 1
N=2 일 때 11 00
N=3 일 때 100 111 001
  
위에서 규칙을 찾는게 쉽지는 않겠지만  
피보나치와 무슨 관련이 있는지 생각하면서 차근히 보자  
  
<br>  

### 피보나치와 연관성 찾기
  
잘 보면 N=3 에서 경우의 수는  
  
N=3 일 때는 100 은  
  
N=1 일 때 1에다가 00을 붙여서   
100 001 을 만들 수 있고    
  
N=2 일 때 11 00에다가 1을 붙여서   
111 001 100 을 만들 수 있다    
  
<br>  
  
앞선 내용을 정리하면   
1은 바로 앞의 경우의 수에다가 붙일 수 있고  
00은 2칸이 필요하니 앞앞의 경우의 수에다가 붙일 수 있다  
  
따라서 피보나치 수열과 같은 답이 된다  
**근데 중복은 어떻게 해결하는가?**  
  
<br>  
  
## 솔직히 중복 제거 원리를 떠올리기는 어렵다  
중복 제거 원리르 떠올리기에는 실전에선 촉박하다  
그래서 그냥 몇 번 노가다 해보고, 피보나치 같으면 그냥 때려맞추는게 맞다고 본다  
  
그치만 지금은 공부니까 원리에 대해 생각해보면...  
  
  <br>  
  
### 경우의 수 다시 보기    
n=5의 경우를 보자  
1 2 3 5 8
n=5는 8이 되고 아래와 같은 n=4 (5) 와 n=3 (3) 의 합이다  
```
n=3 (3개) 
001 100 111

n=4 (5개) 
0000 1100 1001 0011 1111
```
여기서 n=3은 00만 담당, n=4는 1만 담당한다는걸 앞서 말했다.  
왜냐? n=3은 N-2 즉 2칸 비우기니까 00을 담당하는 것이다.  
   
<br>  
   
### 중복제거 원리  
  
근데 여기서 00과 1을 붙일 때 중복이 발생한다.  
```
n=3 중복
001 ->  00 001
  
n=4 중복 
0000 -> 0000 1
```
이렇게 중복이 생긴다  
  
결과부터 말하면  
00은 뒤에다가 추가하고  
1은 앞에다가 추가하는 식으로 하면 된다  
  
**왜인지는... 잘 모르겠다**   
생각해봐야겠다  
  
![image](https://user-images.githubusercontent.com/101965836/189483720-08996e4e-403b-4bb0-a90b-d3135bd447c6.png)  
[출처](https://westshine-data-analysis.tistory.com/100)  
  
이렇게 하면 된다.  
왜인지 잘 생각해보자...
