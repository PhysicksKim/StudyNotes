```C
float Q_rsqrt( float number )
{
	long i;
	float x2, y;
	const float threehalfs = 1.5F;

	x2 = number * 0.5F;
	y = number;
	i = * ( long * ) &y;                     // evil floating point bit level hacking
	i = 0x5f3759df - ( i >> 1 );             // what the fuck?
	y = * ( float * ) &i;
	y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration
//	y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed

	return y;
}
```
[소스코드로 이동 : Quake-III-Arena q_math.c#L552](https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/q_math.c#L552)  

---

---

# 고속역제곱근(fast inverse square root)    
  
퀘이크 3 소스 코드에서 등장하여  
기괴한 `i = 0x5f3759df - ( i >> 1 );  //what the fuck?` 라인과   
유튜브 영상으로 유명한 알고리즘이다.   

이 알고리즘을 이해한다고 짜릿하고 번뜩이고 통쾌하고 아무튼 대단히 아름다운 알고리즘은 아니지만   
`what the fuck` 라인과 더불어 float 을 비트 그대로 long 으로 변환시켜버리는 미친 행태 탓에   
뭔가 나도 저걸 이해하면 천재개발자인것 마냥 꺼드럭 거릴 수 있을 것 같아서   
한번 파보기 시작했다.   
  
<br>

# 알아야 할 지식 순서  
  
1. float 값이 주어지면 손으로 비트 계산할 수 있어야 한다  (ex. 1.5 가 주어지면 0 0111 1111 1000 0000... 으로 손으로 환산 할 수 있어야함)
2. 수학적으로 log 의 성질을 알아야 한다 (ex. log(XY) = log(X) + log(Y))
3. 그 뒤에 뉴턴의 방법을 통한 근사치 보정이 있는데, 별로 안중요하다.


<br>  

# Float 부동소수점의 이해  

![image](https://github.com/user-attachments/assets/1e09f5bb-a540-4c2c-b81a-8790eb4006c2)  
  
손으로 부동 소수점 계산할 수만 있으면 끝이다.  
참고로 직접 비트에 0101 마킹해서 float 만들어 볼 수 있는 사이트가 있으니 이용해보면 이해하게 편해진다.  
[IEEE-754 float converter](https://www.h-schmidt.net/FloatConverter/IEEE754.html)  

<br>  

부동소수점에 대한 설명은 여러 곳에서 다 찾아볼 수 있으나  
그냥 내 설명이 더 깔끔한 것 같다.  
  
복잡한 소리 빼고 1.5 부터 float 으로 만드는 것 부터 역으로 이해해보자.  

---

# 왜 이상하게 0 0111 1111 1000 이 1.5인거야?  
   
부동 소수점과 고정 소수점에 대한 기본적인 이야기는 버리자.    
어차피 여기 들어왔으면 대충 0.00000000001 도 표기하고 10230402.1 도 표기하기에 적합하려면   
부동 소수점이 더 좋다는 정도는 얼?추? 알고 있을거다.   

그럼 곧바로 1.5 를 float 으로 바꾼 모양새를 역할별로 `부호 , 지수부, 가수부` 로 나눠서 보자.  

![image](https://github.com/user-attachments/assets/0ad04815-facd-44d5-9682-431728dfe8de)  
  
지수부 설명은 간단하다. 0이면 + 고, 1이면 - 를 뜻한다.  

그다음 지수부는 자릿수다. 그냥 점 위치를 말한다.  
우리가 엄청 크거나 엄청 작은 수를 다룰때 10^n승으로 표기하는 방식을 마찬가지로 float 에도 사용했다.  
예를 들어  
`쿼크의 크기는 0.0000000000000000001m 다` 라고 표기하지 않고   
`쿼크의 크기는 10^(-19) m 다` 라고 표기하는 것 처럼    
부동 소수점도 이를 활용해 `2^(E)` 형태로 표기한다.  
  
이 역할을 하는 게 지수부다.  
  
그리고 가수부는 그 아래에 상세 숫자들을 뜻한다.  
예를 들면 `6.0221408 * 10^23` 에서 60221408 이 상세 숫자에 해당한다.   

### 어 근데 지수부 왜 0000 0001 이 아니라 0111 1111 임?  
  
근데 1.5면 0111 1111 = 127 이라는 큰 자릿수는 아닌데 뭘까? 라는 생각이 든다.  
  
1.5를 2진수로 바꾸면 1.1 이다. 
> 10진수 1.5 는
> 1*2^0 + 1*2^(-1) = 1 + 1/2 = 1 + 0.5 = 1.5
     
근데 왜 지수부 1 가수부 1 로 `0 0000 0001 1000 0000 ...` 이 아니라  
`0 0111 1111 1000 0000 ...` 일까?  
    

## 사실 BIAS 라는 게 있음  

![image](https://github.com/user-attachments/assets/4b093552-fe57-4c4c-a0e2-5b7753b927cd)  

일단 1.1(2) 은 1.1 * 2^0 인 상태다.  
아니 위 스샷 보면 지수부 Value: 2^0 이잖아? 근데 왜 127 로 마킹한거야?  
라고 생각이 드는데  
  
지수부는 사실 127 이라는 값이 빠진 bias 가 있다.    
  
![image](https://github.com/user-attachments/assets/2c591d24-1930-4126-9e0f-ed8d0ba3d8ef)

위 스샷은 지수부가 0000 0000 인 상태다. 이 경우 2^0 이 아니라, 2^-126 승이다.  
즉 0부터 출발하는 게 아니라 -126 부터 출발한다고 생각하면 된다.  
  
> `2의 보수법` 을 참고    


