```C
float Q_rsqrt( float number )
{
	long i;
	float x2, y;
	const float threehalfs = 1.5F;

	x2 = number * 0.5F;
	y = number;
	i = * ( long * ) &y;                     // evil floating point bit level hacking
	i = 0x5f3759df - ( i >> 1 );             // what the fuck?
	y = * ( float * ) &i;
	y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration
//	y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed

	return y;
}
```
[소스코드로 이동 : Quake-III-Arena q_math.c#L552](https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/q_math.c#L552)  

---

---

# 고속역제곱근(fast inverse square root)    
  
퀘이크 3 소스 코드에서 등장하여  
기괴한 `i = 0x5f3759df - ( i >> 1 );  //what the fuck?` 라인과   
유튜브 영상으로 유명한 알고리즘이다.   

이 알고리즘을 이해한다고 짜릿하고 번뜩이고 통쾌하고 아무튼 대단히 아름다운 알고리즘은 아니지만   
`what the fuck` 라인과 더불어 float 을 비트 그대로 long 으로 변환시켜버리는 미친 행태 탓에   
뭔가 나도 저걸 이해하면 천재개발자인것 마냥 꺼드럭 거릴 수 있을 것 같아서   
한번 파보기 시작했다.   
  
<br>

# 알아야 할 지식 순서  
  
1. float 값이 주어지면 손으로 비트 계산할 수 있어야 한다  (ex. 1.5 가 주어지면 0 0111 1111 1000 0000... 으로 손으로 환산 할 수 있어야함)
2. 수학적으로 log 의 성질을 알아야 한다 (ex. log(XY) = log(X) + log(Y))
3. 그 뒤에 뉴턴의 방법을 통한 근사치 보정이 있는데, 별로 안중요하다.


<br>  

# Float 부동소수점의 이해  

![image](https://github.com/user-attachments/assets/1e09f5bb-a540-4c2c-b81a-8790eb4006c2)  
  
손으로 부동 소수점 계산할 수만 있으면 끝이다.  
참고로 직접 비트에 0101 마킹해서 float 만들어 볼 수 있는 사이트가 있으니 이용해보면 이해하게 편해진다.  
[IEEE-754 float converter](https://www.h-schmidt.net/FloatConverter/IEEE754.html)  

<br>  

부동소수점에 대한 설명은 여러 곳에서 다 찾아볼 수 있으나  
그냥 내 설명이 더 깔끔한 것 같다.  
  
복잡한 소리 빼고 1.5 부터 float 으로 만드는 것 부터 역으로 이해해보자.  

---

# 왜 이상하게 0 0111 1111 1000 이 1.5인거야?  
   
부동 소수점과 고정 소수점에 대한 기본적인 이야기는 버리자.    
어차피 여기 들어왔으면 대충 0.00000000001 도 표기하고 10230402.1 도 표기하기에 적합하려면   
부동 소수점이 더 좋다는 정도는 얼?추? 알고 있을거다.   

그럼 곧바로 1.5 를 float 으로 바꾼 모양새를 역할별로 `부호 , 지수부, 가수부` 로 나눠서 보자.  

![image](https://github.com/user-attachments/assets/0ad04815-facd-44d5-9682-431728dfe8de)  
  
지수부 설명은 간단하다. 0이면 + 고, 1이면 - 를 뜻한다.  

그다음 지수부는 자릿수다. 그냥 점 위치를 말한다.  
우리가 엄청 크거나 엄청 작은 수를 다룰때 10^n승으로 표기하는 방식을 마찬가지로 float 에도 사용했다.  
예를 들어  
`쿼크의 크기는 0.0000000000000000001m 다` 라고 표기하지 않고   
`쿼크의 크기는 10^(-19) m 다` 라고 표기하는 것 처럼    
부동 소수점도 이를 활용해 `2^(E)` 형태로 표기한다.  
  
이 역할을 하는 게 지수부다.  
  
그리고 가수부는 그 아래에 상세 숫자들을 뜻한다.  
예를 들면 `6.0221408 * 10^23` 에서 60221408 이 상세 숫자에 해당한다.   

### 어 근데 지수부 왜 0000 0001 이 아니라 0111 1111 임?  
  
근데 1.5면 0111 1111 = 127 이라는 큰 자릿수는 아닌데 뭘까? 라는 생각이 든다.  
  
1.5를 2진수로 바꾸면 1.1 이다. 
> 10진수 1.5 는
> 1*2^0 + 1*2^(-1) = 1 + 1/2 = 1 + 0.5 = 1.5
     
근데 왜 지수부 1 가수부 1 로 `0 0000 0001 1000 0000 ...` 이 아니라  
`0 0111 1111 1000 0000 ...` 일까?  
  
  
## 사실 BIAS 라는 게 있음    
  
![image](https://github.com/user-attachments/assets/4b093552-fe57-4c4c-a0e2-5b7753b927cd)  
  
일단 1.1(2) 은 1.1 * 2^0 인 상태다.  
아니 위 스샷 보면 지수부 Value: 2^0 이잖아? 근데 왜 127 로 마킹한거야?  
라고 생각이 드는데  
  
지수부는 사실 127 이라는 값이 빠진 bias 가 있다.    
  
![image](https://github.com/user-attachments/assets/503d83b8-aefd-4926-8105-bc5c3abff70c)
  
위 스샷은 지수부가 0000 0001 인 상태다. 이 경우 2^0 이 아니라, 2^-126 승이다.  
즉 0부터 출발하는 게 아니라 -126 부터 출발한다고 생각하면 된다.  

> 0000 0000 과 1111 1111 은 NaN 과 Inf 경우에 사용된다.
  
> Integer 의 `2의 보수법` 과 비슷해 보이지만, 지수부는 이와 달리 `Bias` 를 사용한다.
> 보수법과 bias 의 차이나 장단점에 집중하기 보단, 그냥 지수승에 -127 빼서 쓰는구나 라고 생각하면 된다.  
  

<br>  

## 그래서 bias 계산해서 127-127 해야해서 0111 1111  
  
`십진수 1.5 = 이진수 1.1 * 2^0` 을 만들어야 한다.  
일단 뒤쪽 1은 ㅇㅋ 가수부 제일 윗 비트에 1 마킹하면 끝이다.  
그럼 가수부는 1000 0000 0000 ... 이다. 끝  
  
지수부가 중요해보인다. 다시 앞서본 Bias 를 생각해서 만들어보자.      
일단 2^0 만들어야 한다.  
근데 bias 가 -127 이라고 했다.  
  
그러면 지수부 비트를 127 로 만들어 줘야지  
2^(127-127) = 2^0 으로 해줄 수 있다.  
127 은 이진수로 0111 1111 이다.  (= 0+64+32+16 + 8+4+2+1)  
  
따라서   
  
![image](https://github.com/user-attachments/assets/a1e56f21-fd80-4ed2-b9eb-7e703294820c)  

1.5 는 위와 같이 `0 0111 1111 1000 0000 ...` 이다  
  
- 부호  : 0 (+)  
- 지수부 : 0111 1111  
- 가수부 : 1000 0000 0000 ...

<br>  

---

# 좀 더 어려운 수로 해보자  
  
1.5는 간단히 1.1(2) 로 환산할 수 있어서 생략한 2가지가 있다.    
  
- 10진수에서 2진수로 바꾸는 방법
- 2진수가 11010.1010(2) 같이 복잡하다면 어떻게 하지?  
  
2가지에 대해 설명해보자   
  
# 1) 10진수를 2진수로 바꾸기  

26.625 를 2진수로 바꾸려면, 소수점 위와 아래로 나누자.  
  
## (a) 정수부 26 = 11010(2)  

### 정석 
```
---| 26 |---
/2 | 13 | 0
/2 | 6  | 1
/2 | 3  | 0
/2 | 1  | 1
/2 | 0  | 1
```
2를 나누면서 나머지를 오른쪽에 적고  
나머지 순서를 역순으로 바꿔주면 된다.  
  
26 을 계속 2로 나눌 때 나머지는 01011 이고, 거꾸로 해주면 11010(2) 이 된다. 
이렇게 26 = 11010(2) 로 바꿔줄 수 있다.    

<br>  

### 내 암산 방법  
근데 난 작은 수 암산할때는 대충 가까운 이진법 제곱수 빼는 방식을 쓴다.  
26 에 뺄 수 있는 가장 큰 2 제곱수는 16이니까  
26 - 16 = 10  
10이면 또 8로 빼줄 수 있고  
10 - 8 = 2
2는 곧바로 2의 제곱수다.  
정리해보면  
`16 8 x 2 x`
`1 1 0 1 0`  
이라고 계산할 수 있다.  

<br>  
  
## (b) 소수부 .625  
  
이진수의 소수부는 `2^-1` `2^-2` 같은 식으로 `1/2=0.5` `1/4=0.25` 가 된다.  
  
> 얼핏 이진수의 소수부가 낯설어 보일 수 있다.
> 10진수로 다시 생각해보면
> `10^-1` = `1/10` = `0.1`
> `10^-2` = `1/100` = `0.01`
> 이렇게 됨을 알 수 있다.
> 2진수도 마찬가지인 것이다.
  
이진수의 소수부는 2로 나누는 게 아니라     
2를 곱하면서 자릿수가 올라가는 것을 체크해주면 된다  
  
```
---|---|625|  ... 
*2 | 1 |250|  ... 625 * 2 = 1750
*2 | 0 |500|  ... 250 * 2 = 0500
*2 | 1 |000|  ... 500 * 2 = 1000
*2 | 0 |000|  ...   0 * 2 =    0
*2 | 0 |000|
```

즉 0.625 는 0.1010000...(2) 이다.  
그냥 뒤에 0짜르고 0.101(2) 이란말이다.  
  
다시 검산해보면  
```
0.101(2) = 2^-1 + 2^-3 = 1/2 + 1/8 = 0.5 + 0.125 = 0.625  
```
0.625 가 됨을 알 수 있다.  

---

# 정수부 26 = 11010(2) | 소수부 0.625 = 0.101(2) 
따라서 `26.625 = 11010.101(2)` 이다  

<br>  

---

<br>  

# 26.625 = 11010.101(2) 을 float 으로 바꾸기  

## 0) 부호비트  
+면 0이니까 float 제일 앞의 부호비트는 0  
  
## 1) 소수점 . 위치를 끌어올린다.  
`11010.101(2) = 1.1010 101 * 2^4`   
소수점 4칸 이동했으니 `2^4` 이다.  
  
## 2) 지수부와 가수부 나누기  
- 지수부 : `2^4` => `4`
- 가수부 : `1.1010 1010` 에서 앞에 1 날리고 `.1010 1010`

가수부는 `1010 1010 0000...` 라고 하면 된다.  
  
## 3) 지수부 바이어스 계산  
바이어스가 -127 빼주는거였다.  
따라서 `2^(x-127) = 2^(4)` 로 만들어 줘야한다.  
그러면 `x=127+4 = 128 + 2 + 1` 이니까  
```
1 0 0 0   0 0 1 1
↑             ↑ ↑
128           2 1
```
이렇게 지수부를 채워주면 된다  
따라서 `1000 0011` 라고 하면 된다  
  
## 정리  
- 부호 : 0
- 지수부 : `1000 0011`
- 가수부 : `1010 1010 0000 ...`
  
float 으로 합치면
`0  1000 0011   1010 1010 0000 0000 ...`  
  
## 진짜임  
![image](https://github.com/user-attachments/assets/c1f440e3-8403-44a1-acfb-cc0a31548651)  
보셈 진짜임  
