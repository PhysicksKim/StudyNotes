# 소수 구하기의 기본 노하우  
  
소수 구하기에 대해 검색해보면  
시간복잡도를 줄기이 위해서  
**에라토스테네스의 체** 사용하고 **√n 까지 탐색**하라는 말을 볼 수 있다.  
  
근데  
검색해서 나오는 글들을 보면  
에라토스테네스의 체에서 범위를 제대로 설명해둔 곳이 없는 것 같아서 기록해둔다.  
  
<br>

# 에라토스테네스의 체  

### 검색으로 흔히 찾을 수 있는 기본 코드    
  
```java
// false : 소수 아님 || true : 소수임  
check[1] = false;
  
for (int i=2; i*i<=N; i++) { // 1. i<=N 대신 i*i<=N 
    if (!check[i]) continue;
    for (int j=i*i ; j<=N; j+=i) // 2. int j = i*2 가 아니라 i*i
        check[j] = false;
}
```
   
여기서 각각 for문에서 최적화가 하나씩 있다.  
   
<br><br>    
   
## 1. i<=N 대신 i*i<=N  
   
이 부분은 설명이 많이 나와있다.     
   
헷갈릴 수 있는 내용은    
**√n 까지 탐색** 이라는 말은    
**"N 이하의 소인수"** 를 찾을 때 **√n 까지 탐색** 하면 된다는 말이다.    
    
**"N 이하의 소수"** 를 찾을때는 i*i<=N 이라고 하면 안된다.  
혹여나 착각할까봐 적어둔다.    

<br><br>  

## 2. int j = i*i 
for i 가 소수인 경우,  
에라토스테네스의 체 에다가 i의 배수들은 소수가 아님을 마킹하는 과정이다   
  
근데 여기서 왜 j = i*i 부터 시작하는지 모를 수 있다.  
  
<br>

### 예시) i = 17 인 경우  
i\*X 에서 X = 2 ~ 를 탐색하는 모습을 보자.  
  
| j | i*X |
|---|---|
|34|17 * 2|
|51|17 * 3|
|68|17 * 4|
|...|...|
|289|17 * 17|
|306|17 * 18|  
    
근데 위 코드에서 제시한 바는    
  
> ### i*i = 17 * 17 부터 시작해도 된다  
  
라고 하고있다.   
  
### 왜?      
17 * 2 ~ 17 * 16 는 그 전에 이미 체크했기 때문에     
  
### 왜? (2)      
뒤집어 보라. 2 * 17 ~ 16 * 17 은 이미 했다.   

<br><br><br>
  
---  
  
<br>   
     
```
for i    // i for문 
  for j  // j for문 
```
   
## 17 * 2 의 체크 (소수 * 소수)    
   
i for문 에서 i = 2 일 때  
2 * 2   
2 * 3  
...  
2 * 17  
에서 이미 했다.  
  
<br>
  
## 17 * 4 의 체크 (소수 * 소수아님)  
  
17 * 2 * 2 로 다시 소인수 분해 해서 생각해보면  
(17*2) * 2 니까  
  
i for문 에서 i = 2 일 때  
2 * 2  
2 * 3  
...
2 * 34  
에서 이미 했다.  
  

### 따라서 17 * 2 ~ 17 * (17-1) 은 이미 앞서서 체크했기 때문에, i*i 부터 하면 된다  
