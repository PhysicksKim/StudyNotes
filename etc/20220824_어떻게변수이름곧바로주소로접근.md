# 의문  
### 변수 이름이 어떻게 곧바로 메모리 주소로 연결될까?  
  
예를 들면  
aaaa 라는 변수가 있고,  
cccc 라는 변수가 있다고 하자.  
   
만약 이것들이 다 

|변수이름|주소|
|---|---|
|aaaa|0x000100|
|cccc|0x000300|

이런식으로  
이름 - 주소로 저장되어 있다면  
자료 구조상 한계로 성능 문제가 발생할 수 있다.  
  
그럼 어떻게 저장되길레  
변수 이름을 쓰면 O(1)로 접근이 가능한걸까?  
  
<br><br><br>  

---

# 해답  

[출처](https://stackoverflow.com/questions/14612314/how-are-variable-names-stored-in-memory-in-c)  
  
> ### 답변 번역
> 변수 이름은 컴파일러가 동작한 후부터는 더이상 존재하지 않습니다  
> 컴파일이라는 모든 행동들은 이런(변수 이름 같은) 상징적인 이름들과 작성된 코드들을  
> 기계어로 변환하는 것 입니다.  
> 그래서, variable_name 이라는 변수명이 있다면,  
> 컴파일러와 링커가 거기에다가 0xaaaaaaaa 라는 주소를 집어넣을겁니다.  
> 그리고 해당변수는 그 주소를 통해서 접근할 수 있게 됩니다.  

위의 번역만으로도 이해할 수 있을 것이다.  
컴파일하면 변수 이름이 곧 전부 주소로 변환된다는 것이다.  
따라서 모두 주소형태로 갖고있으면  
O(1)로 당연히 접근할 수 있다는 뜻이 된다.  
  
---

# {추가} 인터프리터 에서는 Symbol Table 사용  
  
[위키백과 - 심볼 테이블](https://ko.wikipedia.org/wiki/%EC%8B%AC%EB%B3%BC_%ED%85%8C%EC%9D%B4%EB%B8%94)
[참고 - Python internals: Symbol tables](https://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/)  
  
1. Symbol Table 이라는 자료 구조를 사용해서 변수 이름과 메모리 주소를 저장한다. 
2. 컴파일 언어에서는 컴파일 과정에서 Symbol Table을 사용해 변수 이름을 미리 메모리 주소로 다 변환해둔다. 
3. 인터프리터 언어에서는 Symbol Table을 코드 실행 중에 사용하면서, 변수 이름과 메모리 주소를 맵핑 시켜주는 역할을 한다.

따라서 인터프리터 언어에서는  
  
|변수이름|메모리주소|
|---|---|
|a|0x0100|
|b|0x0200|
  
이런 식으로 변수 이름에 따른 메모리 주소 값을 저장해둔 Symbol Table을 두고    
변수를 부를 때 마다 Symbol Table 에서 메모리 주소를 갖고와 참조하도록 한다.  
  
