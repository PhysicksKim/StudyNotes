> 본 문서는  
> { 객체지향 프로그래밍 - 김동헌 저 } 를 읽고  
> 뇌피셜을 굴려 정리해둔 내용입니다  
> 래퍼런스로 쓰기에는 부적절합니다  
  
# 둘은 비슷하다  

생긴건 똑같다.  
다른건 '동작방식' 또는 '목적'이 다르다.  
  
# Strategy 의 '동작방식'  
Strategy 패턴은  
Strategy 클래스를 실행,생성 하는 주체가  
어떤 Strategy 구현체가 있는지 알고, 그 중 적절한걸 상황에 따라 바꿔가며 실행하도록 동작한다.  

### 예시코드
```java

DataParser dataParser;

public void parseData(Data data) {

  //JSON data
  if(data.dataType = DataTypes.JSON) {
    dataParser = new JSONParser();
  } else if(data.dataType = DataTypes.XML) {
    dataParser = new XMLParser();
  } else {
    dataParser = new DefaultByteParser();
  }
  
  dataParser.parse(data);
}
```
이 경우 dataParser 를 쓰는 parseData() 입장에서는  
**DataParser 구현체에 어떤 것들이 있는지** 알아야 한다  
  
또한 상황에 따라 어떤 DataParser를 써야하는지 알아야 하므로,  
마치 상황에 따라 십자드라이버 일자드라이버 갈아끼우는 모습과 같다.    
단지 패턴의 대상이 되는 인터페이스는 문제를 해결하는 도구로 잠시 사용될 뿐이며  
패턴의 대상이 되는 인터페이스가 **활용하는 클래스의 상태를 바꾸지 않는다**  
  
<br><br>

# State 의 '사용목적'
  
State 는 
  
> 나와 관련된 값이 복잡한 조건에 따라 바뀔 때  
> 이 값의 상태를 내가 직접 조작하지 않고, 다른 인터페이스를 뽑아내서 조작하겠다.   
  
라는 목적을 띈다.  
  
위 문장을 나눠서 해석해보면  
  
1. 나와 관련된 값   
2. 복잡한 조건에 따라 바뀜  
3. 상태를 직접 건드리지 않고  
4. 인터페이스를 뽑아내서(패턴을 써서) 체크  
  
이렇게 된다. 순서대로 차근히 보자  

### 예시. 비행기의 상태  
비행기는 이륙, 착륙, 파괴, 정지, 정상비행, 고도상승, 고도하강 등... 엄청 많은 상태를 뽑아낼 수 있다  
단순화 시켜서 비행기 부품의 상태와 비행기 조종상 목적으로 분류할 수 있겠지만,  
막상 분류하고 보면 너무도 많은 상태들이 비행기 객체 안에 나열될 수 있다.  
  
따라서 현재 상태를 리턴해주는 로직을 따로 빼는 방식을 쓸 수 있다.   

먼저 아래와 같은 비행기 상태를 예로 들겠다    
이륙, 착륙, 브레이크, 부품문제, 지상주차, 하차  
  
### 0. 상황 예시    
파일럿 객체는 1초마다 비행기의 상태를 체크하고, 상태를 바꾸는 식으로 조작한다고 해보자.   
  
예를 들어  
a. 파일럿은 비행기 상태를 '지상주차' 에서 '이륙'으로 바꾼다.  
b. 그 다음 1초 마다 파일럿은 비행기의 상태를 보고,  
c. '부품문제' 상태를 띄면 상태를 '브레이크'로 바꾸고,  
d. 파일럿은 계속 '브레이크' 상태인지 체크하다가    
e. 비행기의 속도가 0이 되면 '지상주차' 상태로 바뀐다.  
f. 파일럿은 '하차' 로 상태를 바꾸고 점검에 들어간다.    
  
이렇게 보면 정말 복잡하다는 것을 알 수 있고,  
또 다양한 상태들이 추가될 여지가 많은 것을 알 수 있다.  
  
물론 상태와 명령을 분리하고, 상태를 보고 명령은 다른 인터페이스로 내리도록 할 수 있지만  
이 복잡한 상황에서 또 상태와 명령까지 분리하면 머리터지니까 단순하게 상태만으로 이야기하자.  
  
### 1. 나와 관련된 값  
비행기의 상태가 어떤지 나타내는 값들이다.  
이륙, 착륙, 브레이크 등등  
비행기 객체의 현재 값과 관련된 내용을 담고있다.  
  
### 2. 복잡한 조건에 따라 
어떤 경우 '부품문제' 상태를 띄워야 할까?  
어떤 경우 '하차' 상태를 띄워야 할까?  
경우에 따라  
파일럿이 주체가 되어서 '상태' 를 세팅할 뿐만 아니라  
외부 주체가 '상태'를 바꿀 수도 있다. (버드스트라이크 등)  
  
따라서 다양한 상태에 대해서  
상태를 바꾸는 주체를 비행기로 두지 않고  
외부에 다른 주체로 두도록 할려면  
이렇게 state pattern을 쓰는 것이다.  

### 3. 상태를 직접 조작하지 않고    
앞서 말했듯 비행기 객체가 직접 비행기 객체의 상태를 변화시켜서 체크하려면  
너무도 많은 고려사항들이 있고, 그 고려사항들이 비행기 객체안에 쑤셔넣어지다보면 많은 사이드이펙트가 발생한다  
따라서 비행기의 상태를 비행기가 갖고 있지만  
비행기의 상태는 외부의 제3자가 바꿀 수 있도록 해둔다.  
  
### 4. 인터페이스를 뽑아내서  
상태와 관련된 인터페이스를 뽑아냈다.  
상태에 맞는 구현체들이 쭈루룩 있을테고    
비행기 입장에서는 checkState() 메서드들을 써서 현재 어떤 상태인지 확인할 수 있도록 구현하고  
외부 제3자는 조건에 따라 AirplaneState 구현체들을 바꿔 끼워서 비행기 상태를 변경시킬 수 있다.  
  

<br><br><br>  

# Strategy Pattern VS State Pattern 차이를 요약하면  
  
### Strategy 
상황에 따라 다른 툴(알고리즘)을 써서 로직 일부분을 해결  
  
### State   
해당 객체와 관련된 값이 복잡한 조건에 따라 바뀔 때, 따로 인터페이스를 뺌.   
해당 객체는 어떤 상태값이 존재하는지 몰라도 되며, 제3자가 상태값을 변화시키고 보고 판단하고 조작하는데 상태가 쓰임.   
