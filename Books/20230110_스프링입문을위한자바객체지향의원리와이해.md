# CH01 사람을 사랑한 기술  

머리말에 해당하는 챕터다.  
요약하면  
"왜 절차지향 객체지향 IOC DI 같은 것들이 태어났는가?"  
에 대해서  
"그게 쉽고 편하니까"  
라고 설명해주는 챕터다.  
  
<br>  
  
#### 기계어 -> 어셈블리어 나온 이유?  
**01100011** 로 코딩하면 숨넘어가니까  
"사람이 이해하기 쉬운" 
**ADD**로 코딩하자  
  
는 개념에서 어셈블리어가 등장  
  
<br>  
  
#### 어셈블리어 -> C언어 나온 이유?  
CPU 마다 어셈블리어가 다르다.  
애드삭은 add 1, 3  이라고 하고,    
유니박은 plus 1, 3 이라고 한다.   
  
그러면 CPU마다 다 다르게 코딩해야 한다.  
  
이 문제를 해결하기 위해서  
a = 1 + 3;  
라고 코딩하기 위해서 나온게 C언어 이다.  
  
<br>  
  
### 객체지향의 등장  
C언어 다음에는? C++ 그리고 Java 가 등장한다.  
왜? 객체지향이 등장했기 때문에.  
객체지향은 절차지향 다음에 등장하는데  
절차지향은 코드를 논리 단위로 끊어서 생각하자는 생각에서 등장했다.  
하지만 점점 프로그램 규모가 커질수록  
함수 함수 함수로 연결된 코드를 이해하는데 어려움이 생겼고  
그 다음에 나온게 객체지향 개념이다.  

<br>  

## 객체지향 다음은?  
객체지향 다음은 뭘까?   
이에 대해 저자는  
해결 방안으로 각종 디자인 패턴과 SOLID 원칙 등을 제시한다.  
  
### 그러면 Spring은 뭐지 ?  
자. 다시 정리해보자.  
어셈블리어가 0001110110 같은 거를 ADD 라고 표현한건  
"니모닉" 이라는 개념이다.  
"니모닉"은 이제 01 같은 이진법으로 코딩하지 말고    
사람이 이해할 수 있는 말로 코딩하자는 개념이다.  
그리고 이에 대응되는 "**제품**"이 **어셈블리어** 이다  
  
<br>  
  
### 개념(해결책) - 제품  
개념이 제시되면 이에 해당하는 제품이 나온다  

|개념|제품|
|---|---|
|니모닉|어셈블리어|
|절차지향 + 소스파일 공통 사용|C|
|객체지향|C++ , Java|
|???|Spring|
  
### Spring은 왜 나왔는가?  
객체지향이 태동한 이후  
객체지향 디자인 원칙(SOLID)를 비롯해서  
IOC DI AOP WEB ORM Test 등등  
다양한 개발에 관한 개념이 등장했다.  
  
그러면 IOC를 구현한 제품은 뭐가 있는가?  
DI를 구현한, AOP를 구현한, WEB을 구현한 제품은 뭐가 있을까?  
  
다양한 제품들이 제시될 수 있겠지만  
위에 제시한 것과 더불어 수 많은 개발방향을 잘 버무려 만든 제품이 바로 Spring 이다.  
이 같은 배경을 두고 Spring이 등장하게 된 것이다.    
  
  
### 그래서 Spring 첫걸음은 OOP 이다  
객체지향이 뭔지 이해해야지  
객체지향 이후 등장한 복잡하고 다양한 개발 사상에 대해서 이해할 수 있다.  
따라서 객체지향이 뭔지 이해하기를 몇 챕터에 걸쳐 하고  
그 다음 객체지향으로 제시된 개발 방향에 대해 또 몇 챕터간 이야기 한 다음  
마지막으로 Spring에 들어가게 될 것이다.  
  
  
<br><br><br>  

# CH02 자바와 절차적/구조적 프로그래밍  
  
JAVA 코드에 따라 T메모리 영역에서 어떤 일이 일어나는지에 대해 알아보는 챕터다.  
  
> 챕터 이름이 절차적/구조적 프로그래밍인 이유는   
> 코드가 어떻게 실행되는지 절차적/구조적 관점에서 먼저 보자는 뜻이다.    
> 객체지향 이야기하기에 앞서서  
> 코드 실행 순서대로 메모리에서 어떤 일이 일어나는지 이번 챕터를 통해서 본다.    
   
Static / Stack / Heap 3가지 영역을  
![image](https://user-images.githubusercontent.com/101965836/211825396-a74a2515-6a1f-44f2-bb7e-a1d90b82723d.png)  
그림과 같이 T 자 형태로 그렸다고 해서 T메모리라고 한다.  
  
Static Stack Heap 영역에 어떤 값들이나 클래스나 메서드들이 저장된다는 내용은 자료구조나 Java 언어 공부 과정에서 익히 들어왔다.  
그치만 정리하고 넘어가는 차원에서 간략하게만 짚고 넘어가자.  
   
## static / stack / heap 영역에 올라가는 것들  
   
### 1. Static 영역  

1. JVM이 실행되면 java.lang 이 먼저 static 에 올라간다.  
2. main() 이 있는 Class 와 main() 메서드가 올라간다  
3. 각종 클래스들(설계도)이 static 영역에 올라간다.  

### 2. stack 
1. 실행중인 메서드() 가 올라간다  
2. 메서드 내에 있는 지역 변수가 올라간다. 
     
위와 같이 설명을 할 수 있기는 한데, 정확하게 설명하고 이해하려면 좀 복잡하다.    
stack은 단순히 변수나 메서드들을 저장하는 공간이 아니다.    
  
먼저 메서드들이 stack에 올라간다.  
그리고 각 메서드는 프레임을 만든다.  
```java
void out() {
  int a = 1;
  
  if(a==1) {
    int b = in();
  }
}

int in() { return 2; }
```
이런 코드가 있다면.    
![image](https://user-images.githubusercontent.com/101965836/211830137-407f49d1-11a3-41f9-9751-1ad43d599861.png)  
이렇게 프레임이 생길 것이다.  
프레임에 대해 설명하면  
if{} 프레임 안에서는 out() 프레임에는 접근할 수 있지만 (변수 a 접근 가능)  
in() 프레임에서는 out() 프레임에 접근할 수 없다 (변수 a 접근 불가)  
  
그리고 메서드 안에 메서드가 호출되면, 위 그림처럼 바깥에 다른 메서드 프레임이 생긴다.  
  
### 3. Heap  
heap에 대해서는 다음 챕터에서 나온다.  
다만 간략히 이야기하면  
new Animal(); 같이 new로 객체를 생성하면 heap에 그 객체에 대한 값들이 저장된다.  
  
<br><br>  

## 멀티 스레드 / 멀티 프로세스   
### 멀티 스레드 : stack 영역이 여러 개로 구분 됨    
![image](https://user-images.githubusercontent.com/101965836/211836267-0e779ead-7b9a-431c-a074-bf3691f192bd.png)  
  
### 멀티 프로세스 : T 메모리가 여러 개로 구분 됨  
![image](https://user-images.githubusercontent.com/101965836/211837151-6fdb3339-1f03-4d16-ac21-6215fddb6180.png)  
  

### 멀티 스레드에서 전역변수 문제점  
전역변수(static 변수)는 T메모리에서 static 영역에 저장되는데  
멀티 스레드의 경우 같은 static을 공유하기 때문에  
전역변수 값이 다른 스레드에 의해 바뀔 수 있다.  
