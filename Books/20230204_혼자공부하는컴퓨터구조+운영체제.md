# CH 01 컴퓨터 구조 시작하기  

## 1-1 컴퓨터 구조를 알아야 하는 이유  

### 컴퓨터 구조를 이해하면  
- 문제 해결 능력이 향상 됨  
- 어떤 관점에서 성능/용량/비용 을 고려해 개발해야 하는지 알 수 있다  

<br><br><br>    

## 1-2 컴퓨터 구조의 큰 그림  

### 컴퓨터 구조
1. 컴퓨터가 이해하는 정보
2. 컴퓨터의 네 가지 핵심 부품  
  
<br>  
  
### 1) 컴퓨터가 이해하는 정보
  
- 데이터 : 컴퓨터가 이해하는 정보  
- 명령어 : 데이터를 움직이고 컴퓨터를 작동시키는 정보  
  
> ### Q. "컴퓨터를 한마디로 정의해 보세요"
> A. 컴퓨터는 명령어를 처리하는 기계입니다.  
  
<br>  

### 2) 컴퓨터의 4가지 핵심 부품  
1. CPU : 메모리에 저장된 명령어 읽기, 해석, 실행  
내부 구성 요소중 **ALU(산술논리연산장치), 레지스터, 제어장치** 가 중요  
  
2. 메모리 : 명령어와 데이터를 저장.  
"주소" 개념을 사용해서 빠르게 접근할 수 있음   
  
3. 보조기억장치 : 전원이 꺼져도 데이터를 저장하기 위한 장치  
  
4. 입출력장치 : 컴퓨터 외부에 연결되어 내부와 정보를 교환하는 장치  
  
+ 메인보드 : 컴퓨터 핵심 부품들을 연결시켜줌.  
메인보드 내부에 있는 Bus를 통해서 정보를 주고받음.  
주소버스, 제어버스, 데이터버스 가 있음   
  
<br><br><br>    
  
---

---

<br><br><br>  

# CH 02 데이터  

## 2-1 0과 1로 숫자를 표현하는 방법  
   
### Bit    
비트 : 0과 1을 나타내는 가장 작은 단위. On/Off 를 0과 1로 나타냄  
  
|1byte|8bit|
|---|---|
|1kB|1,000byte|
|1MB|1,000kB|
|1GB|1,000MB|
|1TB|1,000GB|
  
> 1,024씩 묶어서 표현한 단위는 kB, MB, GB 가 아니라 KiB, MiB, GiB이다.  
> 키비바이트, 메비바이트 같은 식으로 읽는다  
  
> ### 워드  
> CPU가 한 번에 처리할 수 있는 데이터의 크기  
> cpu에 붙어있는 32비트 또는 64비트 같은 것들  
   
<br>    
  
### 이진수의 음수 표현  
  
2의 보수법을 사용한다.  
[2의 보수법 설명](https://github.com/PhysicksKim/TIL/blob/main/CS/20221021_%EC%9D%8C%EC%88%98%ED%91%9C%EA%B8%B0%EB%B2%95%EA%B3%BC2%EC%9D%98%EB%B3%B4%EC%88%98.md)  
  
### 2의 보수법 구하기  
예시로 1001(2) 의 보수를 구해보자  
  
1. 먼저 양수 기준 2진법으로 값을 적는다  
 
|1|0|0|1|  
|---|---|---|---|
  
2. 모든 0과 1을 뒤집는다  

|0|1|1|0|  
|---|---|---|---|
    
3. 1을 더하면, 2의 보수가 완성된다    

|0|1|1|1|  
|---|---|---|---|
  
1001(2) -> 0111(2)  
  
<br>
  
### 16진법 - 코딩에 16진수를 쓰는 이유 
2진수를 그대로 다뤄야 하는 경우(ex.비트연산)   
2진수를 그대로 쓰면 너무 길이가 길어지므로  
10진수 보다 2진수 변환이 쉬운 16진수를 사용한다  
  
<br><br><br>    
  
## 2-2 0과 1로 문자를 표현하는 방법  
  
### 문자 집합과 인코딩  
문자 집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음  
문자 인코딩 : 문자를 0과 1로 변환하는 것    
문자 디코딩 : 0과 1을 문자로 변환하는 것  
  
<br>  
  
### 문자 인코딩 종류  

### A. 아스키 코드 ASCII
초창기 문자 집합이다  
7bit + parity 1bit 구조이다  
  
아스키코드는 표현할 수 있는 2^7개(128)밖에 없다는 단점이 있다.    
  
### B. EUC-KR  
아스키 코드의 한계에 따라 다양한 문자들을 표현하기 위한 인코딩이 탄생했고  
그 중 한글을 표현할 수 있는 대표적인 인코딩이 EUC-KR 이다  
  
> ### 완성형 인코딩 vs 조합형 인코딩  
> 한글은 초성, 중성, 종성으로 되어 있다.    
> 문자 인코딩도 마찬가지로 초성 중성 종성으로 나눠서 조합되는 형태의 인코딩이 있는데  
> 이를 조합형 인코딩이라고 한다  
> 반대로 완성형 인코딩은 모든 글자마다 다 따로 코드를 부여하는 문자 인코딩 방식을 말한다.  
>    
> 단순히 생각하면 한글에는 조합형 인코딩이 어울린다고 볼 수 있지만  
> [조합형 완성형 논쟁](https://namu.wiki/w/%EC%A1%B0%ED%95%A9%ED%98%95%20%EC%99%84%EC%84%B1%ED%98%95%20%EB%85%BC%EC%9F%81)  
> 초창기에 조합형과 완성형 중 어느쪽이 더 나은가에 대한 논쟁이 있었다  
> 논쟁은 후술할 유니코드의 등장으로 일단락되어, 완성형이 자리잡게 되었다  
  
### C. 유니코드 UTF-8
영어 + 한글만 표현할 수 있는 제한적인 문자 인코딩을 넘어서  
모든 문자를 다 표현할 수 있고, 심지어 이모티콘까지 표현할 수 있는 인코딩 방식인  
유니코드(Unicode)가 등장했다  
  
유니코드에도 여러 세부 인코딩 방식이 있는데  
그 중 가장 대중적인 방식이 UTF-8 이다  
  
UTF-8 은 1~4바이트로 가변길이 문자 인코딩 방식에 해당한다    
자세한 인코딩 방식에 대해 알 필요까지는 없으나  
궁금하면 [UTF-8 위키백과](https://ko.wikipedia.org/wiki/UTF-8) 만 봐도 알 수 있을 정도로 어렵지 않다  
  
  
<br><br><br>    
  
---

---

<br><br><br>  
  
# CH 03 명령어 
  
## 3-1 소스 코드와 명령어  

### 고급 언어와 저급 언어  
- 고급 언어 : 개발자가 이해하기 쉬운 언어    
- 저급 언어 : 컴퓨터가 이해하기 쉬운 언어  
  
**저급 언어**에는 2종류가 있다   
1. 기계어 : 0과 1의 명령어 비트로 이루어진 언어. 01010110 이라서 사람이 이해하기 힘듦
2. 어셈블리어 : 기계어의 각 명령을 단어로 변환한 언어.  
```
push  rbp
mov   rbp, rsp
mov   DWORD PTR [rbp-4], 1
```
  
**어셈블리어**가 저급 언어인 이유는    
기계어와 1대1 대응이 되기 때문이다  
(아닌 경우도 있다고는 한다)  
  
무슨 말이냐면  
고급 언어에서 하나의 명령어는   
기계어에서는 여러 명령어의 조합으로 이뤄지지만      
  
어셈블리어의 명령어 하나는 기계어 명령 하나와 같다는 뜻이다.    
  
### 개발자가 굳이 어셈블리어를 알아야 할까?  
요즘은 어셈블리어로 개발하는 경우는  
정말 Low Level 까지 건드리는 컴파일러, 운영체제, 임베디드 개발자 말고는 없다고 보면 된다.  
  
과거에야 컴파일러 최적화 수준도 낮고, 컴퓨터 성능도 안좋아서   
어셈블리어로 코딩하는 최적화가 필요했으나  
현대에는 컴파일러 수준도 높아졌고 컴퓨터 성능도 비약적으로 발전했기에   
굳이 어셈블리어로 코딩하는 최적화가 필요없다.  
  
더불어 컴파일러는 CPU나 운영체제를 고려해서 최적화까지 해주지만  
직접 어셈블리어로 코딩하면서 어셈블리어 + CPU + 운영체제 지식까지 겸비해 최적화하기는 어렵다.  
따라서 컴파일러보다 최적화를 잘 할 자신이 없으면  
그냥 C/C++로 코딩하는편이 더 최적화가 잘된다고 한다 (출처 - 나무위키)  
  
다만   
분야에 따라서 어셈블리어로 직접 까보면 좋은 경우도 있으니  
이럴때는 어셈블리어를 학습할 필요도 있다.  
  
### 컴파일 언어와 인터프리터 언어  
  
- 컴파일 언어 : 소스 코드를 저급 언어로 변환하는 과정  
컴파일러를 통해 저급언어로 변환된 코드를 Object Code(목적코드) 라고 한다.  
  
- 인터프리터 언어 : 코드가 한 줄씩 변환되어 실행되는 언어   
소스 코드를 한 줄씩 기계어로 변환하기에 컴파일 언어보다 느리다  
  
  
### 컴파일 언어 vs 인터프리터 언어  

얼핏 보기에는 컴파일 언어가 무조건 좋아보이겠지만  
OS 호환성이라던가 디버깅 등 문제로 인해서  
인터프리터의 장점도 있다  
  
이에 대한 내용은  
[20230202_JAVA는컴파일과인터프리터둘다해당.md](https://github.com/PhysicksKim/TIL/blob/main/CS/ComputerArchitecture/20230202_JAVA%EB%8A%94%EC%BB%B4%ED%8C%8C%EC%9D%BC%EA%B3%BC%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0%EB%91%98%EB%8B%A4%ED%95%B4%EB%8B%B9%2B%EA%B0%95%ED%83%80%EC%9E%85%EC%95%BD%ED%83%80%EC%9E%85%EB%8F%99%EC%A0%81%ED%83%80%EC%9E%85%EC%96%B8%EC%96%B4%EC%A0%95%EC%A0%81%ED%83%80%EC%9E%85%EC%96%B8%EC%96%B4.md)  
이전에 작성한 위 문서를 보면 더 자세히 알 수 있다.  
  
### 목적파일 vs 실행파일  
컴파일 결과가 목적(Object) 파일이 나온다고 앞서 말했는데  
목적 파일을 곧바로 실행할 수는 없고  
추가로 **링킹**이라는 작업이 필요하다  
  
링킹은 목적 코드 안에서 가져다 쓴 외부 기능들을 연결시켜주어 실행파일로 만드는 작업을 말한다  
  
예를 들면 화면에 글자를 출력하는 기능들은 main.o 에 없고  
대표적으로 c언어에서 include 한 stdio.h 에 있다  
이를 연결시켜주는 작업이 링킹이다.  
  

<br><br><br>    
  
## 3-2 명령어의 구조
