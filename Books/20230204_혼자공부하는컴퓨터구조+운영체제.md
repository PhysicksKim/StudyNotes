# CH 01 컴퓨터 구조 시작하기  

## 1-1 컴퓨터 구조를 알아야 하는 이유  

### 컴퓨터 구조를 이해하면  
- 문제 해결 능력이 향상 됨  
- 어떤 관점에서 성능/용량/비용 을 고려해 개발해야 하는지 알 수 있다  

<br><br><br>    

## 1-2 컴퓨터 구조의 큰 그림  

### 컴퓨터 구조
1. 컴퓨터가 이해하는 정보
2. 컴퓨터의 네 가지 핵심 부품  
  
<br>  
  
### 1) 컴퓨터가 이해하는 정보
  
- 데이터 : 컴퓨터가 이해하는 정보  
- 명령어 : 데이터를 움직이고 컴퓨터를 작동시키는 정보  
  
> ### Q. "컴퓨터를 한마디로 정의해 보세요"
> A. 컴퓨터는 명령어를 처리하는 기계입니다.  
  
<br>  

### 2) 컴퓨터의 4가지 핵심 부품  
1. CPU : 메모리에 저장된 명령어 읽기, 해석, 실행  
내부 구성 요소중 **ALU(산술논리연산장치), 레지스터, 제어장치** 가 중요  
  
2. 메모리 : 명령어와 데이터를 저장.  
"주소" 개념을 사용해서 빠르게 접근할 수 있음   
  
3. 보조기억장치 : 전원이 꺼져도 데이터를 저장하기 위한 장치  
  
4. 입출력장치 : 컴퓨터 외부에 연결되어 내부와 정보를 교환하는 장치  
  
+ 메인보드 : 컴퓨터 핵심 부품들을 연결시켜줌.  
메인보드 내부에 있는 Bus를 통해서 정보를 주고받음.  
주소버스, 제어버스, 데이터버스 가 있음   
  
<br><br><br>    
  
---

---

<br><br><br>  

# CH 02 데이터  

## 2-1 0과 1로 숫자를 표현하는 방법  
   
### Bit    
비트 : 0과 1을 나타내는 가장 작은 단위. On/Off 를 0과 1로 나타냄  
  
|1byte|8bit|
|---|---|
|1kB|1,000byte|
|1MB|1,000kB|
|1GB|1,000MB|
|1TB|1,000GB|
  
> 1,024씩 묶어서 표현한 단위는 kB, MB, GB 가 아니라 KiB, MiB, GiB이다.  
> 키비바이트, 메비바이트 같은 식으로 읽는다  
  
> ### 워드  
> CPU가 한 번에 처리할 수 있는 데이터의 크기  
> cpu에 붙어있는 32비트 또는 64비트 같은 것들  
   
<br>    
  
### 이진수의 음수 표현  
  
2의 보수법을 사용한다.  
[2의 보수법 설명](https://github.com/PhysicksKim/TIL/blob/main/CS/20221021_%EC%9D%8C%EC%88%98%ED%91%9C%EA%B8%B0%EB%B2%95%EA%B3%BC2%EC%9D%98%EB%B3%B4%EC%88%98.md)  
  
### 2의 보수법 구하기  
예시로 1001(2) 의 보수를 구해보자  
  
1. 먼저 양수 기준 2진법으로 값을 적는다  
 
|1|0|0|1|  
|---|---|---|---|
  
2. 모든 0과 1을 뒤집는다  

|0|1|1|0|  
|---|---|---|---|
    
3. 1을 더하면, 2의 보수가 완성된다    

|0|1|1|1|  
|---|---|---|---|
  
1001(2) -> 0111(2)  
  
<br>
  
### 16진법 - 코딩에 16진수를 쓰는 이유 
2진수를 그대로 다뤄야 하는 경우(ex.비트연산)   
2진수를 그대로 쓰면 너무 길이가 길어지므로  
10진수 보다 2진수 변환이 쉬운 16진수를 사용한다  
  
<br><br><br>    
  
## 2-2 0과 1로 문자를 표현하는 방법  
  
### 문자 집합과 인코딩  
문자 집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음  
문자 인코딩 : 문자를 0과 1로 변환하는 것    
문자 디코딩 : 0과 1을 문자로 변환하는 것  
  
<br>  
  
### 문자 인코딩 종류  

### A. 아스키 코드 ASCII
초창기 문자 집합이다  
7bit + parity 1bit 구조이다  
  
아스키코드는 표현할 수 있는 2^7개(128)밖에 없다는 단점이 있다.    
  
### B. EUC-KR  
아스키 코드의 한계에 따라 다양한 문자들을 표현하기 위한 인코딩이 탄생했고  
그 중 한글을 표현할 수 있는 대표적인 인코딩이 EUC-KR 이다  
  
> ### 완성형 인코딩 vs 조합형 인코딩  
> 한글은 초성, 중성, 종성으로 되어 있다.    
> 문자 인코딩도 마찬가지로 초성 중성 종성으로 나눠서 조합되는 형태의 인코딩이 있는데  
> 이를 조합형 인코딩이라고 한다  
> 반대로 완성형 인코딩은 모든 글자마다 다 따로 코드를 부여하는 문자 인코딩 방식을 말한다.  
>    
> 단순히 생각하면 한글에는 조합형 인코딩이 어울린다고 볼 수 있지만  
> [조합형 완성형 논쟁](https://namu.wiki/w/%EC%A1%B0%ED%95%A9%ED%98%95%20%EC%99%84%EC%84%B1%ED%98%95%20%EB%85%BC%EC%9F%81)  
> 초창기에 조합형과 완성형 중 어느쪽이 더 나은가에 대한 논쟁이 있었다  
> 논쟁은 후술할 유니코드의 등장으로 일단락되어, 완성형이 자리잡게 되었다  
  
### C. 유니코드 UTF-8
영어 + 한글만 표현할 수 있는 제한적인 문자 인코딩을 넘어서  
모든 문자를 다 표현할 수 있고, 심지어 이모티콘까지 표현할 수 있는 인코딩 방식인  
유니코드(Unicode)가 등장했다  
  
유니코드에도 여러 세부 인코딩 방식이 있는데  
그 중 가장 대중적인 방식이 UTF-8 이다  
  
UTF-8 은 1~4바이트로 가변길이 문자 인코딩 방식에 해당한다    
자세한 인코딩 방식에 대해 알 필요까지는 없으나  
궁금하면 [UTF-8 위키백과](https://ko.wikipedia.org/wiki/UTF-8) 만 봐도 알 수 있을 정도로 어렵지 않다  
  
  
<br><br><br>    
  
---

---

<br><br><br>  
  
# CH 03 명령어 
  
## 3-1 소스 코드와 명령어  

  
<br>
  
### 고급 언어와 저급 언어  
- 고급 언어 : 개발자가 이해하기 쉬운 언어    
- 저급 언어 : 컴퓨터가 이해하기 쉬운 언어  
  
**저급 언어**에는 2종류가 있다   
1. 기계어 : 0과 1의 명령어 비트로 이루어진 언어. 01010110 이라서 사람이 이해하기 힘듦
2. 어셈블리어 : 기계어의 각 명령을 단어로 변환한 언어.  
```
push  rbp
mov   rbp, rsp
mov   DWORD PTR [rbp-4], 1
```
  
**어셈블리어**가 저급 언어인 이유는    
기계어와 1대1 대응이 되기 때문이다  
(아닌 경우도 있다고는 한다)  
  
무슨 말이냐면  
고급 언어에서 하나의 명령어는   
기계어에서는 여러 명령어의 조합으로 이뤄지지만      
  
어셈블리어의 명령어 하나는 기계어 명령 하나와 같다는 뜻이다.    

  
<br>
  
### 개발자가 굳이 어셈블리어를 알아야 할까?  
요즘은 어셈블리어로 개발하는 경우는  
정말 Low Level 까지 건드리는 컴파일러, 운영체제, 임베디드 개발자 말고는 없다고 보면 된다.  
  
과거에야 컴파일러 최적화 수준도 낮고, 컴퓨터 성능도 안좋아서   
어셈블리어로 코딩하는 최적화가 필요했으나  
현대에는 컴파일러 수준도 높아졌고 컴퓨터 성능도 비약적으로 발전했기에   
굳이 어셈블리어로 코딩하는 최적화가 필요없다.  
  
더불어 컴파일러는 CPU나 운영체제를 고려해서 최적화까지 해주지만  
직접 어셈블리어로 코딩하면서 어셈블리어 + CPU + 운영체제 지식까지 겸비해 최적화하기는 어렵다.  
따라서 컴파일러보다 최적화를 잘 할 자신이 없으면  
그냥 C/C++로 코딩하는편이 더 최적화가 잘된다고 한다 (출처 - 나무위키)  
  
다만   
분야에 따라서 어셈블리어로 직접 까보면 좋은 경우도 있으니  
이럴때는 어셈블리어를 학습할 필요도 있다.  

  
<br>
  
### 컴파일 언어와 인터프리터 언어  
  
- 컴파일 언어 : 소스 코드를 저급 언어로 변환하는 과정  
컴파일러를 통해 저급언어로 변환된 코드를 Object Code(목적코드) 라고 한다.  
  
- 인터프리터 언어 : 코드가 한 줄씩 변환되어 실행되는 언어   
소스 코드를 한 줄씩 기계어로 변환하기에 컴파일 언어보다 느리다  

  
<br>
  
### 컴파일 언어 vs 인터프리터 언어  

얼핏 보기에는 컴파일 언어가 무조건 좋아보이겠지만  
OS 호환성이라던가 디버깅 등 문제로 인해서  
인터프리터의 장점도 있다  
  
이에 대한 내용은  
[20230202_JAVA는컴파일과인터프리터둘다해당.md](https://github.com/PhysicksKim/TIL/blob/main/CS/ComputerArchitecture/20230202_JAVA%EB%8A%94%EC%BB%B4%ED%8C%8C%EC%9D%BC%EA%B3%BC%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0%EB%91%98%EB%8B%A4%ED%95%B4%EB%8B%B9%2B%EA%B0%95%ED%83%80%EC%9E%85%EC%95%BD%ED%83%80%EC%9E%85%EB%8F%99%EC%A0%81%ED%83%80%EC%9E%85%EC%96%B8%EC%96%B4%EC%A0%95%EC%A0%81%ED%83%80%EC%9E%85%EC%96%B8%EC%96%B4.md)  
이전에 작성한 위 문서를 보면 더 자세히 알 수 있다.  
  
<br>
  
### 목적파일 vs 실행파일  
컴파일 결과가 목적(Object) 파일이 나온다고 앞서 말했는데  
목적 파일을 곧바로 실행할 수는 없고  
추가로 **링킹**이라는 작업이 필요하다  
  
링킹은 목적 코드 안에서 가져다 쓴 외부 기능들을 연결시켜주어 실행파일로 만드는 작업을 말한다  
  
예를 들면 화면에 글자를 출력하는 기능들은 main.o 에 없고  
대표적으로 c언어에서 include 한 stdio.h 에 있다  
이를 연결시켜주는 작업이 링킹이다.  
  

<br><br><br>    
  
## 3-2 명령어의 구조
  
<br>
  
### 연산 코드 , 오퍼랜드
- 연산 코드  
: Operation Code. 연산자. 명령어가 수행할 연산  
  
- 오퍼랜드  
: Operand. 피연산자. 연산에 사용할 데이터 OR 연산에 사용할 데이터가 저장된 위치.  
**오퍼랜드에는 데이터를 직접 담는 경우보다, 데이터가 있는 주소를 담는 경우가 많다**
   
#### 오퍼랜드 예시  
|더해라|100과|120을|
|---|---|---|  
  
기계어와 어셈블리어도 마찬가지로 **연산코드**와 **오퍼랜드**로 구성되어 있다  
```
push  rbp
mov   rbp, rsp
ret   
```
앞에 push 와 mov 가 연산코드  
뒤에 rbp, rsp 가 오퍼랜드 이다.  
ret 처럼 연산코드만 있고 오퍼랜드가 없는 경우도 있다.  
  
<br><br>  
  
### 주소 지정 방식  
앞서  
> **오퍼랜드에는 데이터가 있는 주소를 담는 경우가 많다**  

라고 했다. 왜냐하면  
**명령어의 길이 때문**이다.  
  
오퍼랜드 안에 값을 직접 담으면  
크기가 큰 데이터를 담을 수 없기 때문이다.  
  
- 유효주소(effective address) : 연산 대상이 되는 데이터가 저장된 위치    
- 주소 지정 방식(addressing mode) : 연산에 사용할 데이터 위치를 찾는 방법  
    
<br><br>  

### CPU의 다양한 주소 지정 방식  
  
1. 즉시 주소 지정 방식 (immediate addressing mode) : 연산에 사용할 데이터 저장  
2. 직접 주소 지정 방식 (direct addressing mode) : 유효 주소(메모리) 저장  
3. 간접 주소 지정 방식 (indirect addressing mode) : 유효 주소의 주소 저장  
4. 레지스터 주소 지정 방식 (register addressing mode) : 유효 주소(레지스터) 저장
5. 레지스터 간접 주소 지정 방식 (register indirect addressing mode) : 유효 주소를 저장한 레지스터 저장  
  
<br><br><br>    
  
---

---

<br><br><br>  
  
# CH 04 CPU의 작동 원리  

## 4-1 ALU와 제어장치  
  
### ALU(arithmetic and logical unit)
산술 연산, 논리 연산을 담당한다  
레지스터를 통해 피연산자를 받고  
제어장치로 부터 제어신호를 받는다.  
  
### 플래그  
연산 결과에 대한 추가적인 상태 정보  
  
|플래그 종류|의미|
|---:|---|
|부호 플래그|연산 결과 부호를 나타냄 (1이 음수)|
|제로 플래그|연산 결과가 0인지 여부|
|캐리 플래그|연산 결과 올림/내림 발생 여부|
|오버플로우 플래그|오버플로우 발생 여부|
|인터럽트 플래그|인터럽트 가능한지 여부 (4장)|
|슈퍼바이저 플래그|커널 모드/사용자 모드 여부 (9장)|
   
<br>  
  
### 플래그 레지스터 예시  
  
|부호 플래그|제로 플래그|캐리 플래그|오버플로우 플래그|인터럽트 플래그|슈퍼바이저 플래그|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|0|1|0|0|0|
  
플래그 레지스터는 위와 같이 연산 결과 플래그를 나타낸다.  
위의 예시를 보면, 부호는 1이므로 음수이며, 캐리가 발생했음을 알 수 있다.  
  
<br>  
  
### 제어장치의 Input/Output
- 제어장치  
제어 신호를 내보내고, 명령어를 해석하는 부품  

### Input
1. 클럭 신호 : cpu는 클럭 신호에 맞춰서 동작함  
2. 해석해야 할 명령어 
3. 플래그 레지스터 속 플래그 값  
4. 제어 버스의 제어 신호 : 입출력장치 같은 CPU 외의 장치가 발생시킨 제어 신호를 받아들임  
  
### Output  
CPU는 Output으로 제어 신호를 보낸다.  
크게 제어 신호는 2가지, 외부로 / 내부로 보내는 신호로 나뉜다.  
  
1. 외부에 제어 신호 : 제어 버스로 보냄. 메모리, 입출력장치 등을 대상으로 함.    
2. 내부에 제어 신호 : CPU 내부에 있는 unit들에 보냄. ALU, 레지스터를 대상으로 함.  
  
<br><br><br>    
  
## 4-2 레지스터  
  
### 반드시 알아야 할 레지스터  

<br>

- **프로그램 카운터**   
다음에 읽을 명령어가 저장된 메모리 주소.    
  <br>
   
- **명령어 레지스터**   
메모리에서 읽어 들인 명령어를 해석하기 위해 저장  
  <br>
  
- **메모리 주소 레지스터**   
읽을 메모리의 주소를 저장하는 레지스터. CPU가 읽을 주소값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침.    
  <br>
  
- **메모리 버퍼 레지스터**   
메모리와 주고받을 값을 저장하는 레지스터. 쓰고 싶은 값, 받고 싶은 값이 거쳐가는 곳.  
  <br>
  
- **플래그 레지스터**   
연산 결과나 CPU 상태에 대한 부가 정보를 저장하는 곳. [앞서 본](https://github.com/PhysicksKim/TIL/blob/main/Books/20230204_%ED%98%BC%EC%9E%90%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0+%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.md#%ED%94%8C%EB%9E%98%EA%B7%B8) 플래그 값들을 저장.    
  <br>
  
- **범용 레지스터**   
다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터. 데이터와 주소 모두 저장 가능.  
  <br>
  
- **스택 포인터** (바로 아래에 자세히)    
스택 포인터를 이용한 주소 지정 방식에서, 스택 꼭대기를 가리키는 레지스터.   
  <br>
  
- **베이스 레지스터** (바로 아래에 자세히)   
베이스 레지스터 주소 지정 방식에서, 기준 주소의 역할을 하는 베이스 주소 값을 저장.  
  
<br><br>  
  
### 특정 레지스터를 이용한 주소 지정 방식  
1. 스택 주소 지정 방식  
메모리에 스택 영역이 있음.  
스택 자료구조를 사용해 값을 저장하며  
**스택 포인터**가 스택의 꼭대기를 가리킨다.  
  
2. 변위 주소 지정 방식  
메모리 주소를  
```
유효 주소 = 오퍼랜드 + 변위  
```
형태로 지정하는 방식.  
  
- 상대 주소 지정 방식 
오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻음.   
  
- 베이스 레지스터 주소 지정 방식  
오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻음.  

<br><br>
  
> ### 상대 주소 지정 vs 베이스 레지스터 주소 지정 차이점  
> 둘 다 기본 방식은 동일하다  
> 기준점이 되는 **변위** 가 각각 있고 (프로그램 카운터, 베이스 레지스터)  
> 거기에 주소 Offset 값이 되는 오퍼랜드가 더해지는 형식이다  
>   
> 둘의 차이점은 사용 용도와 기준점이 되는 변위가 어떻게 저장되어있는지에 차이가 있다.
>     
> 상대 주소 지정(프로그램 카운터) : 분기 명령어 근처에 분기될 위치가 있는 경우 흔히 사용된다.    
> 베이스 레지스터 주소 지정(베이스 레지스터) : 기억장치 재배치시 유용하다.  
>  
> 그럼 둘은 동일해 보이는 데 왜 용도에 차이가 있는가?  
> 그 이유는, 프로그램 카운터는 하나만 존재하고, 베이스 레지스터는 여러 개 세트로 가지고 있다는 차이에서 발생한다.  
> [참고](https://www.geeksforgeeks.org/difference-between-pc-relative-and-base-register-addressing-modes/)  
> ![image](https://user-images.githubusercontent.com/101965836/217505080-c29c9c03-9cb8-46d1-92a5-25999bfade4d.png)  
> ![image](https://user-images.githubusercontent.com/101965836/217505065-96b22c5b-6053-491d-8189-70a37f32a76a.png)  
> 위의 이미지를 통해 보면  
> 프로그램 카운터(PC)는 하나만 갖고 있기 때문에,  
> 지금 실행중인 명령어들을 순차적으로 접근하는 용도로 쓰이며  
> 베이스 레지스터는 여러 세트로 갖고 있기 때문에,  
> 메모리 주소를 재배치 할 때 기준점이 되는 주소를 왕창 가져온 다음 재배치 하기에 유용하다.  
  
<br><br><br>    
  
## 4-3 명령어 사이클과 인터럽트  

### 명령어 사이클  
: CPU가 명령어를 꺼내오고 실행하면서 반복되는 동작이 사이클을 이룬 것을 말한다    
  
<br>
  
### 대표적 3가지 명령어 사이클     
1. 인출 사이클  
: 메모리에서 명령어를 CPU로 가져오는 단계  
   
2. 실행 사이클  
: CPU로 가져온 명령어를 실행하는 단계  
  
3. 간접 사이클  
: 간접 주소 지정 방식을 사용할 때, 주소를 따라 메모리에 다시 접근 하는 단계  
  
<br><br>  
  
### 인터럽트  
: 현재 작업을 중단하고, 다른 더 급한 작업을 처리하는 것.  
  
1. 동기 인터럽트 : CPU에 의해 발생하는 인터럽트. 프로그래밍상 오류에 해당(예외라고 함)  
2. 비동기 인터럽트 (**하드웨어 인터럽트**) : 주로 입출력장치에 의해 발생하는 인터럽트. 입출력 작업을 요청함.  
  
> 일반적으로 비동기 인터럽트라 칭하지만  
> 입출력 장치에서 발생했다는 의미를 담아서  
> 더 직관적인 "**하드웨어 인터럽트**" 로 부르겠다  
  
<br>
  
### 하드웨어 인터럽트 사용 이유    
입출력 장치는 CPU보다 속도가 느리기 때문에  
CPU가 주기적으로 입출력 장치를 확인하기 보다는  
입출력장치가 다른 작업을 요청하는 게 효율적이다.  
  
따라서 하드웨어 인터럽트를 사용한다.  
  
<br> 
  
### 하드웨어 인터럽트 처리 순서  
1. 입출력장치 -> CPU  **인터럽트 요청 신호** 보냄  
2. CPU가 **인터럽트 플래그**를 확인함  
3. **인터럽트 벡터**를 참조하여, **인터럽트 서비스 루틴**을 실행한다  
  
- 인터럽트 요청 신호  
입출력장치가 CPU에게 인터럽트 해도 되는지 물어봄  

- 인터럽트 플래그
중요한 작업 중이라서 인터럽트를 받지 않는다면 인터럽트 플래그가 1로 설정되어있다  
CPU는 인터럽트 플래그를 확인하고, 인터럽트 플래그에 따라서 인터럽트를 받을지 말지를 알려준다.  
  
- 인터럽트 벡터  
인터럽트 서비스 루틴이 저장된 위치를 말한다  
  
- 인터럽트 서비스 루틴 (인터럽트 핸들러)  
각각의 인터럽트 발생 시 어떤 동작을 할지에 대한 내용이 담긴 프로그램을 말한다   
    
<br>  

### 인터럽트 발생 시, 실행 중이던 프로그램은?
기존에 작업 중이던 내용을 백업해둔다.  
인터럽트가 발생하면  
프로그램 카운터 값 등 기존 프로그램 실행에 쓰이던 값들을 메모리에 있는 스택 영역에 백업해둔다.     
  
<br>  

### 예외의 종류  
앞서 **동기 인터럽트** 는 **예외** 라고 했다  
예외가 발생한 뒤에 어떻게 CPU가 동작할 지에 따라서 4가지로 나뉜다.  

1. 폴트 : 예외 처리 후 **예외가 발생한 명령어부터** 재개  
2. 트랩 : 예외 처리 후 **예외가 발생한 명령어 다음부터** 재개
3. 중단 : 예외 발생 시 **프로그램을 강제로 중단** 해야함. 심각한 오류
4. 소프트웨어 인터럽트 : 시스템 호출이 발생했을 때 나타남. (9장에서 )  
  
<br><br><br>    
  
---

---

<br><br><br>  
  
# CH 05 CPU 성능 향상 기법  

## 5-1 빠른 CPU를 위한 설계 기법  
  
- a. 클럭
- b. 멀티코어
- c. 멀티스레드
  
### a. 클럭
클럭은 cpu가 신호 하나를 보내는 최소 단위를 말한다.  
컴퓨터 부품들은 클럭 신호에 맞춰서 움직인다.  
  
따라서 cpu가 시간당 더 많은 신호를 보낼 수 있다면  
곧 더 많은 계산, 더 많은 명령을 내릴 수 있다.  

그러므로 CPU 클럭이 높아지면 성능도 좋아진다.  
  
> ### 오버클럭  
> CPU 클럭 속도를 강제로 끌어올리는 기법  
  
> ### Q. 클럭 속도 강제로 올리면 안되나?
> A. 발열 문제 때문에 안된다. 시간당 더 많은 전류가 흐르면, 그만큼 발열도 증가하기 때문이다.  
  
<br><br>
  
### b. 멀티코어  
  
클럭 속도의 한계가 있으니  
그냥 코어 하나 더 두면 되지 않겠는가?  
  
다만 단순히 CPU 코어를 여러개 둔다고 끝이 아니라  
여러 CPU 코어들이 "같이 적절히 잘" 동작해야 하니까  
하드웨어, 소프트웨어(OS, 프로그램) 둘 다 멀티코어에 맞게 잘 동작해야한다  
  
현대의 CPU들은 대부분 멀티 코어로 동작하지만   
앞서 말한대로 "같이 적절히 잘" 동작해야 하므로  
꼭 코어 수에 비례해서 연산 속도가 증가하지는 않는다   
  
<br><br>  
  
### c. 멀티 스레드  
- **스레드** : **실행 흐름의 단위**   
  
스레드는 사전적 의미로부터 두 가지로 나뉜다.    
1. 하드웨어적 스레드  
2. 소프트웨어적 스레드  
  
<br><br>  
  
- 하드웨어적 스레드  
: 하나의 코어가 동시에 여러 명령어를 처리    
<br>**멀티스레드 프로세서** 또는 **멀티스레드 CPU** 라고 한다.  
또는 **인텔의 멀티스레드** 기술을 일컬어 **하이퍼스레딩** 이라고 한다  
  
<br>
  
- 소프트웨어적 스레드  
: 하나의 프로그램에서 독립적으로 실행되는 단위  
근데, 1코어 1스레드 CPU도 소프트웨어적 스레드는 수십 개 실행할 수 있다.  
  
<br>
  
### 멀티스레드 프로세서의 핵심 - 레지스터  
**레지스터가 왜 핵심**인가?  
CPU는 현재 프로그램의 어디를 실행하고 있는지를 레지스터에 저장하기 때문(프로그램 카운터 레지스터)      
  
<br><br><br>  
  
## 5-2 명령어 병렬 처리 기법  
  
### 명령어 병렬 처리 기법  
1. 명령어 파이프 라이닝  
2. 슈퍼스칼라   
3. 비순차적 명령어 처리    
  
<br>

### 1. 명령어 파이프 라인
![image](https://user-images.githubusercontent.com/101965836/218108513-2ff11109-abe8-470f-a18f-6b8e0205a0a8.png)  
  
CPU가 명령을 처리하는건, 단순히 하나의 처리가 아니다.   
메모리에서 명령을 가져오는 작업, 명령을 해석하는 작업, 명령을 실행, 연산, 저장 등  
다양한 작업을 각기 해당 유닛이 처리하게 된다.  
  
따라서   
명령어 처리 과정이 인출 , 해석, 실행 , 저장 과정으로 나뉜다고 하면  
명령어 하나 다 처리하고 다음 명령어 처리하는 게 아니라  
위처럼 겹치게 수행해서 효율적으로 처리하는 게 더 빠르게 명령어를 처리할 수 있게된다.  
  
### 파이프라인 위험  
1. 데이터 위험 : 명령어간 데이터 의존성   
이전 명령어를 끝내야만 다음 명령어를 실행할 수 있는 경우   
  
2. 제어 위험 : 프로그램 카운터의 갑작스러운 변화   
다음 명령어를 순차적으로 가져왔는데, 앞선 명령 결과로 프로그램 카운터가 바뀌면, 미리 처리한 명령어가 쓸모없어진다   
  
3. 구조적 위험 : 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려 할 때 발생   
자원 위험 이라고도 한다.   
  
<br><br>  
  
### 2. 슈퍼스칼라  
CPU 내부에 여러개의 명령어 파이프라인을 두는 구조  
  
이론적으로는 파이프라인 개수에 비례해서 처리 속도가 빨라지지만  
파이프라인 위험 같은 문제로   
파이프라인 개수에 비례해 빨라지지 않는다.  
   
<br><br>
  
### 3. 비순차적 명령어 처리   
명령어 처리 순서를 바꿔서(**비순차적**), 앞서 본 파이프라인 위험을 회피해서 명령어를 처리하는 방식  
순서를 바꿔 실행할 수 있는지(**데이터 의존성**) 판단할 수 있어야 함  
  
> 아래와 같이 순차적으로 명령어가 a부터 f까지 처리해야 한다고 해보자.    
> a b c d e f   
> 근데 **b 명령어가 다 끝나야 c를 처리할 수 있다**면  
> a b **d e f** c   
> 이런 식으로 처리한다면 더 효율적으로 처리될 수 있을 것이다.  
> 이를 비순차적 명령어 처리라고 한다    
>    
> 따라서 비순차적 명령어 처리를 위해서는 데이터 의존성 파악을 할 수 있는지가 중요하다.  
  
<br><br><br>      
  
## 5-3 CISC 와 RISC  
  
CPU의 명령어 병렬 처리 기법을 생각해보면  
결국 "**명령어 파이프 라이닝**" 을 어떻게 할 지가 관건임을 알 수 있다.  
  
그러면 반대로  
**명령어가 파이프 라이닝하기 쉽게 생기면**  
병렬 처리가 더 잘 될 것이다.  
  
<br>
  
### ISA(Instruction Set Architecture) 명령어 집합 구조  
ISA : CPU가 이해할 수 있는 명령어들의 모음을 말한다  
  
집합 구조(Set Architecture)가 붙는 이유는  
ISA가 다르면 CPU 구조와 설계 자체가 달라지기 때문이다   
  
또한 앞서 말했듯  
ISA에 따라서 병렬 처리에 유리한 ISA가 있고, 그렇지 못한 ISA가 있다.  
이를 알기 위해 양대산맥인 **CISC**와 **RISC**에 대해 알아보자  
  
<br><br>  
  
### CISC (Complex Instruction Set Computer)  
**가변 길이 명령어** 방식을 사용한다  
CISC에는 다양하고 강력한 명령어들이 많아서   
하나의 명령어로 많은 일을 처리할 수 있었기에   
메모리를 최대한 아끼며 개발해야 하던 시절에는 인기가 많았다  
  
하지만  
명령어가 복잡하고 다양한 기능을 제공하는 탓에  
명령어 크기와 실행 시간이 일정하지 않아서 병렬처리에 문제가 있다.  
  
달리 말하면    
규격화 되지 않은 명령어가  
파이프라이닝을 어렵게 한다.  
  
> 대다수의 복잡한 명령어는 사용 빈도가 낮다.  
> 20% 가 80%의 사용량을 차지한다고도 한다.  

> 인텔의 x86 , x86-64 가 대표적인 CISC 이다  
  
<br><br>  
  
### RISC (Reduced Instruction Set Computer)  
CISC의 한계로 RISC는 병렬 처리에 유리하도록 설계됐다.  
명령어의 종류가 적고, 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.  
  
> 메모리 접근 명령어도 load store 두 개 밖에없다. 그래서 load-store 구조 라고 부르기도 한다  
  
즉, **고정 길이 명령어**를 사용한다.  
  
대표적으로 ARM이 RISC 기반의 ISA 이다.  
  
|CISC|RISC|
|---|---|
|복잡하고 다양한 명령어|단순하고 적은 명령어|
|가변 길이 명령어|고정 길이 명령어|
|다양한 주소 지정 방식|적은 주소 지정 방식|
|프로그램을 이루는 명령어의 수가 적음|프로그램을 이루는 명령어의 수가 많음|
|여러 클럭에 걸쳐 명령어 수행|1클럭 내외로 명령어 수행|
|파이프라이닝 어려움|파이프라이닝 쉬움|  
  
  
<br><br><br>    
  
---

---

<br><br><br>  
  
# CH 06 메모리와 캐시 메모리  

## 6-1 RAM의 특징과 종류
  
### RAM의 특징  
- RAM에는 **실행할 프로그램**의 **명령어**와 **데이터**가 저장됩니다.  
- 전원을 끄면 내용이 사라지는 **휘발성 저장장치**와 내용이 사라지지 않는 **비휘발성 저장 장치**가 있다  
  
### RAM의 용량과 성능  
RAM 용량이 크면, 많은 프로그램을 동시에 실행하는데 유리하다  
  
> 간단하게, 프로그램 A , B , C 가 각각 메모리를 1GB 쓴다고 하자  
> 이 때 만약 2GB 램을 쓴다면,   
> A B C 프로그램을 동시에 메모리에 올릴 수 없다.  
> 따라서 A B 만 띄워놓다가 C를 써야하는 상황이 오면,   
> 그 때 메모리보다 느린 HDD 등에서 명령어와 데이터를 가져와야 한다  
>   
> 그러므로 RAM보다 훨씬 느린 HDD 속도에 따라 프로그램이 실행되므로,  
> 큰 속도 저하를 겪게된다.  
>  
> 반면, 램이 8GB로 든든하다면, 그냥 A B C 다 메모리에 띄워둘 수 있기 때문에  
> 작업 전환시에도 비교적 느린 HDD 속도에 맞춰 프로그램이 실행되게 되므로  
> 사용자는 속칭 렉을 겪게 된다.  
  
<br><br>  
  
### RAM의 종류  
  
- DRAM (Dynamic RAM)  
시간이 지나면 데이터가 사라지므로(Dynamic), 데이터 소멸을 막기 위해 재활성화를 해줘야 하는 RAM  
소비 전력 ↓  저렴 ↓  집적도 높음 ↑  => 대용량 설계에 용이하다  
=> **주기억장치(RAM)** 에 사용    
   
<br>
   
- SRAM (Static RAM)  
저장된 데이터가 사라지지 않는 RAM  
소비 전력 ↑  비쌈 ↑  집적도 낮음 ↓  속도 빠름 ↑  
=> **캐시 메모리** 에 사용  
  
<br>
  
- SDRAM (Synchronous Dynamic RAM)  
DRAM + 클럭 신호와 동기화  
클럭 타이밍에 맞춰서 CPU와 정보를 주고받을 수 있다   
  
<br>  
  
- DDR SDRAM (Double Data Rate SDRAM)  
SDRAM 의 2배 대역폭  
대역폭(data rate) : 데이터를 주고 받는 길의 너비  
대역폭을 배로 늘렸기 때문에, 전송 속도도 배로 늘어난다    
  
<br>  
  
### DDR SDRAM
DDR도 DDR2, DDR3 ... 로 늘어날 때마다 2배씩 대역폭이 증가한다  
  
- 대역폭 증가 예시  

|SDRAM | DDR SDRAM | DDR2 | DDR3 | DDR4 | 
|---|---|---|---|---|
|1|2|4|8|16|
  
SDRAM의 대역폭을 1이라고 하면  
위와 같이  
DDR SDRAM은 2가 되고  
DDR2 : 4 / DDR3 : 8  
같은 식으로 2배씩 대역폭이 늘어난다.  
   
<br><br>
  
## 6-2 메모리의 주소 공간  
메모리에 저장된 주소는  **물리 주소** 와 **논리 주소** 로 나뉜다  
  
- 물리 주소 : 메모리 하드웨어가 사용하는 주소. 실제 하드웨어상 주소  
- 논리 주소 : CPU와 실행중인 프로그램이 사용하는 주소. 프로그램 각각에 0번지 부터 부여하는 주소  
  
<br><br>  
  
### 왜? 물리 주소와 논리 주소를 따로 구분해서 쓸까?  
이유 : 메모리 어디에 무슨 명령이 저장되어 있는지 다 알지는 못함    
=> 메모리에 저장된 정보는 시시각각 변하기 때문이다 
  
<br>  
  
### 왜 시시각각 변하는가?  
메모리에 프로그램을 적재되었다가 내려오길 반복하면서  
실제로 프로그램이 올라간 위치가 바뀌기 때문이다.  

### 논리 주소 필요성 
같은 프로그램을 실행하더라도  
실제 적재되는 주소는 1000, 2300, 3600 같이   
실행할 때마다 계속 바뀔 수 있다.  
  
따라서 CPU가 이를 추적하기보단,   
CPU는 그냥 프로그램마다 0부터 끝까지 표현하는 논리 주소를 다루도록 하고  
따로 메모리 관리 장치가 논리 주소를 실제 물리 주소로 변환하도록 한다  
   
<br>
  
### 메모리 관리 장치 (Memory Management Unit ; MMU)  
MMU는 **베이스 레지스터 값**을 더하여  
논리 주소를 물리 주소로 변환한다.  
  
예를들어  
프로그램 A가 주소 1000 부터 시작하고,  
CPU는 A 실행중이며 논리 주소 100을 갖는다면  
100 + 1000 = 1100 으로 접근한다.  
  
<br>  
  
### 메모리 보호 기법  
메모장이 1000 ~ 2000 에 적재되어 있는데  
만약 cpu가 논리주소로 1500번째 명령어 실행해라고 하면  
메모장 범위 밖의 명령을 실행하게 된다.  
  
따라서  
**한계 레지스터** (Limit Register) 가 이를 방지하기 위해  
논리 주소 > 한계 레지스터   
인 경우, 인터럽트를 발생시켜 실행을 중단시킨다.  
  
<br><br><br>  
  
## 6-3 캐시 메모리  
