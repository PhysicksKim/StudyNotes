# CH 09 운영체제 시작하기 

## 9-1 운영체제 알아야 하는 이유  
    
- 시스템 자원 : 프로그램 실행에 필요한 요소 (=자원)     
ex. CPU 메모리 보조기억장치 같은 컴퓨터 부품들 모두 다 해당  
  
- 운영체제 : 필요한 자원을 할당하고, 올바르게 실행되도록 돕는 프로그램   

### 커널 영역  
운영체제도 메모리에 적재되지만  
운영체제는 특별한 프로그램이므로  
메모리에서 **"커널 영역"** 이라는 특별한 곳에서 실행된다  
  
### 사용자 영역  
응용 프로그램이 적재되는 영역을 **사용자 영역** 이라고 한다  
  
### 운영체제가 메모리 관리  
운영체제가 프로그램을 메모리에 적재, 삭제, 재배치 한다    
    
따라서, **운영체제가 중요한 이유**   
메모리 자원을 잘 관리하는 게 중요하기 때문이다.    
  
### CPU 할당  
운영체제는 메모리 관리 뿐만 아니라   
프로그램별 CPU 자원 할당도 담당한다.   
따라서 CPU 할당 문제 또한 중요한다.   
    
예를 들어  
CPU가 입출력장치 같이 느린 장치의 응답만 대기하고 있다면    
자원 낭비가 될 수 있다.  
  
따라서, **운영체제가 중요한 이유**  
CPU 스케쥴링 등을 효율적으로 처리하는 것도 중요하기 때문이다.  
  
<br>  
  
### 개발자에게 운영체제 중요한 이유  
하드웨어를 직접 다루는 임베디드 개발자라면 당연히 운영체제 지식이 중요하다.   
  
그러면, **웹 개발자**에게 운영체제는??   
사용의 측면에서 중요한 게 아니라,  
이해를 위한 기초 지식 측면에서 중요하다.  
  
예를 들어   
무작정 Arrays.sort() 를 사용하는 사람과  
자료 구조를 이해하고 sort()를 사용하면 어떤 알고리즘과 시간 복잡도로 메서드가 돌아가는지 아는 사람은  
코드를 왜 그렇게 써야하는지 이해하는 정도가 다르다.  
  
기초 지식 없이 무작정 Arrays.sort()만 쓰는 사람은  
Counting Sort가 갑자기 소스코드에 등장했을때  
왜 그런지 설명해도 기초지식이 없어서 이해할 수 없다.  
  
마찬가지로  
운영체제도 잘 이해하기 위해서 필요하다.  
직접 운영체제에게 메모리 할당을 어떻게 해라 라고 명령할 일은 거의 없겠지만  
"이렇게 하면 GC가 효율적으로 동작합니다" 라는 내용이 있을 때  
GC를 이해하기 위한 운영체제 지식이 필요하다.    
    
추가로,   
에러 메세지에 따라 어떤 문제인지 추측할 때도 중요하다    
예를 들어    
운영체제가 "이거 커널에서 문제났어" 라고 에러 메세지를 띄울 때      
운영체제를 모른다면 "헉. 나 커널 모르는데" 라고 공포감이 들 수 있다.     
하지만, 커널이 뭔지 알고 어떻게 동작하는지 안다면 당황하지 않고 어떻게 에러에 접근해야 할 지 알 수 있다.  
  
따라서  
직접 운영체제를 다루지 않더라도,   
개발자라면 운영체제에 대한 지식은 기초로 갖추고 있어야 도움이 된다    
더 좋은 코드, 적절한 에러 대응에 운영체제 지식이 필요하다     
  
<br><br><br>  

## 9-2 운영체제의 큰 그림  
  
**커널** 이 매우 중요하다  
**이중모드**, **시스템 호출** 개념을 알아보자  
  
### 운영체제의 심장, 커널  
커널을 어떻게 사용하는지에 따라서   
프로그램이 하드웨어를 이용하는 양상이 달라지고,   
컴퓨터 전체 성능도 달라진다.   
   
운영체제를 지칭할 때는, 커널을 지칭한다고 봐도 무방한다.   
   
### 사용자 인터페이스  
사용자가 운영체제와 상호작용 할 수 있는 통로  
  
- 그래픽 유저 인터페이스  
- 커맨드 라인 인터페이스  
  
<br>  
  
### 이중 모드와 시스템 호출  
  
응용 프로그램들이 **하드웨어 자원에 접근**하려고 할 때  
무조건 운영체제를 거쳐야 한다  
   
- **이중 모드** : CPU 명령어 실행 모드를 **사용자 모드**와 **커널 모드**로 구분하는 방식   

1. 사용자 모드 : 커널 영역의 코드를 실행할 수 없는 모드   
CPU는 하드웨어 자원에 접근하는 명령어를 실행할 수 없다    
2. 커널 모드 : 운영체제 서비스를 제공받을 수 있는 모드   
  
> 슈퍼바이저 플래그 레지스터를 보고 커널 모드인지 사용자 모드인지 구분한다  
   
사용자 모드로 실행되는 프로그램이  
운영체제 서비스를 제공받으려면  
**시스템 호출(System Call)** 을 요청한다  
  
시스템 호출은 일종의 인터럽트이며  
CPU가 시스템 호출을 처리하는 순서 또한 인터럽트 처리 순서와 유사하다  
  
<br>

### 운영체제의 핵심 서비스  

### 1. 프로세스 관리
- 프로세스 : 실행 중인 프로그램을 말한다  
  
하나의 CPU 코어는 한 번에 하나의 프로세스만 실행할 수 있다  
따라서 CPU는 프로세스를 번갈아 가면서 실행해야 한다.  
  
그치만 프로세스들은 제각각 상태, 사용하는 자원 들이 다양하고  
당장에 진행이 불가능한 프로세스도 있다  
  
따라서 운영체제는 다양한 프로세스들이 균형잡히게 또는 급한 프로세스를 빨리 처리하는 식으로  
프로세스를 관리하면서 실행할 수 있어야 한다  
  
이에 대해 10장에서 알아본다  

<br>  
  
### 2. 자원 접근 및 할당  
운영체제가 각 자원들을 어떻게 관리하고, 어떤 기능을 제공할까?   
  
- CPU : 해당 프로세스가 얼마나 CPU를 오래 사용할지 결정 -> **CPU 스케쥴링** (11장)  
- 메모리 : 어떻게 메모리에 프로세스를 적재하고, 메모리 부족시 어떻게 대처할지 -> **메모리 관리** (14장)  
- 입출력장치 : 입출력 인터럽트 발생시 어떻게 서비스 루틴을 실행하는가 -> 인터럽트 서비스 루틴

<br>

### 3. 파일 시스템 관리
보조기억장치 속 데이터를 어떻게 파일과 디렉토리로 관리하는지 (15장) 

<br><br><br>    
  
---

---

<br><br><br>  

# CH 10 프로세스와 스레드  
  
### 프로세스 
- 포그라운드 프로세스 : 사용자가 보는 앞에서 실행되는 프로세스    
- 백그라운드 프로세스 : 사용자가 보지 못하는 뒤에서 실행되는 프로세스  
유닉스 = **데몬** | 윈도우 = **서비스** 
  
### 프로세스 제어 블록  
운영체제는 빠르게 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분한다   
이를 위해서  
운영체제는 **프로세스 제어 블록(PCB)** 을 이용한다  
  
![image](https://user-images.githubusercontent.com/101965836/221890767-30de3723-ee7c-460d-9f61-1267dfed0cd4.png)  
- 각 프로세스는 식별을 위한 PCB를 각자 달고있다.   
- PCB는 커널 영역에 생성된다  
- 운영체제는 PCB로 특정 프로세스를 식별하고, 프로세스 처리에 필요한 정보를 판단한다.  
  
### PCB에 담기는 정보  

- 프로세스 ID (**PID**) : 프로세스를 식별하기 위한 고유 번호   
- 레지스터 값 : 프로세스 실행에 사용하는 프로그램 카운터를 비롯한 레지스터 값    
- 프로세스 상태 : 프로세스가 어떤 상태인지도 PCB에 기록 (ex. 입출력 대기상태, cpu 대기상태, cpu 이용중)    
- CPU 스케쥴링 정보 : 프로세스가 언제 어떤 순서로 CPU에 할당받을지  
- 메모리 관리 정보 : 메모리에 저장된 위치. 페이지 테이블 정보, 베이스 레지스터, 한계 레지스터 같은 프로세스 실행을 위한 메모리 관련 값들이 담긴다.  
- 사용한 파일과 입출력 장치 목록    
  
### 문맥 교환 (Context Switching)
다른 프로세스로 실행 순서가 넘어가면   
이전까지 실행중이던 프로세스의 각종 정보들을 따로 백업해둬야 한다  
여기서  
이전에 실행하던 정보들을 **"문맥"** 이라고 하며  
**문맥 교환** 은 이렇게 프로세스가 전환될 때, 다른 프로세스의 문맥으로 전환하는 것을 말한다.  
  
<br>

### 프로세스의 메모리 영역  
메모리의 사용자 영역에는 프로세스가 어떻게 적재될까?    
  
크게 아래와 같이 나뉘어서 메모리에 적재된다    
  
1. 코드 영역  
2. 데이터 영역  
3. 힙 영역  
4. 스택 영역  
  
이렇게 나뉜다.  
  
### 1. 코드 영역  
Code Segment (= Text Segment) 라고 부른다  
  
기계어 명령어가 코드 영역에 저장되며  
CPU가 실행할 명령어가 담기므로 **읽기 전용** 공간이다  
  
### 2. 데이터 영역  
프로그램이 실행되는 동안 유지 할 데이터가 저장되는 공간이다.  
ex. 전역 변수  
  
> 코드 영역과 데이터 영역은 크기가 변하지 않는다  
> 따라서 '크기가 고정된 영역' 이라는 뜻으로, **정적 할당 영역** 이라고도 부른다  
> 반대로 **힙 영역, 스택 영역** 은 크기가 변하므로 **동적 할당 영역** 이라고 부른다  
  
### 3. 힙 영역  
프로그래머가 직접 할당할 수 있는 저장 공간이다.  
예를 들어 자바 같은 경우 new Object() 같이 오브젝트를 만든다 하면 힙 영역에 데이터가 저장된다  
  
> 그런데 프로그래머가 직접 할당하는 공간이다 보니까  
> 더 이상 쓰지 않는데도 데이터를 남겨두는 실수를 하기도 하는데  
> 이로 인해 무의미한 정보가 메모리에 남게되는 **"메모리 누수"** 가 발생한다.  
  
### 4. 스택 영역  
데이터를 일시적으로 저장하는 공간이다.  
잠깐 쓰다가 마는 지역 변수, 매개 변수들이 저장되는 공간이다.  
  
<br><br>  
  
### 동적 영역의 주소 할당 방향  
![image](https://user-images.githubusercontent.com/101965836/222139311-8a0a7a4c-b759-401e-9839-c5a6b33fb6dc.png)  
[이미지 출처](https://velog.io/@yeahg_dev/TIL11.-C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)  
  
동적 할당 영역(스택, 힙 영역)은 크기가 변하기 때문에  
위 그림처럼,   
스택은 높은 주소 -> 낮은 주소 순으로 할당하고  
힙은 낮은 주소 -> 높은 주소 순으로 할당하도록 한다.  
  
이렇게 해서 메모리가 다 차지 않는 이상은  
가로막혀 할당된 주소가 불연속적이게 되지 않도록 한다.  
  
<br><br><br>  
  
## 10-2 프로세스 상태와 계층 구조  
  
### 프로세스 상태  
다양한 프로세스들이 **번갈아 가면서 실행**되기 때문에  
프로세스는 여러 상태를 반복하며 실행된다.  
  
### 1. 생성 상태  
프로세스를 생성 중인 상태  
이제 막 PCB를 할당 받은 상태  
  
### 2. 준비 상태  
당장 CPU 할당만 받으면 실행할 수 있는 상태  
아직 차례가 오지 않아서 준비만 하고 있음  
  
### 3. 실행 상태  
CPU를 할당받아 실행 중인 상태  
일정 시간동안만 CPU를 사용할 수 있다  

> 준비 상태 -> 실행 상태  
> 전환되는 것을 **디스패치(dispatch)** 라고 한다  
  
실행 도중 입출력장치 인터럽트가 발생하면,  
인터럽트 서비스 루틴이 끝날 때 까지 대기해야 한다  
  
### 4. 대기 상태  
입출력 인터럽트 발생 시  
프로세스가 입출력장치 작업을 기다리는 상태  
  
> 참고로,  
> 입출력 인터럽트 말고도 여러 이유로 대기 상태가 될 수 있지만  
> 대부분 입출력 인터럽트 때문에 대기상태로 전환되므로  
> 간단히 입출력 인터럽트 발생 시 라고 설명했다  
  
### 5. 종료 상태  
프로세스가 종료되는 상태  
운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다  

<br><br>  

### 프로세스 상태 다이어그램  
![image](https://user-images.githubusercontent.com/101965836/222345722-557364f8-cf55-4ea3-a3d7-625457c62312.png)  
    
<br><br>  

### 프로세스 계층 구조  
**부모** 프로세스, **자식** 프로세스  
  
최초의 프로세스가 딱 실행되고  
그 프로세스가 또 다른 프로세스를 실행하는 식으로  
프로세스가 프로세스를 낳는 계층적 구조를 이룬다.  
  
![image](https://user-images.githubusercontent.com/101965836/222346423-aacfcf8b-e2cf-450c-bd51-326476362c9d.png)  
  
<br><br>  
  
### 프로세스 생성 기법  
  
**복제**와 **옷 갈아입기**를 통해 실행된다    
  
- fork : 부모 프로세스가, 자식 프로세스를 생성할 때, 자신의 복사본을 만들어내는 작업  
- exec : 만들어진 복사본을 자신의 메모리 공간에 다른 프로그램으로 교체한다  
  
fork와 exec는 시스템 호출이다.  
시스템 호출로 복사해서 자식 프로세스로 생성한다  
  
> fork와 exec로 자식 프로세스를 계속 생성해내는데  
> 구체적으로 어떻게 메모리 공간이 생기고  
> PID와 PPID(Parent PID)가 어떻게 되는지에 대한 깊은 내용이 있다.  
> 책에 별도로 심화된 내용이 있지만,  
> 일단 이정도만 알고 넘어가자  
  
<br><br><br>  
  
## 10-3 스레드  
  
### 스레드 정의  
> - [MDN 정의](https://developer.mozilla.org/en-US/docs/Glossary/Thread)  
> Thread in computer science is the execution of running multiple tasks or programs at the same time.      
> 컴퓨터 과학에서 스레드는 다중 작업이나 프로그램을 동시에 진행하는 실행을 말한다.    
  
- 책의 스레드 정의  
실행의 단위. 프로세스를 구성하는 실행 흐름 단위.   
하나의 프로세스는 여러 개의 스레드를 가질 수 있다.  
하나의 프로세스에서 여러 부분을 동시에 실행할 수 있습니다.  
  
<br><br>  
  
### 프로세스와 스레드  
먼저,  
**프로세스**는 **여러 개의 스레드**를 가질 수 있다  
  
그럼.  
다중 프로세스와 다중 스레드는 무슨 차이인가?  
[20230110_스프링입문을위한자바객체지향의원리와이해.md - 멀티 스레드 / 멀티 프로세스](https://github.com/PhysicksKim/TIL/blob/main/Books/20230110_%EC%8A%A4%ED%94%84%EB%A7%81%EC%9E%85%EB%AC%B8%EC%9D%84%EC%9C%84%ED%95%9C%EC%9E%90%EB%B0%94%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98%EC%9B%90%EB%A6%AC%EC%99%80%EC%9D%B4%ED%95%B4.md#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C--%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)   

### 멀티 스레드  
![image](https://user-images.githubusercontent.com/101965836/223449503-c48bece3-137e-4802-bd99-50026c9e7c62.png)

### 멀티 프로세스  
![image](https://user-images.githubusercontent.com/101965836/223449516-1def8de9-61d7-4035-9929-9866a5d0b2bf.png)
  
**멀티 스레드**는 **하나의 T 메모리**에서 동시에 코드를 실행하는 거고   
**멀티 프로세스**는 **여러 T 메모리**에서 동시에 코드를 실행하는 것이다.   
  
<br>
  
### 멀티 스레드 / 멀티 프로세스 장단점  
멀티 스레드에서 자원을 공유한다는 점이 장점이자 단점이 된다.  
  
자원을 공유하므로    
같은 값을 여러 스레드가 이용할 수 있어서 같은 자원으로 여러 작업을 할 수 있다.   
  
하지만 단점으로   
같은 값을 여러 스레드가 수정할 수 있으므로, 예상과 다른 값이 튀어나올 수 있다.      
  
<br><br><br>    
  
---

---

<br><br><br>  
  
# CH 11 CPU 스케줄링  
  
## 11-1 CPU 스케줄링 개요  
  
CPU 스케줄링 : 운영체제가 여러 프로세스에 CPU 자원을 배분하는 것을 말한다.  
  
### 프로세스 우선순위  
  



