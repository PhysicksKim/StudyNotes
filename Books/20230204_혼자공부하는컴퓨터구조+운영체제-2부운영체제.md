# CH 09 운영체제 시작하기 

## 9-1 운영체제 알아야 하는 이유  
    
- 시스템 자원 : 프로그램 실행에 필요한 요소 (=자원)     
ex. CPU 메모리 보조기억장치 같은 컴퓨터 부품들 모두 다 해당  
  
- 운영체제 : 필요한 자원을 할당하고, 올바르게 실행되도록 돕는 프로그램   

### 커널 영역  
운영체제도 메모리에 적재되지만  
운영체제는 특별한 프로그램이므로  
메모리에서 **"커널 영역"** 이라는 특별한 곳에서 실행된다  
  
### 사용자 영역  
응용 프로그램이 적재되는 영역을 **사용자 영역** 이라고 한다  
  
### 운영체제가 메모리 관리  
운영체제가 프로그램을 메모리에 적재, 삭제, 재배치 한다    
    
따라서, **운영체제가 중요한 이유**   
메모리 자원을 잘 관리하는 게 중요하기 때문이다.    
  
### CPU 할당  
운영체제는 메모리 관리 뿐만 아니라   
프로그램별 CPU 자원 할당도 담당한다.   
따라서 CPU 할당 문제 또한 중요한다.   
    
예를 들어  
CPU가 입출력장치 같이 느린 장치의 응답만 대기하고 있다면    
자원 낭비가 될 수 있다.  
  
따라서, **운영체제가 중요한 이유**  
CPU 스케쥴링 등을 효율적으로 처리하는 것도 중요하기 때문이다.  
  
<br>  
  
### 개발자에게 운영체제 중요한 이유  
하드웨어를 직접 다루는 임베디드 개발자라면 당연히 운영체제 지식이 중요하다.   
  
그러면, **웹 개발자**에게 운영체제는??   
사용의 측면에서 중요한 게 아니라,  
이해를 위한 기초 지식 측면에서 중요하다.  
  
예를 들어   
무작정 Arrays.sort() 를 사용하는 사람과  
자료 구조를 이해하고 sort()를 사용하면 어떤 알고리즘과 시간 복잡도로 메서드가 돌아가는지 아는 사람은  
코드를 왜 그렇게 써야하는지 이해하는 정도가 다르다.  
  
기초 지식 없이 무작정 Arrays.sort()만 쓰는 사람은  
Counting Sort가 갑자기 소스코드에 등장했을때  
왜 그런지 설명해도 기초지식이 없어서 이해할 수 없다.  
  
마찬가지로  
운영체제도 잘 이해하기 위해서 필요하다.  
직접 운영체제에게 메모리 할당을 어떻게 해라 라고 명령할 일은 거의 없겠지만  
"이렇게 하면 GC가 효율적으로 동작합니다" 라는 내용이 있을 때  
GC를 이해하기 위한 운영체제 지식이 필요하다.    
    
추가로,   
에러 메세지에 따라 어떤 문제인지 추측할 때도 중요하다    
예를 들어    
운영체제가 "이거 커널에서 문제났어" 라고 에러 메세지를 띄울 때      
운영체제를 모른다면 "헉. 나 커널 모르는데" 라고 공포감이 들 수 있다.     
하지만, 커널이 뭔지 알고 어떻게 동작하는지 안다면 당황하지 않고 어떻게 에러에 접근해야 할 지 알 수 있다.  
  
따라서  
직접 운영체제를 다루지 않더라도,   
개발자라면 운영체제에 대한 지식은 기초로 갖추고 있어야 도움이 된다    
더 좋은 코드, 적절한 에러 대응에 운영체제 지식이 필요하다     
  
<br><br><br>  

## 9-2 운영체제의 큰 그림  
  
**커널** 이 매우 중요하다  
**이중모드**, **시스템 호출** 개념을 알아보자  
  
### 운영체제의 심장, 커널  
커널을 어떻게 사용하는지에 따라서   
프로그램이 하드웨어를 이용하는 양상이 달라지고,   
컴퓨터 전체 성능도 달라진다.   
   
운영체제를 지칭할 때는, 커널을 지칭한다고 봐도 무방한다.   
   
### 사용자 인터페이스  
사용자가 운영체제와 상호작용 할 수 있는 통로  
  
- 그래픽 유저 인터페이스  
- 커맨드 라인 인터페이스  
  
<br>  
  
### 이중 모드와 시스템 호출  
  
응용 프로그램들이 **하드웨어 자원에 접근**하려고 할 때  
무조건 운영체제를 거쳐야 한다  
   
- **이중 모드** : CPU 명령어 실행 모드를 **사용자 모드**와 **커널 모드**로 구분하는 방식   

1. 사용자 모드 : 커널 영역의 코드를 실행할 수 없는 모드   
CPU는 하드웨어 자원에 접근하는 명령어를 실행할 수 없다    
2. 커널 모드 : 운영체제 서비스를 제공받을 수 있는 모드   
  
> 슈퍼바이저 플래그 레지스터를 보고 커널 모드인지 사용자 모드인지 구분한다  
   
사용자 모드로 실행되는 프로그램이  
운영체제 서비스를 제공받으려면  
**시스템 호출(System Call)** 을 요청한다  
  
시스템 호출은 일종의 인터럽트이며  
CPU가 시스템 호출을 처리하는 순서 또한 인터럽트 처리 순서와 유사하다  
  
<br>

### 운영체제의 핵심 서비스  

### 1. 프로세스 관리
- 프로세스 : 실행 중인 프로그램을 말한다  
  
하나의 CPU 코어는 한 번에 하나의 프로세스만 실행할 수 있다  
따라서 CPU는 프로세스를 번갈아 가면서 실행해야 한다.  
  
그치만 프로세스들은 제각각 상태, 사용하는 자원 들이 다양하고  
당장에 진행이 불가능한 프로세스도 있다  
  
따라서 운영체제는 다양한 프로세스들이 균형잡히게 또는 급한 프로세스를 빨리 처리하는 식으로  
프로세스를 관리하면서 실행할 수 있어야 한다  
  
이에 대해 10장에서 알아본다  

<br>  
  
### 2. 자원 접근 및 할당  
운영체제가 각 자원들을 어떻게 관리하고, 어떤 기능을 제공할까?   
  
- CPU : 해당 프로세스가 얼마나 CPU를 오래 사용할지 결정 -> **CPU 스케쥴링** (11장)  
- 메모리 : 어떻게 메모리에 프로세스를 적재하고, 메모리 부족시 어떻게 대처할지 -> **메모리 관리** (14장)  
- 입출력장치 : 입출력 인터럽트 발생시 어떻게 서비스 루틴을 실행하는가 -> 인터럽트 서비스 루틴

<br>

### 3. 파일 시스템 관리
보조기억장치 속 데이터를 어떻게 파일과 디렉토리로 관리하는지 (15장) 

<br><br><br>    
  
---

---

<br><br><br>  

# CH 10 프로세스와 스레드  
  
### 프로세스 
- 포그라운드 프로세스 : 사용자가 보는 앞에서 실행되는 프로세스    
- 백그라운드 프로세스 : 사용자가 보지 못하는 뒤에서 실행되는 프로세스  
유닉스 = **데몬** | 윈도우 = **서비스** 
  
### 프로세스 제어 블록  
운영체제는 빠르게 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분한다   
이를 위해서  
운영체제는 **프로세스 제어 블록(PCB)** 을 이용한다  
  
![image](https://user-images.githubusercontent.com/101965836/221890767-30de3723-ee7c-460d-9f61-1267dfed0cd4.png)  
- 각 프로세스는 식별을 위한 PCB를 각자 달고있다.   
- PCB는 커널 영역에 생성된다  
- 운영체제는 PCB로 특정 프로세스를 식별하고, 프로세스 처리에 필요한 정보를 판단한다.  
  
### PCB에 담기는 정보  

- 프로세스 ID (**PID**) : 프로세스를 식별하기 위한 고유 번호   
- 레지스터 값 : 프로세스 실행에 사용하는 프로그램 카운터를 비롯한 레지스터 값    
- 프로세스 상태 : 프로세스가 어떤 상태인지도 PCB에 기록 (ex. 입출력 대기상태, cpu 대기상태, cpu 이용중)    
- CPU 스케쥴링 정보 : 프로세스가 언제 어떤 순서로 CPU에 할당받을지  
- 메모리 관리 정보 : 메모리에 저장된 위치. 페이지 테이블 정보, 베이스 레지스터, 한계 레지스터 같은 프로세스 실행을 위한 메모리 관련 값들이 담긴다.  
- 사용한 파일과 입출력 장치 목록    
  
### 문맥 교환 (Context Switching)
다른 프로세스로 실행 순서가 넘어가면   
이전까지 실행중이던 프로세스의 각종 정보들을 따로 백업해둬야 한다  
여기서  
이전에 실행하던 정보들을 **"문맥"** 이라고 하며  
**문맥 교환** 은 이렇게 프로세스가 전환될 때, 다른 프로세스의 문맥으로 전환하는 것을 말한다.  
  
<br>

### 프로세스의 메모리 영역  
메모리의 사용자 영역에는 프로세스가 어떻게 적재될까?    
  
크게 아래와 같이 나뉘어서 메모리에 적재된다    
  
1. 코드 영역  
2. 데이터 영역  
3. 힙 영역  
4. 스택 영역  
  
이렇게 나뉜다.  
  
### 1. 코드 영역  
Code Segment (= Text Segment) 라고 부른다  
  
기계어 명령어가 코드 영역에 저장되며  
CPU가 실행할 명령어가 담기므로 **읽기 전용** 공간이다  
  
### 2. 데이터 영역  
프로그램이 실행되는 동안 유지 할 데이터가 저장되는 공간이다.  
ex. 전역 변수  
  
> 코드 영역과 데이터 영역은 크기가 변하지 않는다  
> 따라서 '크기가 고정된 영역' 이라는 뜻으로, **정적 할당 영역** 이라고도 부른다  
> 반대로 **힙 영역, 스택 영역** 은 크기가 변하므로 **동적 할당 영역** 이라고 부른다  
  
### 3. 힙 영역  
프로그래머가 직접 할당할 수 있는 저장 공간이다.  
예를 들어 자바 같은 경우 new Object() 같이 오브젝트를 만든다 하면 힙 영역에 데이터가 저장된다  
  
> 그런데 프로그래머가 직접 할당하는 공간이다 보니까  
> 더 이상 쓰지 않는데도 데이터를 남겨두는 실수를 하기도 하는데  
> 이로 인해 무의미한 정보가 메모리에 남게되는 **"메모리 누수"** 가 발생한다.  
  
### 4. 스택 영역  
데이터를 일시적으로 저장하는 공간이다.  
잠깐 쓰다가 마는 지역 변수, 매개 변수들이 저장되는 공간이다.  
  
<br><br>  
  
### 동적 영역의 주소 할당 방향  
![image](https://user-images.githubusercontent.com/101965836/222139311-8a0a7a4c-b759-401e-9839-c5a6b33fb6dc.png)  
[이미지 출처](https://velog.io/@yeahg_dev/TIL11.-C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)  
  
동적 할당 영역(스택, 힙 영역)은 크기가 변하기 때문에  
위 그림처럼,   
스택은 높은 주소 -> 낮은 주소 순으로 할당하고  
힙은 낮은 주소 -> 높은 주소 순으로 할당하도록 한다.  
  
이렇게 해서 메모리가 다 차지 않는 이상은  
가로막혀 할당된 주소가 불연속적이게 되지 않도록 한다.  
  
<br><br><br>  
  
## 10-2 프로세스 상태와 계층 구조  
  

