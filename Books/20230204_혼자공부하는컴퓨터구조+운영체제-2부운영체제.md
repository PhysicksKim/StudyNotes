# CH 09 운영체제 시작하기 

## 9-1 운영체제 알아야 하는 이유  
    
- 시스템 자원 : 프로그램 실행에 필요한 요소 (=자원)     
ex. CPU 메모리 보조기억장치 같은 컴퓨터 부품들 모두 다 해당  
  
- 운영체제 : 필요한 자원을 할당하고, 올바르게 실행되도록 돕는 프로그램   

### 커널 영역  
운영체제도 메모리에 적재되지만  
운영체제는 특별한 프로그램이므로  
메모리에서 **"커널 영역"** 이라는 특별한 곳에서 실행된다  
  
### 사용자 영역  
응용 프로그램이 적재되는 영역을 **사용자 영역** 이라고 한다  
  
### 운영체제가 메모리 관리  
운영체제가 프로그램을 메모리에 적재, 삭제, 재배치 한다    
    
따라서, **운영체제가 중요한 이유**   
메모리 자원을 잘 관리하는 게 중요하기 때문이다.    
  
### CPU 할당  
운영체제는 메모리 관리 뿐만 아니라   
프로그램별 CPU 자원 할당도 담당한다.   
따라서 CPU 할당 문제 또한 중요한다.   
    
예를 들어  
CPU가 입출력장치 같이 느린 장치의 응답만 대기하고 있다면    
자원 낭비가 될 수 있다.  
  
따라서, **운영체제가 중요한 이유**  
CPU 스케쥴링 등을 효율적으로 처리하는 것도 중요하기 때문이다.  
  
<br>  
  
### 개발자에게 운영체제 중요한 이유  
하드웨어를 직접 다루는 임베디드 개발자라면 당연히 운영체제 지식이 중요하다.   
  
그러면, **웹 개발자**에게 운영체제는??   
사용의 측면에서 중요한 게 아니라,  
이해를 위한 기초 지식 측면에서 중요하다.  
  
예를 들어   
무작정 Arrays.sort() 를 사용하는 사람과  
자료 구조를 이해하고 sort()를 사용하면 어떤 알고리즘과 시간 복잡도로 메서드가 돌아가는지 아는 사람은  
코드를 왜 그렇게 써야하는지 이해하는 정도가 다르다.  
  
기초 지식 없이 무작정 Arrays.sort()만 쓰는 사람은  
Counting Sort가 갑자기 소스코드에 등장했을때  
왜 그런지 설명해도 기초지식이 없어서 이해할 수 없다.  
  
마찬가지로  
운영체제도 잘 이해하기 위해서 필요하다.  
직접 운영체제에게 메모리 할당을 어떻게 해라 라고 명령할 일은 거의 없겠지만  
"이렇게 하면 GC가 효율적으로 동작합니다" 라는 내용이 있을 때  
GC를 이해하기 위한 운영체제 지식이 필요하다.    
    
추가로,   
에러 메세지에 따라 어떤 문제인지 추측할 때도 중요하다    
예를 들어    
운영체제가 "이거 커널에서 문제났어" 라고 에러 메세지를 띄울 때      
운영체제를 모른다면 "헉. 나 커널 모르는데" 라고 공포감이 들 수 있다.     
하지만, 커널이 뭔지 알고 어떻게 동작하는지 안다면 당황하지 않고 어떻게 에러에 접근해야 할 지 알 수 있다.  
  
따라서  
직접 운영체제를 다루지 않더라도,   
개발자라면 운영체제에 대한 지식은 기초로 갖추고 있어야 도움이 된다    
더 좋은 코드, 적절한 에러 대응에 운영체제 지식이 필요하다     
  
<br><br><br>  

## 9-2 운영체제의 큰 그림  
  
**커널** 이 매우 중요하다  
**이중모드**, **시스템 호출** 개념을 알아보자  
  
### 운영체제의 심장, 커널  
커널을 어떻게 사용하는지에 따라서   
프로그램이 하드웨어를 이용하는 양상이 달라지고,   
컴퓨터 전체 성능도 달라진다.   
   
운영체제를 지칭할 때는, 커널을 지칭한다고 봐도 무방한다.   
   
### 사용자 인터페이스  
사용자가 운영체제와 상호작용 할 수 있는 통로  
  
- 그래픽 유저 인터페이스  
- 커맨드 라인 인터페이스  
  
<br>  
  
### 이중 모드와 시스템 호출  
  
응용 프로그램들이 **하드웨어 자원에 접근**하려고 할 때  
무조건 운영체제를 거쳐야 한다  
   
- **이중 모드** : CPU 명령어 실행 모드를 **사용자 모드**와 **커널 모드**로 구분하는 방식   

1. 사용자 모드 : 커널 영역의 코드를 실행할 수 없는 모드   
CPU는 하드웨어 자원에 접근하는 명령어를 실행할 수 없다    
2. 커널 모드 : 운영체제 서비스를 제공받을 수 있는 모드   
  
> 슈퍼바이저 플래그 레지스터를 보고 커널 모드인지 사용자 모드인지 구분한다  
   
사용자 모드로 실행되는 프로그램이  
운영체제 서비스를 제공받으려면  
**시스템 호출(System Call)** 을 요청한다  
  
시스템 호출은 일종의 인터럽트이며  
CPU가 시스템 호출을 처리하는 순서 또한 인터럽트 처리 순서와 유사하다  
  
<br>

### 운영체제의 핵심 서비스  

### 1. 프로세스 관리
- 프로세스 : 실행 중인 프로그램을 말한다  
  
하나의 CPU 코어는 한 번에 하나의 프로세스만 실행할 수 있다  
따라서 CPU는 프로세스를 번갈아 가면서 실행해야 한다.  
  
그치만 프로세스들은 제각각 상태, 사용하는 자원 들이 다양하고  
당장에 진행이 불가능한 프로세스도 있다  
  
따라서 운영체제는 다양한 프로세스들이 균형잡히게 또는 급한 프로세스를 빨리 처리하는 식으로  
프로세스를 관리하면서 실행할 수 있어야 한다  
  
이에 대해 10장에서 알아본다  

<br>  
  
### 2. 자원 접근 및 할당  
운영체제가 각 자원들을 어떻게 관리하고, 어떤 기능을 제공할까?   
  
- CPU : 해당 프로세스가 얼마나 CPU를 오래 사용할지 결정 -> **CPU 스케쥴링** (11장)  
- 메모리 : 어떻게 메모리에 프로세스를 적재하고, 메모리 부족시 어떻게 대처할지 -> **메모리 관리** (14장)  
- 입출력장치 : 입출력 인터럽트 발생시 어떻게 서비스 루틴을 실행하는가 -> 인터럽트 서비스 루틴

<br>

### 3. 파일 시스템 관리
보조기억장치 속 데이터를 어떻게 파일과 디렉토리로 관리하는지 (15장) 

<br><br><br>    
  
---

---

<br><br><br>  

# CH 10 프로세스와 스레드  
  
### 프로세스 
- 포그라운드 프로세스 : 사용자가 보는 앞에서 실행되는 프로세스    
- 백그라운드 프로세스 : 사용자가 보지 못하는 뒤에서 실행되는 프로세스  
유닉스 = **데몬** | 윈도우 = **서비스** 
  
### 프로세스 제어 블록  
운영체제는 빠르게 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분한다   
이를 위해서  
운영체제는 **프로세스 제어 블록(PCB)** 을 이용한다  
  
![image](https://user-images.githubusercontent.com/101965836/221890767-30de3723-ee7c-460d-9f61-1267dfed0cd4.png)  
- 각 프로세스는 식별을 위한 PCB를 각자 달고있다.   
- PCB는 커널 영역에 생성된다  
- 운영체제는 PCB로 특정 프로세스를 식별하고, 프로세스 처리에 필요한 정보를 판단한다.  
  
### PCB에 담기는 정보  

- 프로세스 ID (**PID**) : 프로세스를 식별하기 위한 고유 번호   
- 레지스터 값 : 프로세스 실행에 사용하는 프로그램 카운터를 비롯한 레지스터 값    
- 프로세스 상태 : 프로세스가 어떤 상태인지도 PCB에 기록 (ex. 입출력 대기상태, cpu 대기상태, cpu 이용중)    
- CPU 스케쥴링 정보 : 프로세스가 언제 어떤 순서로 CPU에 할당받을지  
- 메모리 관리 정보 : 메모리에 저장된 위치. 페이지 테이블 정보, 베이스 레지스터, 한계 레지스터 같은 프로세스 실행을 위한 메모리 관련 값들이 담긴다.  
- 사용한 파일과 입출력 장치 목록    
  
### 문맥 교환 (Context Switching)
다른 프로세스로 실행 순서가 넘어가면   
이전까지 실행중이던 프로세스의 각종 정보들을 따로 백업해둬야 한다  
여기서  
이전에 실행하던 정보들을 **"문맥"** 이라고 하며  
**문맥 교환** 은 이렇게 프로세스가 전환될 때, 다른 프로세스의 문맥으로 전환하는 것을 말한다.  
  
<br>

### 프로세스의 메모리 영역  
메모리의 사용자 영역에는 프로세스가 어떻게 적재될까?    
  
크게 아래와 같이 나뉘어서 메모리에 적재된다    
  
1. 코드 영역  
2. 데이터 영역  
3. 힙 영역  
4. 스택 영역  
  
이렇게 나뉜다.  
  
### 1. 코드 영역  
Code Segment (= Text Segment) 라고 부른다  
  
기계어 명령어가 코드 영역에 저장되며  
CPU가 실행할 명령어가 담기므로 **읽기 전용** 공간이다  
  
### 2. 데이터 영역  
프로그램이 실행되는 동안 유지 할 데이터가 저장되는 공간이다.  
ex. 전역 변수  
  
> 코드 영역과 데이터 영역은 크기가 변하지 않는다  
> 따라서 '크기가 고정된 영역' 이라는 뜻으로, **정적 할당 영역** 이라고도 부른다  
> 반대로 **힙 영역, 스택 영역** 은 크기가 변하므로 **동적 할당 영역** 이라고 부른다  
  
### 3. 힙 영역  
프로그래머가 직접 할당할 수 있는 저장 공간이다.  
예를 들어 자바 같은 경우 new Object() 같이 오브젝트를 만든다 하면 힙 영역에 데이터가 저장된다  
  
> 그런데 프로그래머가 직접 할당하는 공간이다 보니까  
> 더 이상 쓰지 않는데도 데이터를 남겨두는 실수를 하기도 하는데  
> 이로 인해 무의미한 정보가 메모리에 남게되는 **"메모리 누수"** 가 발생한다.  
  
### 4. 스택 영역  
데이터를 일시적으로 저장하는 공간이다.  
잠깐 쓰다가 마는 지역 변수, 매개 변수들이 저장되는 공간이다.  
  
<br><br>  
  
### 동적 영역의 주소 할당 방향  
![image](https://user-images.githubusercontent.com/101965836/222139311-8a0a7a4c-b759-401e-9839-c5a6b33fb6dc.png)  
[이미지 출처](https://velog.io/@yeahg_dev/TIL11.-C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)  
  
동적 할당 영역(스택, 힙 영역)은 크기가 변하기 때문에  
위 그림처럼,   
스택은 높은 주소 -> 낮은 주소 순으로 할당하고  
힙은 낮은 주소 -> 높은 주소 순으로 할당하도록 한다.  
  
이렇게 해서 메모리가 다 차지 않는 이상은  
가로막혀 할당된 주소가 불연속적이게 되지 않도록 한다.  
  
<br><br><br>  
  
## 10-2 프로세스 상태와 계층 구조  
  
### 프로세스 상태  
다양한 프로세스들이 **번갈아 가면서 실행**되기 때문에  
프로세스는 여러 상태를 반복하며 실행된다.  
  
### 1. 생성 상태  
프로세스를 생성 중인 상태  
이제 막 PCB를 할당 받은 상태  
  
### 2. 준비 상태  
당장 CPU 할당만 받으면 실행할 수 있는 상태  
아직 차례가 오지 않아서 준비만 하고 있음  
  
### 3. 실행 상태  
CPU를 할당받아 실행 중인 상태  
일정 시간동안만 CPU를 사용할 수 있다  

> 준비 상태 -> 실행 상태  
> 전환되는 것을 **디스패치(dispatch)** 라고 한다  
  
실행 도중 입출력장치 인터럽트가 발생하면,  
인터럽트 서비스 루틴이 끝날 때 까지 대기해야 한다  
  
### 4. 대기 상태  
입출력 인터럽트 발생 시  
프로세스가 입출력장치 작업을 기다리는 상태  
  
> 참고로,  
> 입출력 인터럽트 말고도 여러 이유로 대기 상태가 될 수 있지만  
> 대부분 입출력 인터럽트 때문에 대기상태로 전환되므로  
> 간단히 입출력 인터럽트 발생 시 라고 설명했다  
  
### 5. 종료 상태  
프로세스가 종료되는 상태  
운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다  

<br><br>  

### 프로세스 상태 다이어그램  
![image](https://user-images.githubusercontent.com/101965836/222345722-557364f8-cf55-4ea3-a3d7-625457c62312.png)  
    
<br><br>  

### 프로세스 계층 구조  
**부모** 프로세스, **자식** 프로세스  
  
최초의 프로세스가 딱 실행되고  
그 프로세스가 또 다른 프로세스를 실행하는 식으로  
프로세스가 프로세스를 낳는 계층적 구조를 이룬다.  
  
![image](https://user-images.githubusercontent.com/101965836/222346423-aacfcf8b-e2cf-450c-bd51-326476362c9d.png)  
  
<br><br>  
  
### 프로세스 생성 기법  
  
**복제**와 **옷 갈아입기**를 통해 실행된다    
  
- fork : 부모 프로세스가, 자식 프로세스를 생성할 때, 자신의 복사본을 만들어내는 작업  
- exec : 만들어진 복사본을 자신의 메모리 공간에 다른 프로그램으로 교체한다  
  
fork와 exec는 시스템 호출이다.  
시스템 호출로 복사해서 자식 프로세스로 생성한다  
  
> fork와 exec로 자식 프로세스를 계속 생성해내는데  
> 구체적으로 어떻게 메모리 공간이 생기고  
> PID와 PPID(Parent PID)가 어떻게 되는지에 대한 깊은 내용이 있다.  
> 책에 별도로 심화된 내용이 있지만,  
> 일단 이정도만 알고 넘어가자  
  
<br><br><br>  
  
## 10-3 스레드  
  
### 스레드 정의  
> - [MDN 정의](https://developer.mozilla.org/en-US/docs/Glossary/Thread)  
> Thread in computer science is the execution of running multiple tasks or programs at the same time.      
> 컴퓨터 과학에서 스레드는 다중 작업이나 프로그램을 동시에 진행하는 실행을 말한다.    
  
- 책의 스레드 정의  
실행의 단위. 프로세스를 구성하는 실행 흐름 단위.   
하나의 프로세스는 여러 개의 스레드를 가질 수 있다.  
하나의 프로세스에서 여러 부분을 동시에 실행할 수 있습니다.  
  
<br><br>  
  
### 프로세스와 스레드  
먼저,  
**프로세스**는 **여러 개의 스레드**를 가질 수 있다  
  
그럼.  
다중 프로세스와 다중 스레드는 무슨 차이인가?  
[20230110_스프링입문을위한자바객체지향의원리와이해.md - 멀티 스레드 / 멀티 프로세스](https://github.com/PhysicksKim/TIL/blob/main/Books/20230110_%EC%8A%A4%ED%94%84%EB%A7%81%EC%9E%85%EB%AC%B8%EC%9D%84%EC%9C%84%ED%95%9C%EC%9E%90%EB%B0%94%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98%EC%9B%90%EB%A6%AC%EC%99%80%EC%9D%B4%ED%95%B4.md#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C--%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)   

### 멀티 스레드  
![image](https://user-images.githubusercontent.com/101965836/223449503-c48bece3-137e-4802-bd99-50026c9e7c62.png)

### 멀티 프로세스  
![image](https://user-images.githubusercontent.com/101965836/223449516-1def8de9-61d7-4035-9929-9866a5d0b2bf.png)
  
**멀티 스레드**는 **하나의 T 메모리**에서 동시에 코드를 실행하는 거고   
**멀티 프로세스**는 **여러 T 메모리**에서 동시에 코드를 실행하는 것이다.   
  
<br>
  
### 멀티 스레드 / 멀티 프로세스 장단점  
멀티 스레드에서 자원을 공유한다는 점이 장점이자 단점이 된다.  
  
자원을 공유하므로    
같은 값을 여러 스레드가 이용할 수 있어서 같은 자원으로 여러 작업을 할 수 있다.   
  
하지만 단점으로   
같은 값을 여러 스레드가 수정할 수 있으므로, 예상과 다른 값이 튀어나올 수 있다.      
  
<br><br><br>    
  
---

---

<br><br><br>  
  
# CH 11 CPU 스케줄링  
  
## 11-1 CPU 스케줄링 개요  
  
CPU 스케줄링 : 운영체제가 여러 프로세스에 CPU 자원을 배분하는 것을 말한다.  
  
### 입출력 vs CPU 집중
  
프로세스마다, CPU를 많이 쓰는지 입출력 작업이 많은지 다르다.  
  
- 입출력 집중 프로세스 : 입출력장치 자주 사용  
- CPU 집중 프로세스 : CPU 자주 사용  
  
그러면   
입출력 vs CPU  
당연히 같은 시간만큼 처리하면 안된다.  
  
따라서  
운영체제가 적절한 알고리즘으로   
어떻게 대기중인 프로세스를 관리하고   
어떻게 프로세스에 우선순위를 부여하는지  
"운영체제가 잘" 해줘야 한다.  
  
<br><br>  

### 스케줄링 큐  
운영체제가 대기중인 모든 프로세스의 PCB를 매 번 체크하는건 비효율적이다  
  
그러므로,  
미리 우선 순위에 따라서 적절한 줄에 넣어두는  
스케줄링 큐를 구현한다.  


### 예시 - 대기 상태의 스케줄링 큐 

![image](https://user-images.githubusercontent.com/101965836/223731761-eb9e2233-b3a0-44a9-8614-add17d7f846b.png)  
  
먼저 예시부터 보면  
대기 큐는 위와 같은 모양으로 되어있다.  
   
1. 프린터, CD-ROM, 하드 디스크 등등 대기 큐를 만들어두고, 거기에 집어넣는다.  
2. 대기 큐에 집어넣을 때, 우선순위에 맞춰 집어넣어야 한다   
  
위와 같은 2가지를 고려해서 PCB를 큐에 집어넣게 된다.  
  
### 프로세스 상태 다이어그램    
![image](https://user-images.githubusercontent.com/101965836/223733550-8018cb7e-dfc7-4a99-a2ce-1260067cf387.png)  
   
[앞선 10장의 프로세스 상태 다이어그램](https://github.com/PhysicksKim/TIL/blob/main/Books/20230204_%ED%98%BC%EC%9E%90%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0+%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-2%EB%B6%80%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.md#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8)  
  
위와 같은 프로세스 상태 다이어 그램에서  
준비 상태와 대기 상태에 앞서 본 스케줄링 큐가 있는 것이다.  
  
<br><br>  

### 선점형 vs 비선점형 스케줄링  
  
당장에 어떤 프로세스가  
"나 진짜 급함! 빨리!"  
하면서 먼저 처리하길 요청한다면 어떻게 해야할까?  
  
  <br>  
  
- **선점형** 스케줄링 
이미 어떤 프로세스가 자원을 사용하고 있더라도, 
운영체제가 자원을 강제로 뺏어와서 다른 프로세스에게 할당해줌  
   
   <br>  
   
- **비선점형** 스케줄링  
프로세스가 종료, 대기 상태에 접어들기 전까지는    
다른 프로세스가 끼어들 수 없는 스케줄링 방식   
  
  
### 선점형 장단점  
- 장점  
자원 독점을 막고 골고루 자원을 배분해준다  
  
- 단점  
Context Switching이 자주 일어나서 오버헤드가 발생 
  
### 비선점형 장단점  
- 장점  
Context Switching이 적으므로 오버헤드 적음  

- 단점  
급한 상황에도 앞선 프로세스가 끝날 때 까지 무작정 대기할 수 밖에 없다.  
  
<br><br><br>  

## 11-2 CPU 스케줄링 알고리즘  

### CPU 스케줄링 알고리즘 필요성  
어떤 프로세스를 먼저 처리 할 지 정하는게 중요함  
무작정 우선순위 높은 것만 처리하다가는,  
우선순위 낮은 프로세스는 무한히 대기하는 지옥에 빠질 수 있음  
  
<br> 

## 스케줄링 알고리즘의 종류  

### 요약
1. 선입 선처리 : 준비 큐에 삽입된 순서대로 CPU 할당  
2. 최단 작업 우선 : CPU 사용 시간의 길이가 가장 짧은 프로세스부터 처리  
3. 라운드 로빈 : 정해진 시간만큼 돌아가며 CPU 할당    
4. 우선순위 : 가장 높은 우선순위를 가진 프로세스에 CPU를 할당  
5. 다단계 피드백 큐 : 우선순위에 따른 큐 오래된 프로세스를 더 우선순위 높은 큐로 이동시킴  
  
### 1. 선입 선처리 스케줄링 (First Come First Served ; FCFS)  
준비 큐에 삽입된 순서대로 프로세스를 처리하는 비선점형 스케줄링 방식  

> - 비선점형 (non-preemptive ; 가로채기 불가) : 처리 하던 프로세서를 다 끝내야지만, 다른 프로세서를 처리함  
> - 선점형 (preemptive ; 가로채기 가능) : 처리 도중에 프로세서를 중단하고, 다른 프로세서 처리를 가능함  
   
- 호위효과  
CPU를 **오래 사용하는 프로세스**가 먼저 도착하면   
다른 프로세스는 무작정 처리가 **끝날 때 까지 기다릴 수 밖에** 없다.  
이를 호위효과라 한다.  
  
<br>
  
### 2. 최단 작업 우선 스케줄링 (Shortest Job First ; SJF)
호위효과를 막으려면?     
사용 시간이 **짧은 프로세스를 먼저 실행**하면 된다.  
  
> 기본적으로 비선점형으로 구현되지만, 선점형으로도 구현할 수 있다.  
  
<br>  
  
### 3. 라운드 로빈 스케줄링 (Round Robin)  
**선입 선처리 스케줄링 + 타임 슬라이스 개념**  
  
- 타임 슬라이스  
프로세스가 CPU를 정해진 시간만 사용하고, 끝내지 못하면 스케줄링 큐의 맨 뒤에 삽입됨  
  
**타임 슬라이스 크기가 중요**한데  
지나치게 크기가 **크면**, **호위 효과**가 생길 여지가 있고  
너무 크기가 **작으면**, **문맥교환**으로 인한 **오버헤드**가 커진다  
  
<br>
  
### 4. 최소 잔여 시간 우선 스케줄링 (Shortest Remaining Time ; SRT)  
  
최단 작업 우선 + 라운드 로빈  
  
<br>  

### 5. 우선순위 스케줄링 (Priority)  
가장 높은 우선순위를 가진 프로세스부터 실행하는 방식  
  
- 기아 현상 (Starvation)  
우선 순위가 높은 프로세스부터 계속 처리하려 해서    
우선 순위가 낮은 프로세스는 무한히 대기하는 현상  
  
- 에이징 기법 (Aging)  
오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식  
  
<br>  

### 6. 다단계 큐 스케줄링 (Multilevel Queue)
우선순위 스케줄링 + 여러 개의 준비 큐  
  
큐를 여러 개 두고, 우선순위를 구분하여 실행하는 것  
  
<br>  

### 7. 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue)  
다단계 큐 + 라운드 로빈(타임 슬라이스) + 피드백 개념  
  
- 다단계 큐      
기아 현상 해결 방안으로
우선 순위가 높은 큐로 프로세스를 이동시킬 수 있다.  
  
- 피드백 전략  
앞서 본 "호위 효과" 와 "기아 현상" 을 해결하기 위해서  
프로세스가 우선 순위 큐 사이를 이동할 수 있다  
   
1. CPU를 오래 사용 -> 우선순위 낮춤 -> 호위효과 예방 (오래 걸리는 건 나눠서 처리)  
2. CPU를 적게 사용 -> 우선순위 높임 -> 기아현상 예방 (빨리 처리하고 치움)    
3. 기다린지 오래 됨 -> 우선순위 높임 -> 에이징 기법 적용  
  
<br><br>  
  
### 가장 일반적 -> 다단계 피드백 큐 스케줄링   
구현은 복잡하지만  
에이징, 호위효과 해결, 기아현상 해결 같은 조건들을 다 만족할 수 있기에    
다단계 피드백 큐가 가장 일반적인 CPU 스케줄링 알고리즘이 된다.  
  
<br><br><br>    
  
---  
  
---  
  
<br><br><br>  
  
# CH 12 프로세스 동기화  

## 12-1 동기화란  

### 동기화의 의미  
  
프로세스들의 수행 시기를 맞추는 것.  
  
1. 실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기  
2. 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기  
  
> 프로세스 뿐만 아니라, 스레드도 동기화 대상이다  
> 더 확장해서, 실행 흐름을 갖는 모든 것은 동기화 대상이다.  
  
#### 1. 실행 순서를 위한 동기화  
어떤 데이터 파일이 있고     
Reader 프로세스와 Writer 프로세스가 있을 때  
Writer 가 먼저 이뤄진 후에 Reader 가 실행되어야 한다면  
실행 순서를 꼭 지켜야 한다  
  
#### 2. 상호 배제 (공유 자원 관리)  
공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘  
  
> - 예시  
> 1. {스레드 A} 변수 a를 읽음 a=10
> 2. {스레드 B} 변수 a를 읽음 a=10
> 3. {스레드 A} a = a + 2 , a=12 (10 + 2)
> 4. {스레드 B} a = a + 5 , a=15 (10 + 5)
>    
> 이렇게 되면 a=17 을 예상했지만, a=15라는 결과가 나온다  
  
<br><br>  

### 멀티스레드 문제 : 생산자와 소비자 문제  
  
멀티 스레드에 동시 접근 시 발생하는 문제 중 하나다.  
  
```
공유변수  
int num = 10;
```
```
Thread A : num++;
Thread B : num--;
```
위와 같은 상태에서  
쓰레드 A와 B를 각각 10만번씩 실행하면 어떻게 될까?  
  
+10만 -10만 이니까 그대로 num=10 이어야 겠지만  
실제로 실행해보면 

```
시행 1차 : 63078
시행 2차 : -13750
```
이렇게 된다.  

### 이유 
```
a. num 변수를 가져온다 -> num = 10
b. 가져온 값에 1을 더한다 -> 10+1 = 11
c. num 변수에 저장한다 -> num = 11
```
위와 같이 a b c 3번의 과정을 통해서 명령이 이뤄진다.  
  
그런데 멀티 스레드 환경에서는 실행 순서가 보장되지 않아서  
a부터 여러번 이뤄질 수 있다  
  
예를 들어, thread 1,2,3 3개가 동시에 실행될 때  
아래와 같이 실행될 수 있다.  

```
1-a. num = 10
2-a. num = 10

1-b. 10 + 1 = 11
2-b. 10 + 1 = 11
3-a. num = 10

1-c. num = 11
2-c. num = 11
3-b. 10 + 1 = 11

3-c. num = 11
```
  
```
- 결과  
num = 11
```
thread 3개에 의해서 3번이나 시행됐지만, +3이 된게 아니라 +1밖에 안됐다.  
  
<br>
  
### 공유 자원과 임계 구역  

- 공유 자원(Shared Resource) : 여러 스레드들이 공통으로 접근하는 자원 (변수, 파일, 입출력장치 등)      
- 임계 구역(Critical Section) : **동시**에 실행하면 **문제**가 발생하는 **자원에 접근**하는 **코드 영역**    
- 레이스 컨디션(Race Condition) : **동시에** **임계 구역**의 **코드를 실행**하여 문제가 발생하는 경우    
  
<br>  

### 임계구역 문제를 해결하는 원칙  

1. 상호 배제(Mutual Exclusion) : 임계 구역에는 하나의 프로세스만 접근가능  
2. 진행(Progress) : 어떤 프로세스도 진입하지 않았다면, 진입 가능하다  
3. 유한 대기(Bounded Waiting) : 임계 구역에 들어갈려고 무한정 대기해서는 안 된다  
  
<br><br><br>  
  
## 12-2 동기화 기법  
  
동기화를 위한 도구 3가지  
1. 뮤텍스 락  
2. 세마포  
3. 모니터  
   
<br>
   
### 1. 뮤텍스 락
임계 구역에 하나의 쓰레드만 접근 가능하도록 하기 위한 임계 구역 잠금 방법.     
  
임계 구역에 자물쇠를 만들고,    
잠겨있지 않은 경우에만 진입가능하며,  
작업이 끝나면 잠금을 해제함.  
  
- 구현을 위한 요소   
```
- 자물쇠 역할 변수 : lock
- 임계 구역 잠그기 : acquire()
- 임계 구역 잠금해제 : release()  
```
  
### 2. 
