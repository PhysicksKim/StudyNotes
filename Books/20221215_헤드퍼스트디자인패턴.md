> # 들어가기에 앞서   
> ### 토이프로젝트 하나도 제대로 안 만든 주제에 왜 디자인패턴?  
> 아무리 봐도   
> 지금 내가 너무 구리게 코딩하고있는거 같았다.   
>    
> 게시판 페이징 + 검색 으로 짜는데,   
> 글 목록, 페이지버튼 구성하려면 어떻게 클래스를 둬야할지 막막했다.  
>   
> 일단 지금의 문제가 뭐냐면, 오프셋 페이징을 하려면 쿼리를 두 번 날려야 한다  
>  
> ### 무슨 문제가 있었는가?  
>   
> 먼저 1. 글목록 쿼리 로 10개의 게시글을 얻어온다.  
> 글 목록 얻어오는 쿼리는 문제없다.  
> 문제는 게시판 하단에 있는 1️⃣2️⃣3️⃣ 페이지 버튼을 만들기 위해서   
> 추가로 2. 게시글 count() 쿼리를 또 날려야 한다는 점이 문제다.  
>     
> 페이지 버튼을 만들기 위해서 총 게시글 수를 얻어와야한다.  
> 예를 들어 게시글이 45개면 \[1] \[2] \[3] \[4] \[5] 페이지 까지 버튼이 있어야 한다.  
> 따라서 페이지 버튼이 몇 개 있어야 하는지 계산해야 하므로 총 게시글 수를 알아야 한다.      
> 그래서 2. 게시글 count() 쿼리 로 총 게시글 수를 얻어오고, 페이지 버튼을 어떻게 구성할지 계산해야 한다.  
>    
> 자, 이제 왜 쿼리가 두 번 날아가야 하는지 다 설명했다.  
> 그러면 쿼리가 두 번 날아가는게 왜 문제인가?  
> 그 이유는 바로 **'글 목록과 페이지 버튼 생성 시점이 달라지기 때문'** 이다  
>    
> ### 생성 시점이 달라서 왜 문제인가?  
> 자세히 코드까지 설명할 필요는 없을 것 같고.   
> 대충 한글로 수도코드 작성해보면  
> ```
> 글목록컨트롤러(DTO dto) {
>   // dto가 request로부터 1. 페이지 사이즈 2. 현재 페이지 를 받아옴
>   글목록 = 게시판서비스.글목록얻기(dto)  
>   페이징 = 게시판서비스.페이징얻기(dto)
>   
>   모델에담기(글목록)
>   모델에담기(페이징)
>   
>   return 뷰페이지;
> }
> ```
>   
> 이렇게 되어야 한다.  
> 그러면.  
> 글목록 + 페이징 으로 해서 하나의 클래스로 만들어야 할까?  
> 아니면 글목록이랑 페이징을 따로 두는게 맞을까?  
>    
> ### 지금 생각은, SRP 때문에 따로 두는게 맞다  
> 객체지향 원칙 중 단일 책임 원칙 (SRP: Single Responsibility Principle) 을 생각하면  
> 글목록과 페이징은 다른 내용이니까  
> 클래스를 따로 두는게 맞는 것 같다.  
>   
> 이 생각은 search 부분을 리펙토링 해보니까 확신이 들었다.    
> ```
> 검색컨트롤러(SearchDTO searchdto, DTO dto) {
>   // dto가 request로부터 1. 페이지 사이즈 2. 현재 페이지 를 받아옴
>   검색글목록 = 게시판서비스.검색글목록얻기(searchdto)  
>   페이징 = 게시판서비스.페이징얻기(dto)
>   
>   모델에담기(검색글목록)
>   모델에담기(페이징)
>   
>   return 뷰페이지;
> }
> ```
> 이렇게 기존 글목록 코드에서 글목록얻기(dto) 대신   
> 검색글목록얻기(searchdto) 로 대체하면 딱 맞아떨어지기에  
> 아마도, 잘 설계된 것 같다.  
> 또 뷰페이지 똑같은 거 그대로 재사용할 수 있고, 검색관련 내용이 있는지 정도만 쫌 뷰페이지에 추가해주면 되기에 잘 설계됐다고 본다.  
> (물론 view도 검색용이랑 글목록용을 분리해도 된다)  
>   
> 하지만 아직도  
> "이거, Page 를 상속해서 searchPage 를 만들어도 될까?"  
> "view 페이지도 분리하는게 맞을까?"  
> 같은 의문들이 너무도 많이 있다.  
>   
> # 그래서 결론은  
> 지금 당장에 뭐가 맞는 설계인가를 고민하고 싶은데,  
> 그걸 고민할 밑천이 기본 객체지향 기본원리(추상화 캡슐화 다형성 상속)랑 SOLID 원칙밖에 없다.  
> 좀 더 실용적이고 실전적인 코드들을 접해본 적이 없어서 답답했다.  
> 그래서.  
> 빨리 디자인 패턴부터 보고싶었다.  
> 그리고 궁극적으로 스프링은 MVC가 핵심인데  
> MVC를 알려면 기본 디자인패턴부터 배워야한다.  
> 그래서 더욱 디자인 패턴을 빨리 배우고 싶었다.   
  
---

# 목차
### [- CH01 전략패턴](https://github.com/PhysicksKim/TIL/blob/main/Books/20221215_%ED%97%A4%EB%93%9C%ED%8D%BC%EC%8A%A4%ED%8A%B8%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4.md#ch01-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4)  

---
  
# CH01 전략패턴
  
## 필요성  
   
![CH01_WhyStreategy](https://user-images.githubusercontent.com/101965836/208663314-f0915c3e-9ebe-457d-84e1-074f3266d861.png)  
  
Duck 이라는 부모 클래스가 있다.  
처음에는 "자연 오리들은 이렇겠지..." 하고 swim() quack() fly() 같은 메서드를 Duck에 넣고, Duck을 상속해서 만들었다  
  
그런데 나중에 보니까   
장난감고무Duck 도 추가되고  
장식용Duck 도 추가되는 것이다.  
  
근데 이런 오리들은 swim() quack() fly() 같은 메서드들이 다 다른방식으로 동작하거나, 아예 동작하지 않아야 한다.  
그치만 오리 전용 그래픽 때문에 Duck.display()를 꼭 써야해서  
Duck을 상속하기는 해야한다고 해보자.  
  
그러면 이렇게 "특정 메서드들에 변경이 잦을 경우" 어떻게 해야할까?  
매 번 오버라이드해서 바꿔줘야할까?  
  
  <br>  
  
## 해결방안 - Strategy pattern (전략 패턴)  
  
![image](https://user-images.githubusercontent.com/101965836/208670067-60c4add1-bfce-41d8-b66d-54092c75d307.png)  
  
자주 바뀌거나, 실행중에 행동이 바뀌는 경우  
위와 같은 전략 패턴을 활용해서 해결할 수 있다  
  
\_\_\_Behavior 라고 따로 인터페이스를 만들어두고  
각 행동별 구현체를 또 만들어 둔다.  
이후 각각의 Duck들이 생성자로 Behavior를 받아서 저장해두고,  
do\_\_\_Behavior() 메서드가 실행되면, 각 behavior에 맞게 행동하도록 짜면 된다.  
  
  
> ### 디자인 원칙 01 
> 달라지는 부분을 찾고, 달라지지 않는 부분과 분리한다.  
>   
> 전략 패턴에서는 달라지는 부분을 behavior로 빼내는 "구성"을 활용했다.  
