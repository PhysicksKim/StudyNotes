# 10. 날짜와 시간 & 형식화  

## 10-1~3 날짜와 시간, Calendar 클래스  

### java.util.Date 
날짜와 시간을 다룰 목적으로 만들어진 클래스 (JDK1.0;1995년)  
근데 Date 메서드는 거의 deprecated이지만, 여전히 쓰이고 있긴 하다  

### java.util.Calendar  
Date 클래스를 개선한 새로운 클래스(JDK1.1;1997년)   
그러나 여전히 단점이 존재  

### java.time패키지  
Date와 Calendar의 단점이었던 날짜와 시간을 같이 다뤄야 하는 단점을 개선해 새로운 클래스들을 제공한다 (JDK1.8)   
이외에도 몇 가지 단점들을 보완했고, 될 수 있으면 time 패키지를 쓰는게 좋다    
하지만 레거시들이 여전히 쓰이고 있으니 Date와 Calendar도 알아둬야 한다   
  
  
### 이걸 왜 배워야 하는가?    
날짜와 시간은 굉장히 중요하다. 실제로 비즈니스 구현에 날짜와 시간은 굉장히 중요하게 다뤄진다. 따라서 날짜와 시간을 어떻게 다뤄야 하는지에 대해서 배워야 한다.  
  
### Calendar 클래스
추상 클래스이므로 getInstance()를 통해 구현된 객체를 얻어야 한다.  
```
Calendar cal = new Calendar(); // 에러! 추상클래스는 인스턴스를 생성할 수 없다
```
```
Calendar cal = Calendar.getInstance(); // OK! getInstance()메서드는 Calendar클래스를 구현한 클래스의 인스턴스를 반환한다.
```

### 예제 
```java
Calendar today = Calendar.getInstance();
// today.get() 안에는 int형으로 숫자를 입력받는다. 1을 주면 YEAR, 2를 주면 MONTH, 3을 주면 WEEK_OF_YEAR을 반환한다.
// 약간 뇌피셜로 Switch CASE 구문으로 CASE 1 CASE 2 같은 식으로 있나보다.  
// 그래서 today.get(1); 이런식으로 할 순 없으니, Calendar 클래스 내부에 static으로 선언된
// Calendar.YEAR 같은 static 상수값을 줘서 값을 갖고온다
System.out.println("올해는... " + today.get(Calendar.YEAR));
System.out.println("오늘이 몇 월이냐면... " + (today.get(Calendar.MONTH)+1));
System.out.println("오늘은 올해의 몇째 주냐면... " + today.get(Calendar.WEEK_OF_YEAR));
```  

## 10-4,5 Calendar 클래스 예제 - set() 메서드 사용

### set()으로 날짜와 시간 지정
```
void set(int field, int value)
void set(int year, int month, int date)
void set(int year, int month, int date, int houfOfDay, int minute)
void set(int year, int month, int date, int hourOfDay, int minute, int second)
```

### 날짜 지정하는 방법
**월(Month)이 0~11** 임에 주의  
```java
Calendar date1 = Calendar.getInstance();
date1.set(2022, 4, 1); // 2022년 5월 1일 (4월이 아니라 5월임)
```
```java
// 이렇게도 가능
date1.set(Calendar.YEAR, 2022);
date1.set(Calendar.MONTH, 4);
date1.set(Calendar.DATE, 1);
```

### 시간 지정하는 방법
시간을 지정하는 방법은 따로 없어서 일일이 해줘야함  
```java
Calendar time1 = Calendar.getInstance();
time1.set(Calendar.HOUR_OF_DAY, 10);
time1.set(Calendar.MINUTE, 20);
time1.set(Calendar.SECOND, 30);
```
### clear() 
옛날에 "이거 날짜를 언제를 기준으로 할건가?" 라는 논의에서    
그냥 "1970-01-01T00:00:00"을 기준으로 하자  
라고 결론지었다.  
그냥 컴퓨터가 나오기 전에 대충 적당한 날짜로 정한 것이다  
그래서 .clear();로 초기화를 하면 1970년 1월 1일 00시 00분 00초로 초기화 된다.  
  
```
Calendar dt = Calendar.getInstance(); // 현재 시간
dt.clear(); // 초기화
System.out.println(new Date(dt.getTimeInMillis(); //
```

한편, clear(int field)를 하면 특정 필드를 초기화 한다.  
예를 들어 clear(Calendar.SECOND) 라고 하면 초를 초기화 하게 된다.  

### clear()의 용도 (예제10-5)  
예를 들어   
두 날짜 값을 인자로 받고, 두 날짜간 며칠 차이인지를 반환하는 메서드를 구현한다 해보자.  
그러면 Calendar 형식으로 2개의 인스턴스를 얻고  
여기다가 .set()해서 인자로 받은 날짜를 대입해서   
두 인스턴스를 .getTimeInMillis()로 빼주고, 다시 일(date) 단위로 변환하면 된다고 생각할 수 있다.  
  
하지만 이렇게 하면 문제가 발생하는데   
아래 코드를 보자  
```
static int getDayDiff(String yyyymmdd1, String yyyymmdd2) {
  ...
  try {
    ... // (인자로 받은 String을 분해해서 int형으로 year, month, day로 변환 
    
    Calendar date1 = Calendar.getInstance();
    Calendar date2 = Calendar.getInstance();
    date1.set(year1, month1, day1);
    date2.set(year2, month2, day2);
    ... // millisecond 단위로 get 해서 두 날짜 빼고 일(date)로 전환
  } catch ...
```

근데 이렇게 하면 date1과 date2가 딱 2일 차이라 하더라도  
1.999999.... 이런식으로 뜬다   
왜냐하면    
date1과 date2 가 생성되는 시간에서 약간의 millisecond 차이가 발생할 수 있기 때문이다  
따라서 이럴 때 아래와 같이 clear를 해주고 set해야 한다.  
```
Calendar date1 = Calendar.getInstance();
Calendar date2 = Calendar.getInstance();
date1.clear();
date2.clear();
date1.set(year1, month1, day1);
date2.set(year2, month2, day2);
```

## 10-6 add와 roll
add와 roll 둘 다 특정 필드의 값을 더해준다  
```
date.add(Calendar.DATE, 1); // 날짜(DATE)에 1을 더한다
date.add(Calendar.MONTH, -8); // 월(MONTH)에 8을 뺀다
```
  
#### 차이점  
add()는 **다른 필드에 영향O**    
roll()은 **다른 필드에 영향X**    
  
```
date.set(2020, 7, 31);

date.roll(Calendar.DATE, 1); // 2020년 7월 1일
date.roll(Calendar.MONTH, -8); // 2020년 1월 31일
```  
  
  
## 10-7 커맨드라인으로 달력 모양으로 출력하는 예제
특별한 내용은 없고, 그냥 필요하면 한 번 그때 보면 좋은 정도다  
대충 달력을 만들 때 어떻게 작성하면 좋을지 약간 노하우 스러운 예제다  

## 10-8 Date와 Calendar간의 변환  
Date의 메서드는 대부분 deprecated 되었지만 여전히 사용하기 때문에 변환 방법 정도는 알아두는 것이 좋다  

### Calendar -> Date
```
Calendar cal = Calendar.getInstance();  
...
Date d = new Date(cal.getTimeINMillis());
```

### Date -> Calendar
```
Date d = new Date();
...
Calendar cal = Calendar.getInstance();
cal.setTime(d);
```

## 10-9 형식화 클래스
#### 형식화 클래스란?  
java.text 패키지에 DecimalFormat, SimpleDateFormat이 있는데  
숫자나 날짜를 원하는 형식으로 쉽게 출력하도록 할 때 사용하는 클래스이다  
  
예를 들면 아래와 같이  
double형 숫자를 지수형으로 바꿔주고 싶으면  
아래와 같이 format을 사용할 수 있다.  
```
double number = 123456.789;
DecimalFormat df = new DecimalFormat("#.#E0");
String result = df.format(number);  // result = "1.2E6"
```
    
반대로 형식화된 숫자나 날짜에서 데이터를 편리하게 정제할 수 있다  
```
DecimalFormat df = new DecimalFormat("#,###.##");
Number num = df.parse("1,234,567,89");
double d = num.doubleValue(); // 1234567.89
```

## 10-10 DecimalFormat
숫자를 형식화할 때 사용한다  
이때 패턴을 어떻게 주는지는 굉장히 다양하다  
```
DecimalFormat df = new DecimalFormat("#.#E0");  
```
패턴에 관한 것은 자주 사용하는 패턴들은 알아두면 좋겠지만  
그냥 상황에 따라서 필요하면 그 때 검색해서 알아봐도 된다  

## 10-11,12 DecimalFormat에 관한 예제
대충 그냥 패턴을 어떻게 쓰는지 알려주는 간단한 예제다  

## 10-13~16 SimpleDateFormat
날짜와 시간을 다양한 형식으로 출력할 수 있게 해준다  
```
Date today = new Date();
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");

String result = df.format(today);
```

반대로 문자열에서 날짜와 시간을 간단히 뽑아낼 수도 있고,  
날짜 문자열을 다른 형식으로 바꾸는 것도 아래 예제와 같이 두 단계를 거치는 식으로 해서 가능하다  
```
DateFormat df = new SimpleDateFormat("yyyy년 MM월 dd일");
DateFormat df2 = new SimpleDateFormat("yyyy/MM/dd");

Date d = df.parse("2015년 11월 23일");
String result = df2. format(d);
```
  
  <br><br><br>
  
  ---
  
  <br><br><br>
  
# 11. 컬렉션 프레임워크  
컬렉션 프레임웍은 객체지향 다음으로 중요한 개념이다  
이 장은 여러번 전체적으로 빠르게 반복해서 보는 게 좋다  
컬렉션 프레임웍 쪽은 분량이 많기 때문에 까먹기 쉬우므로 잘 정리한 다음 반복학습이 중요하다  

## 11-1 컬렉션 프레임워크
#### 컬렉션 collection 
여러 객체(데이터)를 모아 높은 것을 의미   
#### 프레임워크 framework  
표준화, 정형화 된 체계적인 프로그래밍 방식   
특정 프레임웍을 이용해서 프로그램을 짜면 다른 사람이 봐도 그 프레임웍에 따르기 때문에 이해하기가 쉬워지게 된다  
  
#### 그러면 컬렉션 프레임워크은 뭔가?  
컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식을 말하며  
컬렉션을 쉽고 편리하게 다룰 수 있도록 다양한 클래스를 제공한다   
  
많은 데이터를 효율적으로 다룰려면 CRUD를 효율적으로 구현해야 한다  
따라서 JDK1.2부터 다수의 데이터를 다룰 수 있도록 표준화해서 제공한게 컬렉션 프레임웍이다  

#### 컬렉션 클래스
다수의 데이터를 저장할 수 있는 클래스를 말한다 (ex. Vector, ArrayList, HashSet)  
  
## 11-2 컬렉션 프레임워크의 핵심 인터페이스  
1. List   
2. Set   
3. Map   
  
List : 순서가 있음. 중복을 허용.  
ex. 대기자 명단  
  
Set : 순서가 없음. 중복을 허용하지 않음  
ex. 양의 정수 집합, 소수 집합  
  
Map : Key - Value로 이뤄진 데이터 집합. 순서 없음. key는 중복X, Value는 중복O  
ex. 우편번호, 지역번호, Id-Password  
  
여기서 **List와 Set의 공통된 부분** 을 **Collection** 으로 묶는다.  

## 11-3~6 Collection 인터페이스의 메서드, List Set Map 인터페이스의 메서드    
![image](https://user-images.githubusercontent.com/101965836/166133207-d376e76f-24de-4b58-9f0d-15222135f9c4.png)   
이렇게 List와 Set은 공통적으로 Collection으로 묶인다    
Collection에는 구체적으로 아래와 같은 메서드 들이 있는데, 그냥 추가 삭제 검색 정도만 유의해서 보면 된다. 생각보다 그렇게 메서드가 다양하지 않다.   
또 List, Set, Map에도 각각 메서드들이 있는데...   
그냥 일단은 각 챕터마다 어떤 메서드들이 있는지 표를 보여주면서 대략 이런 메서드들이 있다는 것만 알아두고  
뒤에서 하나하나 배워보자  
  
  
## 11-7~11 ArrayList
![image](https://user-images.githubusercontent.com/101965836/166133948-12f7d4ab-ec77-4d12-a9a7-5bce81fb9508.png)  
- 순서O 중복O
- 데이터의 저장공간으로 배열을 사용한다(배열기반)

List 인터페이스는 순서 O 중복 O 이며  
위의 계층도와 같이  
List는 Vector, ArrayList, LinkedList가 있다.  
  
여기서 먼저 ArrayList에 대해서 볼꺼고  
Vector는 ArrayList의 레거시이며 거의 동일하다.   
Vector와 ArrayList 둘의 차이는 Vector는 동기화O ArrayList는 동기화X 이다. (동기화는 13장 쓰레드에서 배운다)  
   
### ArrayList의 메서드  

#### 생성자들
```
ArrayList() // 기본 생성자
ArrayList(Collection c) // 컬랙션에 저장되어 있는 것을 담은 ArrayList를 생성
ArrayList(int initialCapacity) // 배열의 길이를 줘서 생성
```
배열의 길이를 주는 것은,   
배열은 한번 만들면 길이를 바꿀 수 없다.  
따라서 배열 공간이 부족하면, 또 다시 새로 만들고 복사해야하기 때문에 연산 리소스를 차지하게 된다.  
예를들어 나중에 가서 배열의 길이가 엄청 길어져서 100만개가 됐다고 해보자.  
그런데 넉넉하게 배열을 안만들어놓고, 찔끔찔끔 계속 배열 공간을 늘리게되면  
계속 새로 배열을 생성하고 복사하는 작업이 이뤄져서  
말도 안되게 프로그램이 느려지게 된다.  
그러니 처음부터 제대로 예상되는 만큼 배열의 길이를 확보해서 생성해주는 것이 좋다.  
  
#### 추가하는 매서드
```
boolean add(Object o)
void add(int index, Object element)
boolean addAll(Collection c)
boolean addAll(int index, Collection c)
```
boolean으로 된 것들은, 성공하면 true 실패하면 false를 반환한다.  
각 매개변수에서 Object나 Collection들은 저장할 객체를 담은 것을 말하며,  
int index는 저장 위치를 말한다.  

#### 삭제하는 매서드  
```
boolean remove(Object o)
Object remove(int index)
boolean removeAll(Collection c)
void clear()
```
역시나 boolean은 성공 실패 여부를 반환한다.   
특정 위치 삭제에 index를 쓰며 clear는 모든 객체를 삭제한다.  
  
  
#### 검색하는 매서드  
```
int indexOf(Object o) // List 앞에서 부터 찾음
int lastIndexOf(Object o) // List 뒤에서 부터 찾음
boolean contains(Object o) // 객체가 있는지
Object get(int index) // 특정 위치 객체 반환
Object set(int index, Object element) // 특정 위치 객체 변경
```

#### 그외
```
List subList(int fromIndex, int toIndex) // 특정 Index 범위 내의 리스트 추출해서 반환
Object[] toArray() // ArrayList의 객체 배열을 반환
Object[] toArray(Object[] a)
boolean isEmpty() // 비어있는지
void trimToSize() // 빈공간 제거
int size() // 저장된 객체의 갯수
```
  

### 예제 Ex11_1  
간단히 ArrayList를 메서드로 다루는 법에 대한 예제이다  
  
몇 가지 주의할 점은    
Collections는 Collection과 다르다  
Collection은 인터페이스고   
Collections는 Collection을 다루기 위한 유틸 클래스이다  
  
  
그리고  
list1:\[1, 0, 1, 2, 3, 4, 5]  이런 ArrayList가 있다고 해보자  
여기다가 list1.remove(1)을 하면 어떻게 될까?  
정답은 list1:\[1, 1, 2, 3, 4, 5] 가 된다.  
  
왜? remove에다가 int 값을 넘기면 index로 인식해버리기 때문이다.  
따라서 ArrayList에 있는 특정 값을 지우고 싶은데 그게 Int다 라고 하면   
list1.remove(new Integer(1)) 이렇게 적어줘야 한다.    
  
  
### ✨\[중요] ArrayList에서 삭제 할 때 어떤 일이 일어날까?  
ArrayList에 저장된 세 번째 데이터(data\[2]) 를 삭제하는 과정을 예시로 들어서 보자    
![image](https://user-images.githubusercontent.com/101965836/166134982-de363dc8-cc63-44ab-885c-65303c0a8471.png)    
(1) 2를 삭제하고 나면, 그 뒤에 있는 데이터들을 한칸씩 밀어 올리게 된다    
(2) 그 다음 마지막 데이터였던 data\[4]의 값을 null로 바꾸고  
(3) size의 값을 감소시킨다  
여기서 (1)의 과정이 부담이 많이가므로, (1)이 일어나지 안도록 하는 것이 좋다  
  
  
### 오해할 만한 것
만약 for문 돌려서  
list.remove(index)로 index 0부터 ++ 하면서 마지막 index까지 삭제하면  
전부 다 지워질까??  
**삭제가 제대로 안된다.**  
무슨 말인가 하니  
![image](https://user-images.githubusercontent.com/101965836/166135134-122d9de5-ee01-4fc0-abe6-2a928e8d232d.png)  
이렇게 된다는 뜻이다  
   
#### 그럼 어떻게 해야 하느냐?     
그냥 **뒤에서 부터 삭제** 하면 된다  
이러면 또 **배열 복사도 발생하지 않는다**  
![image](https://user-images.githubusercontent.com/101965836/166135173-c4082e9e-d007-4e87-999b-a7d07ecae745.png)  
  
## 11-12~14 LinkedList
### 우선, 배열의 장단점에 대해
배열 장점 : (1) 구조가 간단 (2) 데이터 접근 시간이 짧다 (3) 순차적인 추가 삭제는 빠르다
(1) 그냥 물리적 논리적으로 쫘라락 순서대로 나열된 간단한 구조이다  
(2) 만약 index 10000 이라 하더라도, 그냥 각 배열 크기만큼에다가 10000을 곱하면 물리적으로 논리적으로 해당 위치로 바로 갈 수 있기 때문에 간단하게 해당 위치로 접근할 수 있다  
(3) 간단한 구조기에 뭐 짜잘하게 다른 내용 담긴거 없이 바로 값을 담는다. 따라서 제일 끝에 데이터를 추가하고 삭제하는 경우만 일어난다면 배열이 빠르다.    
    
배열 단점 : (1) 크기를 변경할 수 없다 (2) 비순차적 데이터 추가 삭제에 많은 시간이 걸린다  
(1) 크기 변경해야 할 경우, 새로운 배열을 생성 후 데이터를 복사해야 한다. 그렇다고 너무 큰 배열로 넉넉히 만들어버리면 메모리가 낭비된다  
(2) 중간에 있는 데이터를 추가 삭제 한번 할려고 하면 다 옮기는 작업을 해야해서 연산이 너무 많이 든다.   
물론 그냥 안옮겨버리는 방법이 있기도한데, 일단은 그냥 그렇다는 점만 알아두자   
  
### 그래서 LinkedList - 배열의 단점을 보완   
앞서 본 것과 같이 배열의 단점을 보완하기 위해서 LinkedList가 나왔다   
각각의 요소를 노드(Node) 라고 하며  
노드는 다음 데이터가 어디있는지 참조 변수를 갖고 있다.  
![image](https://user-images.githubusercontent.com/101965836/166135406-e5729605-347b-45ad-814f-87e4cc19db67.png)  
  
따라서 삭제 추가가 일어나면, 그냥 중간에 넣어두고 참조변수만 바꿔주면 된다  
  
### 그런데 LinkedList의 단점도 있다
배열은 연속적이라서 한번에 index로 찾아갈 수 있다  
그런데 LinkedList는 불연속적이라서 한번에 갈 수 없다  
물론 한번에 쫙 갈 수 있도록 해결할 수 는 없지만  
그냥 역방향으로도 갈 수 있도록 한게 이중 연결리스트 이다  

### 이중 연결 리스트(doubly linked list)
그래서 이 접근성이 나쁜 것을 해결한 것이 이중 연결 리스트이다  
![image](https://user-images.githubusercontent.com/101965836/166135554-546bb07b-6c01-498a-8860-481d363d0fb9.png)  
이전 요소가 있기 때문에 앞뒤로 이동할 수 있지만  
삭제, 추가가 일어나면 연결 고리를 앞 뒤 둘다 수정해줘야 하니까 연산 하나가 더 필요하다는 정도의 차이가 있다  

### 이중 원형 연결 리스트(doubly circular linked list)  
![image](https://user-images.githubusercontent.com/101965836/166135654-1d62eed9-571d-42ad-866d-16d54bdbab6b.png)  
맨 앞과 끝에다가도 앞뒤 방향을 추가해서 원형으로 순환하도록 만들 수 있도록 한 것이다    
  
근데 이런게 있긴 한데 자바에서는 앞서 본 그냥 이중 연결 리스트를 쓴다   

### ArrayList vs LinkedList  성능 비교  
![image](https://user-images.githubusercontent.com/101965836/166135687-531cc139-f5a7-4ed7-aa63-bfd729de4023.png)  
  
**(1) 순차적 데이터 추가 삭제** 의 경우 ArrayList가 빠른데   
**(2) 비순차적 데이터 추가 삭제** 의 경우 LinkedList가 압도적으로 빠르다  
**(3) 접근 시간** 의 경우 ArrayList가 엄청 빠르다  
  
  
### 연결 기반과 배열 기반
자료 구조는 모두 배열 기반과 연결 기반으로 이뤄져 있다  
따라서 앞서 본 ArrayList와 LinkeList의 구조와 성능 비교에 대해서 확실히 알아둬야 한다  
  
  
  
## 11-15~18 Stack과 Queue
  
### Stack
![image](https://user-images.githubusercontent.com/101965836/166135812-4edc738d-89ec-4034-8b23-fb674fe7171c.png)    
Stack : LIFO (Last In First Out) => (Last)마지막에 (In)들어간게 (First)제일먼저 (Out)나온다  
밑이 막힌 상자 모양이며, 넣는걸 push라 하고 빼는걸 pop이라 한다   
Array로 만드는게 유리하다   
    
### Queue
![image](https://user-images.githubusercontent.com/101965836/166135835-2957c1db-cc4d-47f8-b51b-f820754013b3.png)  
Queue : FIFO (First In First Out) => (First)처음에 (In)들어간게 (First)제일먼저 (Out)나온다  
밑이 뚫린 상자 모양이며, 넣는걸 offer라 하고 빼는걸 poll이라 한다  
LinkedList로 만드는게 유리하다    

### JAVA에서 Stack과 Queue
자바에서 Stack은 구현된 클래스로 있으며, Queue는 인터페이스로는 Queue가 있고 구현된 형태는 LinkedList가 있다   
```
Stack st = new Stack();
Queue q = new LinkedList();	// Queue인터페이스의 구현체인 LinkedList를 사용
```

### Stack의 메서드  
Object push(Object o) 추가(저장)  
Object pop() 맨 위에 객체 삭제    
  
boolean empty() 비어있는지 알려줌   
Object peek() 맨 위에 저장된 객체를 보는 거    
int search(Object o) 검색해서 같은 object가 있으면 index 반환, 못찾으면 -1 반환   
  
### Queue의 메서드  
boolean offer(Object o) 저장 하고 성공여부 반환    
Object poll() 삭제 하고 반환    
     
Object remove() 삭제인데 객체를 꺼내서 반환. 비어있으면 NoSuchElementException 발생   
Object peek() 삭제 없이 요소를 읽음 비어있으면 null  
Object element() 삭제 없이 요소를 읽음 비어있으면 NoSuchElementException 발생  
boolean add(Object o) 지정된 객체를 Queue에 추가. 저장공간 부족하면 illegalStateException 발생  
  
위의 6개 메서드들은  
각각 예외가 발생하는 메서드들이랑, 예외가 발생하지 않는 메서드로 나눌수 있다.  
![image](https://user-images.githubusercontent.com/101965836/166136419-eb065ed1-3d75-4b38-839e-fe14c5cecae0.png)  

|예외 여부|추가|삭제|확인|  
|---|---|---|---|  
|예외 없음|offer()|poll()|peek()|  
|예외 발생|add()|remove()|element()|  
  
### Queue는 인터페이스다 -> 객체 생성 불가  
Stack은 
```
Stack st = new Stack();
```
이 가능하다  
  
하지만 Queue는 인터페이스이므로 위처럼 **객체 생성이 불가능하다**  
따라서 Queue를 직접 구현하거나 다른 사람이 만든 클래스를 사용하면 된다  
![image](https://user-images.githubusercontent.com/101965836/166136532-fb85c3ba-090a-45a4-b8ca-ba88ee5f1473.png)  
JAVA API문서에서 위와 같이 Queue 인터페이스를 구현한 것들을 보면 우리에게 익숙한 LinkedList가 있다  
그러므로 LinkedList를 사용해서 Queue를 활용하자  
```
Queue q = new LinkedList();
```
근데 그냥 LinkedList라고 쓰면 되지 왜 Queue라고 쓰느냐?    
그건 그냥 공통되게 Queue를 쓰는 것들로 변환할 수 있기 때문이다  
예를 들면 위의 API 문서에서 나와있듯  
q가 LinkedList를 가리키다가 ArrayDeque를 가리킬 수 있다 (다형성)  

## 11-19~21 StackQueue 활용  

스택 활용 - 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저 뒤로가기/앞으로가기  
큐의 활용 - 최근사용문서, 인쇄작업 대기목록, 버퍼    

### Stack활용 예제 - 괄호검사  (예제 11_3)  
((3+5)\*8-2) 라는 수식이 있다고 해보자  
그러면  
```
(             // [ ( ,   ,   ,   ,   ]
((            // [ ( , ( ,   ,   ,   ]
((3+5)        // [ ( ,   ,   ,   ,   ] 
((3+5)\*8-2)  // [   ,   ,   ,   ,   ]
```
이런식으로 (를 만나면 stack에 괄호를 추가하고, )를 만나면 stack에서 괄호를 빼는 식으로 괄호 검사를 한다    

### Queue활용 예제 - 최근사용문서
예를 들어 10개의 문서만 저장한다고 치면,   
사용한지 오래된 기록부터 삭제하는 것이 맞기 때문에   
가장 먼저 들어온(오래된) 기록을 삭제하기 용이하도록 Queue를 활용해 구현하는 것이 적합하다    
  
  
## 11-22~23 Iterator, Enumeration, / Map과 Iterator  
### Iterator, Listiterator, Enumeration  
- 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스이다  

(1) Enumeration은 Iterator의 구버전에 해당한다     
그냥 Iterator를 쓰면 되고, 레거시가 나오면 그때 보면 된다     
(2) Iterator와 Listiterator의 차이는 조회 방향의 차이다    
Iterator는 -> 정방향만 가능한데    
Listiterator는 <- -> 양방향 가능하다    

### 왜 Iterator를 쓰냐? 
컬렉션의 종류가 List Set Map이 있는데  
컬렉션마다 구조가 달라서 요소들을 읽어오는 방법이 다르다  
따라서 이를 표준화 한 것이 Iterator이다  
  
예를 들면 List를 쓰다가 Set으로 바꿨다 치자   
그러면 읽어오는 코드도 바꿔야 하는데,  
Iterator를 사용하면 코드를 변경하지 않아도 된다  
  
  
### 어떻게 쓰느냐  
```
List list = new ArrayList();
Iterator it = list.iterator();

while(it.hasNext()) {
  System.out.println(it.next());
}  
```
컬렉션에 있는 iterator()를 호출해서, Iterator를 구현한 객체를 얻어서 사용한다   
iterator()는 Collection 인터페이스에서 public Iterator iterator(); 라고 정의되어 있으며   
구현은 각각 종류에 따라서 이뤄져있다    
   
### Map과 Iterator  
List Set Map 중에서  
Map에는 iterator()가 없다  
  
List와 Set은 Collection의 자손이지만  
Map은 Collection의 자손이 아니다  
  
### 그러면 Map에 저장된 요소들을 어떻게 가져와야 할까?  
keySet() entrySet() values()를 호출해야 한다  
아래 예제 코드를 보면서 설명해보자  
```
Map map = new HashMap();

Iterator it = map.entrySet().iterator();
```
  
entrySet()은 Key하고 Value 쌍을 갖는 Set을 반환한다. 이 말은 뭐냐면  
map을 set으로 바꾸는 entrySet으로 Set을 얻고   
Set은 iterator를 갖고 있으니 그걸로 쭉쭉 접근해주면 된다  

map에다가 iterator를 쓰는건 나중에 map 배울 때 자세히 알아보자  

## 11-25~29 Array  
### Arrays 유틸 메서드
배열을 편리하게 다루기 위한 메서드를 제공한다   

1. 배열의 출력 - toString()   
2. 배열의 복사 - copyOf() copyOfRange()  
3. 배열 채우기 - fill() setAll()  
4. 배열의 정렬과 검색 - sort(), binaraySearch()   여기서 이진탐색은 정렬된 배열에만 가능함  
5. 다차원 배열 출력 - deepToString()    
6. 다차원 배열 비교 - deepEquals()    
7. 배열을 List로 변환 - asList(Object... a)  여기서 Object 뒤에 ...은 가변 매개변수를 말함  
> 여기서 그냥 List는 읽기 전용이며, ArrayList로 다시 만들어 줘야지 변경 가능한 형태가 된다.  
  
8. 람다와 스트림(14장) 관련 - parallelXXX(), spliterator(), stream()  
  
예제 코드 11_6에서 각각 활용법에 대해 본다  
자세히 각 매서드에 대한 내용은 때에 따라 책이나 문서를 참고하고  
이런 것들이 있구나 정도 알아두고 필요에 따라서 검색해서 쓰도록 하자  
  
### 유의할 점
(1) copyOf()는 딥카피임   
(2) 향상된 for문   
예제코드에서 for(int i : arr7) 이런 코드를 썼는데, 향상된 for문이라 해서    
```
for(int x=0; x<arr7.length;x++) {
  int i = arr7[x];
  ...
}
```
이거를 간단히 한 것이 for(int i : arr7) 이다 (i에 각 배열 인덱스가 아니라 요소가 들어간다는 점을 주목)   
마치 javascript에서 forEach 문 같은 느낌이다     
  
  
## 11-30~33 Comparator와 Comparable  
객체 정렬에 필요한 메서드를 정의한 인터페이스 이다   
정렬 기준을 제공한다   
Comparable : 기본 정렬기준을 구현하는데 사용  
Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용  

### 근데 걔들은 인터페이스고, 어떻게 정렬하는데 쓰는데?  
Arrays.sort() 에서 앞선 기존 예제에서는 Arrays.sort(arr) 같은 식으로 딸랑 배열 하나만 던져주면 자동으로 정렬해버렸다  
(이건 사실 arr의 형식들이 Comparator를 갖고있기 때문이다)  
근데 여기다가 어떻게 정렬해라고 명령을 던져주면 좋지 않겠는가?  
그래서 .sort() 메서드는 arr 다음 인자로 Comparator 인터페이스를 implements 한 클래스의 객체를 같이 던져주면  
거기에 메서드의 구현부에 따라서 정렬하고 다시 결과를 반환해준다  
```
static void sort(Object[] a)  
static void sort(Object[] a, Comparator c)  
```
말이 좀 어려운데...    
일단 설명 차근히 보면서 뒤에서 예제 11-7을 보자    
  
### 그래서 Comparator와 Comparable이 뭘 가지고 있는데?
```java
public interface Comparator {
  int compare(Object o1, Object o2);  // o1, o2 두 객체를 비교
  boolean equals(Object obj); // equals를 오버라이딩하라는 뜻
}
```
compare는 결과가 같으면 0을 반환, 양수면 왼쪽이 크고, 음수면 오른쪽이 크다  

```java
public interface Comparable {
  int compareTo(Object o);
}
```
compareTo는 주어진 객체 o와 자기 자신을 비교하는 것이다  
  
### 근데 어떻게 정렬?  
정렬 기준은 다양하다.   
오름차순, 내림차순 같은 내용도 있으면서   
숫자기준, 이름기준 등등이 있을 수 있다   
어찌됐건 Comparator와 Comparable 둘 다 인터페이스이므로   
compare()와 compareTo()는 두 객체의 비교결과를 반환하도록 작성해주고, 같으면 0 오른쪽이 크면 음수, 작으면 양수로 해서 만들어주면된다   

### 예제코드 11-7
```java
import java.util.*;

class Ex11_7 {
	public static void main(String[] args) {
		String[] strArr = {"cat", "Dog", "lion", "tiger"};

		Arrays.sort(strArr); // String의 Comparable구현에 의한 정렬
		System.out.println("strArr=" + Arrays.toString(strArr));

		Arrays.sort(strArr, String.CASE_INSENSITIVE_ORDER); // 대소문자 구분안함
		System.out.println("strArr=" + Arrays.toString(strArr));

		Arrays.sort(strArr, new Descending()); // 역순 정렬
		System.out.println("strArr=" + Arrays.toString(strArr));
	}
}

class Descending implements Comparator { 
	public int compare(Object o1, Object o2){
		if( o1 instanceof Comparable && o2 instanceof Comparable) {
			Comparable c1 = (Comparable)o1;
			Comparable c2 = (Comparable)o2;
			return c1.compareTo(c2) * -1 ; // -1을 곱해서 기본 정렬방식의 역으로 변경한다.
						                // 또는 c2.compareTo(c1)와 같이 순서를 바꿔도 된다.
		}
		return -1;
	} 
}
```
여기서 보면  
```
Arrays.sort(strArr, String.CASE_INSENSITIVE_ORDER);
```
이 부분에서는 String 클래스 내에서 미리 정의된 Comparator를 넣어주는 식으로 했다   
이런식으로 미리 정의된 Comparator들이 있기도 하다  
  
  
### Integer와 Comparable
Integer 같은 경우 딱 비교 방식이 명확하지 않은가?  
int처럼 비교할 수 있을법한 자료형들은 Comaprable 인터페이스를 받아서 구현하고 있다  
  
### 그럼 Comparator 계속 구현해줘야 하나?  
아니다. 이미 그냥 뭐 대표적인 것들은 다 구현되어있고,  
우리는 "아~ 이런식으로 Comparator Comparable 이란것들이 있는거구나~" 하고 이해한다음  
가져다가 쓸 수 있기만 하면 된다  

## 11-34~36  HashSet
![image](https://user-images.githubusercontent.com/101965836/166145490-41e28dde-bfc6-4806-97c3-54088fd29c7a.png)  
Set 인터페이스는 순서X 중복X 이며,  
Set 인터페이스를 구현한 것은 (1) HashSet (2) TreeSet 이렇게 일반적으로 2가지가 있다   
  
#### HashSet  
- Set 인터페이스의 대표적인 녀석  
- 원래 순서X, 만약 순서가 필요하면 LinkedHashSet을 쓰면 된다  

#### TreeSet
- 범위 검색과 정렬에 유리한 컬렉션 클래스 (범위검색 : 예를 들면 10보다 크고 20보다 작은 것을 검색 하는 것) 
- HashSet보다 데이터 추가, 삭제에 시간이 더 걸림  

### HashSet의 주요 메서드 

#### 생성자
![image](https://user-images.githubusercontent.com/101965836/166145678-a7796ba9-bd40-4366-b558-bc6e50eba631.png)   
여기서 마지막 생성자에 float loadFactor가 있는데    
이거는 "얼마나 용량이 차면 미리 Hash를 늘릴거냐?" 라는 인자이다    
디폴트는 0.75이며 75%가 차면 용량을 늘리는 작업을 한다    
용량을 늘리는 작업은 한 번에 2배씩 늘어난다    

#### 추가 삭제
![image](https://user-images.githubusercontent.com/101965836/166145800-38756a2b-27bd-4ae5-bd44-9e4c3069ff7f.png)    
보면 이제  
추가, 삭제로 크게 나누고, 위의 2개 add 붙은 것들은 추가에 해당하며, 아래 4개들은 삭제에 해당한다  
간단한 것부터 말하면, add(Object o) remove(Object o)는 인자로 넘기는 객체 o를 추가하고 삭제하는 메서드이다  
그 다음 addAll과 removeAll인데  
인자로 넘기는 Collection c 를 통해서 합집합과 교집합을 구한다 (자세한 내용은 뒤에서 다시 다룬다)  
그리고 retainAll은 마찬가지로 Collection c를 통해서 조건부로 삭제를 한다.  
  
#### 포함 여부
![image](https://user-images.githubusercontent.com/101965836/166145908-396de5a0-45b8-4d0c-929b-0c85bf55a01c.png)   
여기서 iterator()는 이전에 알아봤듯 반복해서 다음 요소에 접근할 수 있도록 하기 위해 쓰는 것이다  
```
Iterator it = set.iterator();

while(it.hasNext()) {
	System.out.println(it.next());
}
```
  
#### 그외
![image](https://user-images.githubusercontent.com/101965836/166145941-1eea7744-e4a9-4086-844b-aa6162c1fe0d.png)    
  
  
## Hashset을 이용할 때 주의 할 점  
HashSet에다가 add 할 때, 이미 같은 값을 갖는 객체가 있으면 더이상 저장하지 않는다.    
근데 이러한 작업은 기본적으로 "같은 값이 뭔데?" 에 대해 답할 수 있어야 한다    
따라서 "같은 값"을 정의해주기 위해 equals()를 오버라이딩해서 구현해줘야 한다    
또한 HashSet이라는 이름 그대로 hash를 사용하기 때문에, hashCode()를 호출하므로    
hashCode()도 오버라이딩 되어 있어야 한다    
  
예제 11_11코드를 보면, equals() 오버라이딩을 안해서 문제가 발생하는 예시를 볼 수 있다  
  
	
### 그럼 오버라이딩 어떻게 해요?    
![image](https://user-images.githubusercontent.com/101965836/166146728-879cfa10-e3fa-470d-a970-51b63f536181.png)   
이렇게 하면 된다   
hashCode() 오버라이딩은   
```java
// 방법 1
public int hashCode() {
	return (name+age).hashCode();
}
```
```java
// 방법 2
public int hashCode() {
	return Object.hash(name,age); // 매개 변수는 가변 인자이므로 마음대로 넣어주면 된다  
}
```
원래는 만들어 줘야 하는데   
방법 2처럼 Object에서 제공하는 메서드를 사용하는 새로운 방법이 있다   
방법 2로 쓰면 되는데 방법 1로 써도 상관없다   
  
	
### HashSet으로 합집합 / 교집합 / 차집합 
예제 11_12를 통해 합,교,차집합의 구현 예시를 볼 수 있다.   
```java
Iterator it = setB.iterator();
while(it.hasNext()) {
	Object tmp = it.next();
	if(setA.contains(tmp))
		setKyo.add(tmp);
}

it = setA.iterator();
while(it.hasNext()) {
	Object tmp = it.next();
	if(!setB.contains(tmp))
		setCha.add(tmp);
}

it = setA.iterator();
while(it.hasNext())
	setHab.add(it.next());

it = setB.iterator();
while(it.hasNext())
	setHab.add(it.next());
```

그런데 **사실 그냥 메서드를 쓰면 쉽게 구현** 할 수 있다다  
```java
setA.retainAll(setB); 	// 교집합. 공통 요소만 남기고 삭제
setA.addAll(setB);			// 합집합. setB의 모든 요소를 추가 (중복은 HashSet 특성상 자동으로 제외됨)
setA.removeAll(setB);		// 차집합. setB와 공통 요소 제거
```

## 11-39~41 TreeSet이란?
- 범위 탐색, 정렬을 위한 구조이다   
- 이진 탐색 트리(binaray search tree)로 구현. 범위 탐색과 정렬에 유리하다  
- 모든 노드가 최대 2개(0개~2개)의 하위 노드를 가질 수 있다
- 각 요소(node)가 나무(tree) 형태로 연결되어 있다 (LinkedList의 변형)  

![image](https://user-images.githubusercontent.com/101965836/166147996-7a5f62bd-c69a-4068-bbc9-eb495e64b313.png)  
이진트리는 이렇게 생겼고  
root가 제일 위에 있으며, 자식을 2개 가지고  
또 자식이 부모로서 자식을 갖게 된다.  
그리고 나무 뿌리처럼 생겼다고 해서 Tree 라고 이름을 붙였다  
	 
### TreeSet이 LinkedList의 변형?? 무슨 뜻이냐 하면  
LinkedList는 next가 어디에 있는지 가리키는 값을 갖고 있다  
TreeSet도 비슷하게 next 자식 노드 2개가 각각 어디에 있는지 가리키는 값을 갖는다   
따라서 일종의 LinkedList라고 할 수 있다  

### 이진 탐색 트리  
Binary Search Tree  
그냥 "이진 트리" 가 아니라  
"이진 **탐색** 트리" 이다  
   
![image](https://user-images.githubusercontent.com/101965836/166148354-8cfc97ba-5fc8-41fc-96ba-6f04c17dede4.png)  
![image](https://user-images.githubusercontent.com/101965836/166148378-e9f17daa-2c7d-469d-9b8a-1b3460fbfe3f.png)  
(이렇게 왼쪽 오른쪽 자식을 가리키는 참조 변수 갖는다)  
  
이진 탐색 트리는 이진 트리에서 조건을 하나 추가하면 된다  
부모보다 작은 값은 왼쪽, 큰 값은 오른쪽에 저장하면 된다  
    
#### 단점: 추가 삭제에 시간이 많이 걸린다  
큰지 작은지 비교해야 하니까 하나 추가하려면 계속 비교해야 한다.  
  
### TreeSet 저장과정 - add(Object o)  
중복을 허용하지 않기 때문에, 대소비교 뿐만 아니라 equals()도 필요하다   
![image](https://user-images.githubusercontent.com/101965836/166149720-416f7f71-e44d-408d-8003-22d8ae3c5cd0.png)   
위 그림은 TreeSet에 7,4,9,1,5 순서로 데이터를 저장하는 과정을 나타낸 그림이다  
보다시피 처음에는 7만 딱 있으니 비교횟수가 적지만  
나중에 갈 수록 비교 횟수가 점점 많아지는 것을 알 수 있다  

## 11-42~45 TreeSet이 가지는 메서드들 
![image](https://user-images.githubusercontent.com/101965836/166149995-96ee20fd-91f7-4a21-89cd-3c93652990df.png)  
기본적인 add remove 등은 제외하고, 알아둘만한 메서드들만을 요약한 내용  
  
#### 예제 11_13,14,15 를 통해서 TreeSet의 기본 사용법에 대해 알아봄  

### 예제 11_15 => 범위 검색 예제  
![image](https://user-images.githubusercontent.com/101965836/166151532-630a6e75-4898-4e65-8e8d-62c1d5091ac8.png)  
TreeSet은 범위검색에 특화된 자료구조이므로  
위와 같이 범위 검색에 관한 메서드를 제공한다  

### 트리 순회(tree traversal)
이진 트리에서 모든 노드를 한번씩 읽는 것을 트리 순회라고 한다  
순회 방법에도
1. 전위순회
2. 후위순회
3. 중위순회
4. 레벨순회
이렇게 있다  
나중에 자료구조 할 때 다시 자세히 알아보자    


## 11-46~47 HashMap 이란?

![image](https://user-images.githubusercontent.com/101965836/166174019-a829975b-0bf5-4868-8f42-a998d6da2a12.png)   
  
- 데이터를 Key - Value 형식으로 저장한다  
- 위 그림과 같이 Map 인터페이스를 구현한다  
 
순서 X , 키 중복 X , 값 중복 O  
  
Hashtable : old버전, 동기화O   
HashMap : New버전, 동기화X   
별 이유 없으면 그냥 HashMap 쓰면 된다   
  
TreeMap : 이진 탐색 트리와 같은 특성을 갖고 있음 (사실 TreeSet이 TreeMap을 갖고 만든 것)    
LinkedHashMap : 순서가 필요하면 쓰면 된다  
  
### HashMap의 Key - Value  
- 해싱(hashing)기법으로 데이터를 저장.  
- 데이터가 많아도 검색이 빠르다  
- Map인터페이스를 구현해서, 데이터를 Key - Value 쌍으로 저장한다  
- Key는 유일해야하며, value는 중복을 허용한다

```java
HashMap map = new HashMap();
map.put("myId", "1234");
map.put("asdf", "1111");
map.put("asdf", "1234");  // 기존에 asdf : 1111 값이 있던게, 1234로 덮어씌워진다. 
// result : { myId : 1234 , asdf : 1234 }
```

### Hashing 이란?  
예를 들어   
환자 정보가 엄청 많이 쌓여있으면 어떻게 저장할까?   
주민번호에 따라서 캐비넷에 저장할 수 있을 것이다  
그러면 환자 정보를 조회할 때 마다 주민번호 앞자리에 해당하는 캐비넷에서 찾으면 되기 때문에  
환자 정보가 많아지면 캐비넷 수를 늘려서 탐색 시간을 줄일 수 있을 것이다   
  
	  
마찬가지로, 해싱이란  
해쉬함수를 이용해서 데이터를 저장하고 읽어오는 것을 말하는데  
해쉬코드가 마치 앞선 예시에서 캐비넷의 위치를 알려주는 것과 같다  

### 해싱으로 저장하는 개괄적 모습  
![image](https://user-images.githubusercontent.com/101965836/166174604-42888684-d645-43f7-b9e4-5837df5d8b7c.png)   
  
### 해쉬는 어떻게 계산?  
그냥 Object.hash() 함수를 쓰면 된다.  	
	
### 해시테이블
배열과 LinkedList가 조합된 형태이다   
![image](https://user-images.githubusercontent.com/101965836/166174702-82b9efe2-89b1-483f-b55d-a240205b97ea.png)   
이렇게 2차원 배열처럼 생겨서 Table 이라고 한다   
왜 LinkedList? 변경하기 쉽게 하기 위해서    
  
### 해시 테이블에서 데이터 가져오는 과정
![image](https://user-images.githubusercontent.com/101965836/166174865-e13a1250-30a2-49f8-86cc-582b6920e483.png)   
1. 키로 해시함수를 호출해서 해시코드를 얻는다  
2. 해시코드(함수 output)에 대응하는 LinkedList를 배열에서 찾는다   
3. LinkedList에서 키와 일치하는 데이터를 찾는다   
  
서로 다른 키 일지라도 같은 해시값을 가질 수 있다  
그래도 어차피 LinkedList로 연결되기 때문에 상관없으며, Key 값에 따라서 구별할 수 있다  

## 11-48~51 HashMap 주요 메서드  

### 생성자 
![image](https://user-images.githubusercontent.com/101965836/166175015-c016692f-a21a-4099-82fd-eb71ac7f4d3a.png)    
int형 값을 넘겨서 초기 용량을 넘길 수 있고,   
Map형 값은 다른 Map을 받아서 HashMap으로 생성하는 생성자이다    
  
### 추가 삭제 변경
![image](https://user-images.githubusercontent.com/101965836/166175087-02e7c769-8a6b-411a-b4dd-c09d440fc7e5.png)    
putAll(Map m)은 m에 저장된 값을 전부 넣어주는 메서드  

### 값 읽기
![image](https://user-images.githubusercontent.com/101965836/166175128-acae269c-b1e0-4b89-961b-4c4042b3391d.png)
entrySet() : key - value 쌍을 갖고옴    
keySet() : key 값들만 갖고옴  
values() : value 값들만 갖고옴  
  
![image](https://user-images.githubusercontent.com/101965836/166175218-caa804de-3280-4c56-b533-ec53681a9559.png)   
get은 키 값을 주면 그 값에 해당하는 값을 반환한다   
getOrDefault는 키 값을 주고 없으면 디폴트 값을 반환하는 메서드이다  


### 그외
int size()  
boolean isEmpty()  
void clear()  
Object clone()  

### 예제 11_16~18


## 11-52~56 Collections 클래스, 컬렉션 클레스 요약  

### Collections 클래스
Objects Arrays 같은 것들은 각 형에 맞는 유용한 메서드들을 제공한다.  
마찬가지로 Collections도 컬렉션에 유용한 static 메서드를 제공한다   
   
#### 컬렉션 채우기 복사 정렬 검색
fill() copy() sort() binarySearch() 등  

#### 컬렉션의 동기화된 메서드들 구분  
synchronizedXXX() 처럼 앞에 synchronized가 붙은 것들이 동기화된 메서드들이다  
ex) synchronizedList(List list) synchronizedMap(Map m)  

#### 변경 불가 컬렉션 만들기 (readOnly)  
unmodifiableXXX()라고 된 걸 쓰면된다  
ex) unmodifiableList(List list) unmodifiableMap(Map m)  

#### 싱글톤 컬렉션 만들기
싱글톤 컬렉션이라는건 객체 한 개만 저장하는 컬렉션을 말한다  
singletonXXX() 라고 된 걸 쓰면 된다  

#### 한 종류 객체만 저장하는 컬렉션 만들기  
checkedXXX() 라고 된 걸 써서  
한가지 타입만 저장 가능하도록 만들 수 있다  
예를 들어 String만 저장 가능한 list를 만들고 싶다면   
List chkList = checkedList(list, String.class);  
라고 해서 쓸 수 있다  

#### 이외에도 여러 메서드들이 있다  
어떤 메서드들이 있는지 개괄적으로 알아두면 좋다   

### 전체 정리
![image](https://user-images.githubusercontent.com/101965836/166176535-377a675c-40a5-4646-a803-4c8593484dc4.png)  
11장에 나왔던 각종 자료구조들에 대해서 정리  
  
  
    
  <br><br><br>
  
  ---
  
  <br><br><br>
  
  
  
# 12. 제네릭, 열거형, 애너테이션  
  
## 12-1 제네릭스(Generics)란?  
컴파일시 타입을 체크해 주는 기능(compile-time type check) - JDK1.5  
```java
ArrayList<Tv> tvList = new ArrayList<Tv>();

tvList.add(new Tv()); 		// OK
tvList.add(new Audio());	// 컴파일 에러. Tv 외의 타입은 저장 불가  
```

마치 매개변수처럼, 타입을 넘겨주는 것이다    
특히나 **컴파일 에러**로 이걸 잡아줄 수 있다는게 큰 장점이다  
제네릭스 덕분에 **타입 체크**를 강화해서 코딩할 수 있다  

### 제네릭스 쓰는 곳에는 꼭 타입을 써주자  
지금까지는 ArrayList list = new ArrayList(); 이렇게 썼지만  
앞으로는 
```java
ArrayList<Object> list = new ArrayList<Object>(); 
```
이렇게 꼭 써주자  
  
### 생성자에 \<Tv>는 생략 가능  
다이아몬드 연산자라고도 하는데  
생성자에서 \<\> 안에 내용은 생략 가능하다  
```java
ArrayList<Tv> tvList = new ArrayList<>();  // JDK 1.7부터 가능
```
	
	
### 제네릭스 장점  
1. 타입 안정성 증가
2. 형변환의 번거로움 줄여줌 -> 코드 간결해짐   

형변환을 잘못하면 ClassCastException 형변환 예외가 발생한다  
근데 이러한 문제를 제네릭스를 통해 막을 수 있어서 코드가 간결해진다  
![image](https://user-images.githubusercontent.com/101965836/166193815-d767093b-51e6-4e5d-8003-b293b7547a4d.png)   

실행시에 이런 예외들이 발생하는 것 보다   
컴파일시에 발생하는 것이 좋으니까  
컴파일로 잡을 수 있다는것이 큰 장점이 된다  
  
	
## 12-2 타입 변수  
클래스 작성할 때, Object 타입 대신 타입 변수(E)를 선언해서 사용  
  
![image](https://user-images.githubusercontent.com/101965836/166194062-4c866fea-498e-4d22-9e78-9f6b0ad0766e.png)  
옛날에는 위처럼 Object라고 다 써줬어야 했는데  
타입 변수를 통해서 제네릭 클래스를 사용할 수 있다  
  
타입변수는 보통 관례적으로 Type의 T 또는 Element의 E를 쓴다  
  
	
## 12-3 타입 변수에 대입하기  
객체 생성시, 타입변수 대신 실제 타입을 지정    
```java
ArrayList<Tv> tvList = new ArrayList<Tv>();
```
제네릭스 써주는 곳이 곧 타입변수 위치인 것이다   
    
### 형변환 생략 가능		
옛날에는 Object 같은 식으로 인자를 받아왔기 때문에  
반환도 어쩔 수 없이 Object 형으로 했어야 했고  
사용자가 return을 받을 때 마다 계속 형변환을 해서 아래와 같이 코드를 써줬어야 했다   
```
Tv t = (Tv)tvList.get(0);
```
  
근데 타입변수 덕분에 return의 타입도 가변적으로 타입변수를 통해 가능하게 되면서  
저런 형변환 없이 그냥 바로 받을 수 있게 된것이다  
```
public class ArrayList<E> extends AbstractList<E> {
	...
	public E get(int index) // 반환형을 E로 타입변수로 정할 수 있다. 
	...
}
```
이런 코드가 E를 받아서
```
public class ArrayList<Tv> extends AbstractList<Tv> {
	...
	public Tv get(int index) // 반환형이 E에서 Tv로 가변적으로 바뀐다 
	...
}
```
이렇게 반환타입이 가변적으로 바뀌는 것이다.  
굳   
  
  
  	
## 12-4 제네릭스 용어  
![image](https://user-images.githubusercontent.com/101965836/166194872-b0d3dcd5-2edf-40ad-9e96-26206f0e03d3.png)  
Box\<T> : 제네릭 클래스. **"T의 Box"** 또는 **"T Box"** 라고 읽는다    
T : 타입 변수 또는 타입 매개변수 (T는 타입 문자)    
Box : 원시 타입(raw Type)   
```
Box<String> b = new Box<String>();
```
이렇게 생성하면 된다   
여기서 \<T> 부분에 들어가는 타입을 **대입된 타입(매개변수화된 타입, parameterized type)** 이라고 한다  
  
	
## 12-5 제네릭 타입과 다형성  
참조 변수와 생성자에 대입된 타입은 일치해야 한다   
즉 **다형성으로 퉁쳐서 제네릭스 안에 넣는건 안된다**  
```
// 정직하게 이렇게 제네릭스 타입 일치해야함
ArrayList<Tv> 		list = new ArrayList<Tv>();  // OK

// 다형성 퉁치기 안됨
ArrayList<Product> 		list = new ArrayList<Tv>();  // 에러. Product가 조상이고 Tv가 자손일지라도 안됨
```
  
### 다만, 제네릭 클래스간 다형성은 성립  
```
List<Tv> list = new ArrayList<Tv>();
```
List가 조상, ArrayList가 자손이며, 클래스간 다형성은 성립한다  

### 매개변수 다형성도 성립한다  
```java
ArrayList<Product> list = new ArrayList<Product>();
list.add(new Product());
list.add(new Tv());
list.add(new Audio());
```
다만 이렇게 되면   
list에서 get 해올때 return 타입은 \<Product\> 이므로  
형변환을 해서 가져와야한다  
```java
Product p = list.get(0);
Tv t = (Tv)list.get(1);  
```  
  
	
## 12-7 Iterator\<E>
클래스를 작성할 때, Object타입 대신 T와 같은 타입 변수를 사용하도록 바뀌었다  
  
옛날에는 Iterator가 아래와 같은 식으로 쓰여져 있었다   
```java
public interface Iterator {
	boolean hasNext();
	Object next();
	void remove();
}
```
그러나 제네릭스가 도입된 이후 다음과 같이 변했다   
```
public interface Iterator<E> {
	boolean hasNext();
	E next();
	void remove();
}
```
이에 따라서 Iterator를 사용할 때 형변환을 할 필요가 없어졌다  
   
	 
예를 들어 과거에는 아래와 같이 사용했었다  
```java
Iterator it = list.iterator();
while(it.hasNext()) {
	Student s = (Student)it.next();
	...
```
하지만 제네릭스가 나온 이후 아래와 같이 변했다  
```java
Iterator<Student> it = list.iterator();
while(it.hasNext()) {
	Student s = it.next();
	...
```
보다시피 형변환을 일일이 써 줄 필요 없이   
선언 또는 생성 할 때만 딱 Student 형이라고 써주기만 하면 되니까  
(1) 타입 체크 (2) 형변환 실수 같은 것들을 줄일 수 있게 된다   
매우 굳  

## 12-8 HashMap\<K,V\>
여러 개의 타입 변수가 필요한 경우, 콤마를 구분자로 선언한다   
   
HashMap 같은 경우 Key와 Value로 2종류 타입이 필요하기 때문에   
이렇게 두 가지 타입 변수가 필요하다  
  
	
HashMap의 구현 부분을 간단하게 보면 아래와 같다
```java
public class HashMap<K,V> extends AbstractMap<K,V> { 
	...
	public V get(Object key) { ... }
	public V put(K key, V value) { ... }
	public V remove(Object key) { ... }
	...
}
```
근데 여기서 보면 get에서 K로 key를 안받고 이상하게 Object로 받는다.   
이건 왜그렇냐면 뭐 대단히 문법적이고 그런 내용은 아닌데   
get(Object key) 에서 안에 hash와 관련된 메서드를 사용하는 부분이 있는데  
여기서 hash() 라는 메서드가 Object 타입으로 값을 받기 때문에  
hash(Object o) 로 값을 줘야한다  
근데 여기다가 굳이 \<K|>로 형변환 했다가 다시 또 (Object)key 로 또 바꾸고... 하면  
불필요하게 형변환이 일어나기 때문이다  
그래서 그냥 Object로 받는 거다.  
  
## 12-9 제한된 제네릭 클래스  
extends로 대입할 수 있는 타입을 제한할 수 있다.  
예를 들어  
```java
class FruitBox\<T\> { 
	ArrayList<T> list = new ArrayList<T>();
	...
} 
```
라고 했는데   

``` 
FruiteBox<Elephant> BigElephant = new FruitBox<Elephant>();
```
이렇게 코끼리가 과일박스에 들어가버릴 수 있다.  
(Elephant가 FruiteBox에 들어가는 것은 의도한 바가 아니다)  
따라서 \<T\>로 넘어오는 형식을 제한하기 위해서, 특정 클래스의 자손만 가능하도록 할 수 있다  

### 제한된 제네릭스 지정하기  
간단하게, extends로 제한한다  
```java  
class FruitBox<T extends Fruit> { 
	ArrayList<T> list = new ArrayList<T>();
	...
}
```
이렇게 타입을 제한하면   
```java 
FruitBox<Apple> appleBox = new FruitBox<Apple>();
// 에러  
// FruitBox<Elephant> elephantCase = new FruitBox<Elephant>();  
```
이렇게 제한할 수 있게 된다    
  
	
### 인터페이스인 경우에도 extends로 제한한다  
```
interface Eatable {}
calss FruitBox<T extends Eatable> { ... }
```
implements 안쓰고 extends로 쓴다  
  
	
## 12-11 제네릭스의 제약   
타입 변수에 대입은 인스턴스 별로 다르게 가능하다     
```java
Box<Apple> appleBox = new Box<Apple>();
Box<Grape> grapeBox = new Box<Grape>();
```
  
	
### (1) static멤버에 타입 변수 사용 불가  
```java
class Box<T> {
	static T item; // 에러
	static int compare(T t1, T t2) { ... } // 에러
	...
```

### (2) 배열 생성할 때 타입변수 사용 불가 
쉽게 말해서 **new 다음에 T가 오면 안된다**    
```java
class Box<T> { 
	T[] itemArr;  // OK. T타입 배열을 위한 참조 변수  
			...
	T[] toArray() {
		T[] tmpArr = new T[itemArr.length];  // 에러. 제네릭 배열은 생성 불가능하다  
```
이건 왜 그럴까 추측해보면  
new로 배열을 생성하려면 메모리 할당 문제도 있기 때문이라고 생각한다  
예를 들어 int형으로 크기 5짜리 배열을 만들게 되면  
메모리에서 4byte \* 5 = 20byte 만큼 할당해야 한다.  
하지만 여기서 형이 지정되어 있지 않으면  
얼마짜리 크기로 메모리에서 배열에 할당해야 할 지 알 수 없으므로  
에러를 발생시키는 것 같다   
  
##### 정리하자면, new 연산자 뒤에 T는 안된다
new는 객체나 배열을 생성하는 놈이기 때문이다.   
근데 T\[] itemArr 같은건 상관없다.  
뇌피셜로 왜 그럴까 생각해보면  
요거는 참조변수이므로 그냥 주소를 가리키는 참조형은   
안에 들어가는 내용이 메모리 주소이므로   
얼마나 메모리 공간을 변수에 할당할지 명확하기 때문인 것 같다   
  
  
## 12-12 와일드 카드 \<?\>
앞서  
```
ArrayList<Tv> tvList = new ArrayList<Tv>(); 
```
이렇게 \<Tv\>로 둘 다 꼭 일치했어야 했고, 부모 자식관계일지라도 다형성을 적용시켜서 쓸 수 없었다    
하지만 와일드 카드를 통해서   
타입이 다른 객체도 참조할 수 있게 된다   

```java
ArrayList<? extends Product> list = new ArrayList<Tv>();		// 가능
ArrayList<? extends Product> list = new ArrayList<Audio>();	// 가능
ArrayList<Product> list = new ArrayList<Tv>();	// 에러. 타입 불일치  
```
![image](https://user-images.githubusercontent.com/101965836/166220009-3793a0d7-1871-4a3b-8036-db0dffd1b05e.png)
extends와 super에 대해서 이야기 해보면  
Object -> Product -> Tv 순으로 상속 관계가 정해지고 Product를 기준으로 적는다고 하면     
extends면 Product와 그 아래 자손인 Tv도 가능하고  
super면 Product와 그 위 조상인 Object도 가능하다   
그리고 쌩으로 \<?\>라고 적으면 그냥 Object Product Tv 전부 다 가능하다   

### 제네릭은 뭐고... 와일드카드는 뭐고... 헷갈리는데?  
[자바 제네릭 와일드카드 사용 방법](https://thecodinglog.github.io/java/2020/12/15/java-generic-wildcard.html)  
여기를 참고했다   

자. 제네릭에다가 \<T\> 써가지고 하는 거는  **메서드 선언할 때** 쓰는거고  
와일드카드로 \<?\> 써가지고 하는 거는 **호출이나 사용할 때** 쓰는거다   
뭔말인고 하니   
  
아래 코드처럼
```
FruiteBox<Fruit> fruiteBox = new FruitBox<Fruit>();  // 기본 형태
// FruiteBox<Fruit> appleBox = new FruitBox<Apple>(); // 에러 발생.
```
\<\> 요거에다가는 양쪽에 항상 같은 거 적어줘야 한다 했다.  
그리고, \<T extends Fruit\> 했던 거는 선언부에서나 됐지  
저런식으로 어떤 객체를 생성할때는 딱 명시적으로 "무슨 클래스 들어갑니다~\~" 라고 말 해줘야 한다  
근데, 객체지향이 또 어떤 녀석인가? 얘도 넣고싶고 쟤도 넣고싶고... 이것도 저것도 다 동시에 됐으면 좋겠다 라는게 객체지향 아닌가  
그래서 위 예시의 에러 발생 라인처럼 appleBox지만 일단 Fruit들은 다 넣어보고 싶을 수 있는거다   
  
그래서 나온게 **와일드카드**다   
```
FruiteBox<? extends Fruit> appleBox = new FruitBox<Apple>();
```
이렇게 해서 appleBox에는 Fruit와 자식들이 다 들어갈 수 있다   
원래는 **제네릭 의도**가  
**"선언 할 때 타입 주시면, 딱 그거만 취급하도록 할게요"** 이다  
근데 이게 사용하다 보니까  
**"아... 이게 쫌 다형성도 쓰고싶은데..."** 라고 프로그래머들이 요구하기 시작했다   
이에 따라서   
**"오케이! \[와일드카드] 발동!"** 해서  
**"?로 쓰면 형을 엄격하게 검사하지 않겠습니다"** 라고 하는 것이다  
	  
		
## 12-14 제네릭 메서드  
제네릭 타입이 메서드 선언 할 때 써주는 것을 말한다  
클레스에서 인스턴스 생성할 때 타입을 받는 것과 구분하기 위한 개념이다  
제네릭 클래스와 제네릭 메서드가 헷갈릴 수 있지만,  
그냥 이름 그대로 클래스에 제네릭은 객체 생성용에서 쓰는거고  
메서드에서 제네릭은 메서드 내에서 형을 다양하게 받으면서도 한번에 쓰기 위해 사용하는 거다  
```
static <T> void sort(List<T> list, Comparator<? super T> c)
```
  

### 클래스의 \<T\>와 메서드의 \<T\>는 별개  
```java
class FruitBox<T> {
	...
	static<T> void sort(List<T> list, Comparator<? super T> c) {
		...
	}
}
```
둘 다 타입변수 이름이 T로 일치하지만  
서로 다른 타입변수이다  
class에서 T는 인스턴스 생성시에 정해지고  
멤버변수라던가 그런 친구들에 대한 것이지만  
  
메서드에서 T는 매개변수에 들어있는 List\<T\>라던가   
매서드 구현부에서 필요하기 때문에 받아오는 타입이다   
  
그냥 딱 마치 instance variable과 local variable과 비슷하다고도 생각해볼 수 있다  
   
이 부분 헷갈리지 않도록 주의  
  
### 제네릭 메서드는 호출 할 때마다 타입을 대입해야 한다 
#### - (사실 대부분 생략 가능)  
![image](https://user-images.githubusercontent.com/101965836/166229149-9f058ea7-f0d0-4603-88cb-b9d4e69ebae8.png)  
  
### 메서드 호출 할 때 타입을 생략하지 않을 때는 클래스 이름 생략 불가  
```java
System.out.println(<Fruit>makeJuice(fruitBox)); 				// 에러
System.out.println(this.<Fruit>makeJuice(fruitBox));		// OK
System.out.println(Juicer.<Fruit>makeJuice(fruitBox)); 	// OK
```
이부분은 뭐 어쩔땐 생략 가능하고 뭐하고 하기도 하는데  
그냥 깔끔하게 클래스 이름 써주는게 좋다고 한다  

### 제네릭 vs 와일드카드  
제네릭 메서드 : 메서드를 호출할 때마다 다른 제네릭 타입을 대입할 수 있게 한 것   
와일드카드 : 하나의 참조변수로 서로 다른 타입이 대입된 여러 제네릭 객체를 다루기 위한 것   
말이 어려운데  
```java
// 제네릭 메서드
static <T extends Fruit> Juice makeJuice(FruitBox<T> box) { ... } 
```
```java
// 와일드카드
static Juice makeJuice(FruitBox<? extends Fruit> box) { ... }
```
이렇게 둘 다 같은 소리지만  
위에 제네릭은 호출할 때 Juicer.\<Fruit\>makeJuice(fruitBox) 이렇게 호출되고  
아래 와일드카드는 호출할 때 Juicer.makeJuice(fruitBox) 이렇게 호출될 것이다  
  
이는 어떤 의도를 갖고 서로 다른거냐면  
호출하는 쪽 입장에서는  
제네릭은 **이런 타입에 대해서 보낼겁니다** 라고 타입에 유의해주세요 하는 느낌이고  
와일드카드는 **그냥 내가 보내주는 거 따라서 알아서 처리해** 라고 메서드가 알아서 하라고 툭 던져주는 느낌이다    
  
## 12-15 제네릭 타입의 형변환  
#### 원시타입이란?  
Box\<T\> 처럼 선언된 클래스를 그냥 Box box = new Box(); 로 생성할 수 있다   
여기서 그냥 제네릭 명시 없이 선언된 box 참조변수의 객체를 원시타입이라고 한다   

### 원시타입 쓰지마...
일단 원시타입은 안쓰는 게 좋다  
사실 원시타입으로 제네릭 포함된 타입을 참조변수가 가리킬 수 있다  
```
Box b = new Box<String>(); //가능은 함
```
그치만 이렇게 섞어쓰고 막 서로 형변환하고 하는건 바람직하지 않다  
```
Box<Object> objBox = null;
Box box = (Box)objBox;
objBox = (Box<Object>)box;
```
이게 동작은 하는데   
그냥 섞어서 쓰지 않도록 하자  
  
	
### 헷갈리는 형변환  
제네릭이랑 와일드카드랑 서로 형변환도 가능하다  
```
FruitBox<? extends Fruit> abox = new FruitBox<Apple>(); // 가능
FruitBox<Apple> appleBox = (FruitBox<Apple>)abox; 			// 가능. 경고 발생
```
일단은 이렇게 형변환이 가능하다는 것만 알아두면 된다   

## 12-16 제네릭 타입의 제거  
사실 컴파일 과정에서 제네릭은 다 제거되고  
컴파일러가 문맥에 맞게 타입을 적어준다    
### (1) 제네릭 타입은 경계(bound)를 제거  
![image](https://user-images.githubusercontent.com/101965836/166233786-379b1983-0402-47ef-9ab2-2ba63c414894.png)  

### (2) 형변환도 적절히 추가  
![image](https://user-images.githubusercontent.com/101965836/166233860-e44e2d67-9471-449e-8e5a-5629262e00ce.png)  
제네릭 장점이 형변환을 생략할 수 있다는 점인데  
컴파일 과정에서 제네릭 타입 제거 후에 타입이 불일치하면, 적절하게 형변환도 추가해준다    
  
### (3) 와일드카드가 포함된 경우에도 형변환 적절히 추가  
![image](https://user-images.githubusercontent.com/101965836/166234062-39be4937-4d2c-46a1-b1fa-f48017383107.png)  

## 12-17 열거형(enum)  
열거형이란  
- 서로 관련된 상수들을 같이 묶어놓은 것이다  
  
- Java는 타입에 안전한 열거형을 제공한다    
    
뭔말인지 예시를 통해 보면
	
```java
class Card { 
	static final int CLOVER = 0;
	static final int HEART = 1;
	static final int DIAMOND = 2;
	static final int SPADE = 3;
	
	static final int TWO = 0;
	static final int THREE = 1;
	static final int FOUR = 2;
	
	final int kind;
	final int num;
}
```
이렇게 귀찮게 일일이 상수를 지정해주지 않고  
아래와 같이 한방에 enum으로 정리할 수 있다
```java
class Card {
	enum Kind { CLOVER, HEART, DIAMOND, SPADE }
	enum Value { TWO, THREE, FOUR }
	
	final Kind kind;
	final Value value;
}
```
그리고 타입에 안전하다는 말은  

```java
if(Card.CLOVER==Card.TWO)
```
라고 되어 있을 때     
위에서 static final int로 일일이 지정해줬던 경우    
그냥 int형에 값이 둘 다 2니까 true가 나온다   

하지만 enum을 사용하면    
값은 2일지라도 서로 Kind와 Value로 다른 타입이니까  
아예 그냥 컴파일 에러가 난다  
  
#### Java의 열거형은 (1) 값 (2) 타입 둘 다 체크한다   


## 12-18 열거형의 정의와 사용
### 정의 하는법
```java
// enum 열거형이름 { 상수명1, 상수명2, ... }
enum Direction { EAST, SOUTH, WEST, NORTH }
```
  
### 선언하고 사용하는 방법	
```java
class Unit {
	int x, y;					// 유닛의 위치
	Direction dir;		// 열거형 인스턴스 변수를 선언
	
	void init() {
		dir = Direction.EAST;	 // 유닛의 방향을 EAST로 초기화
	}
}
```
**Direction 형이라고 선언**을 해줘야 한다   
enum이 그냥 단순히 숫자로 0 1 2 3 4 값을 갖는게 아니라 타입도 체크하기 때문에   
타입을 지정해서 선언해줘야 한다    
   
### 열거형 상수의 비교에 ==와 compareTo() 사용가능  
```java
if(dir==Direction.EAST) { // true
	... 
} else if (dir.compareTo(Direction.WEST) > 0) { // 가능 
	...
}
```
compareTo는 왼쪽이 크면 + , 같으면 0 , 오른쪽이 크면 - 이다   
11장에서 배웠고, 뺄샘이라고 생각하면 된다   
   
compareTo를 쓰는 이유는 아래와 같이 쌩자로 비교가 안되기 때문이다  
```java
if(dir > Direction.WEST) { // 에러. 열거형 상수에 비교연산자 사용불가   
```
     
## 12-19 열거형의 조상 - java.lang.Enum  
모든 열거형은 Enum 클래스의 자손이며, 아래 메서드를 상속받는다   
![image](https://user-images.githubusercontent.com/101965836/166236844-653b6428-3f7a-4bde-b9a9-c491fddd7dc0.png)   
    
추가로  		
values() valueOf() 를 컴파일러가 자동으로 추가한다  
> valueOf() 메서드는 특정 객체의 원시 값을 반환합니다.
  
valueOf는 아래 예시로 보면  
```
Direction d = Direction.valueOf("WEST"); // 열거형 상수 이름을 준다  
```
이거는 Direction.WEST 와 같은 거다  
언제 쓰느냐보다는 그냥 이런 게 있구나 라고 알아만 두면 된다  

### 사실 열거형은 하나하나 객체다  
그래서 비교연산자 \> \<를 쓸 수 없고, compareTo() 같은 식으로 쓴다  
그치만 switch case 문에 바로 집어넣어서 쓸 수 있다  
```
switch(dir) {
	case EAST:
		...
```
  
## 12-21 열거형에 멤버 추가하기  
지금까지는 열거형에 그냥 0 1 2 3 자동으로 값이 들어갔지만  
때로는 열거형일지라도 값을 원하는대로 주고싶을 수 있다  
이럴 때 아래와 같이 원하는 값을 줄 수 있다
```java
enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10) }
```
다만 괄호를 사용하려면, 인스턴스 변수와 생성자를 새로 추가해줘야 한다  
  
	
```java
enum Direction {
	EAST(1), SOUTH(5), WEST(-1), NORTH(10);
	
	private final int value;
	Direction(int value) { this.value = value; }
	
	public int getValue() { return value; }
}
```
사실 ()는 생성자임.  
또한 열거형의 생성자는 항상 private이므로 아래와 같이 쓸 수 없다  
```
Direction d = new Direction(1); // 에러. 생성자는 외부에서 호출할 수 없음
```
  
	
## 12-23 애너테이션이란?  
주석처럼 프로그래밍 언어에 영향을 미치지 않으며, 유용한 정보를 제공하는 것  
  
애너테이션 이해를 돕기 위해  
다른 사례로 예를 들어보자   

자바 소스코드를 작성하면서 주석을 입력하지만  
결국 별도의 문서로 소스코드를 설명하는 부분이 필요하다  
따라서 소스코드 작성하고 또 document를 써주고 해야하는데  
일정에 치이다보니 문서 업데이트가 늦어지곤 했다  
이에 따라서 자바 코드 내의 주석을 문서화 시켜주는 작업을 자동으로 해주는  
**문서화 주석** 이라는 게 생겨났다  
이렇게 되면서 소스코드 파일과 코드를 설명하는 문서를 따로 작성할 필요가 없게 되었다   
  
마찬가지로 애너테이션은   
프로그램과 설정파일(XML)이 따로 있었다  
소스코드와 따로 있다보니 불편함이 있어서 이를 애너테이션을 통해서 소스코드 파일에 합쳐서 넣어서 해결한 것이다  
애너테이션은 특정 프로그램한테 이 코드는 어떤 설정을 갖고 있다 라는 설정 정보만 제공하기 위한 것이다  
  
### 애너테이션의 사용 예시

```java
@Test
public void method() {
	...
}
```
  
이렇게 하면 JUnit이라는 테스트 프로그램에게  
이 매서드가 테스트 대상임을 프로그램에게 알려주는 역할을 한다  

## 12-24 표준 애너테이션
Java에서 제공하는 애너테이션을 말한다  
![image](https://user-images.githubusercontent.com/101965836/166336269-b4b2520e-af2c-486d-8f7f-a78bfa414f90.png)  
\* 이 붙은것들은 메타 애너테이션들이다  

## 12-25 \@Override
오버라이딩 할 때 메서드 이름을 잘못적는 실수를 하는 경우가 많다  
이러한 실수를 막기 위해 컴파일러가 오버라이딩을 올바르게 했는지 컴파일러가 체크하도록 하는 애너테이션이다  

```java
class Child extends Parent {
	@Override
	void parentMethod() { ... }
	...
}
```

## 12-26 \@Deprecated  
앞으로 사용하지 않을 것을 권장하는 필드나 매서드에 붙인다  
```java
@Deprecated
public int getDate() {
	return normalize().getDayOfMonth();
}
```
컴파일은 되지만 컴파일 후 경고 메세지를 출력해준다  

## 12-27 @FunctionalInterface  
함수형 인터페이스에 붙이면, 컴파일러가 올바르게 작성했는지 체크  
함수형 인터페이스는 14장에서 자세히 이야기 하며  
함수형 인터페이스에는 하나의 추상메서드만 가져야 한다는 제약이 있음  
  
물론 안붙여도 되지만, 컴파일러가 제대로 작성했는지 체크해준다  
```java
@FunctionalInterface
public interface Runnable {
	public abstract void run();
}
```
함수형 인터페이스는 하나의 매서드만 갖고 있어야 하므로  
함수형 인터페이스인데 둘 이상의 매서드를 작성하면 에러를 보여준다  

## 12-28 @SuppressWarnings
컴파일러의 경고메세지가 나타나지 않게 억제한다  
괄호 안에 억제하고자 하는 경고의 종류를 문자열로 지정한다  

```java
@SuppressWarnings("unchecked")		// 제네릭스와 관련된 경고 억제
ArrayList list = new ArrayList();	// 제네릭 타입 지정을 안함
list.add(obj);										// 경고 발생 지점
```

아래와 같이 작성해서 둘 이상의 경고를 동시에 억제할 수도 있다   
```java
@SuppressWarnings({"unchecked", "deprecation"})		
```

## 12-29 메타애너테이션
애너테이션을 위한 애너테이션이다  
애너테이션을 만들때 사용하는 것  
![image](https://user-images.githubusercontent.com/101965836/166338088-3c32bb2b-ffce-417f-ae3c-a8247325f80e.png)  

## 12-30 @Target
애너테이션을 정의할 때, 적용대상 지정에 사용한다   
예를 들어, "이 애너테이션은 매서드에만 사용합니다" 라든가  
"이 애너테이션은 타입, 필드, 로컬변수에만 사용합니다" 라고 적용대상을 지정할 때 사용한다  

```
@Target({TYPE, FIELD, METHOD, PARAMETER})
```
![image](https://user-images.githubusercontent.com/101965836/166338313-a6e795e0-7025-40e0-abe0-2ce81b890d1d.png)  
대충 이정도 타입들이 있음    


## 12-31 @Retention
애너테이션이 유지(Retention)되는 기간을 지정하는데 사용한다   
![image](https://user-images.githubusercontent.com/101965836/166338526-0f17e4f2-0fc7-41d4-9356-8bb91350814b.png)  
예를 들면  
```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override { }
```
오버라이드 애너테이션을 정의하는 부분인데  
오버라이딩 애너테이션은 그냥 컴파일 할 때 오버라이딩이 제대로 됐는지 컴파일러가 체크하는데 사용하는 것이다  
따라서 애너테이션이 실행시에도 남아있을 필요가 없으므로  
RetentionPolicy를 SOURCE로 해주는 것이다  
  
참고로 RUNTIME이라고 설정 하는 것은  
RUNTIME에만 존재하는 게 아니라, RUNTIME 까지 존재한다는 것이니 헷갈리지 말도록   

## 12-32 @Documented  /  @Inherited
##### @Documented
javadoc으로 작성한 문서에 포함시키려면 @Documented를 붙인다  
##### @Inherited
애너테이션을 자손 클래스에 상속하고자 할 때 사용한다  
이게 무슨말인가 하니   

```java
@Inherited
@interface SuperAnno {}

// ------------------

@SuperAnno
class Parent {}

// ------------------

// @SuperAnno <- Parent가 @Inherited 붙은 @SuperAnno를 사용했기에, @SuperAnno를 붙여준 것과 똑같다  
class Child extends Parent {}  
```
근데 많이 사용되지는 않아서, 그냥 이런게 있다 정도만 알아두면 된다   

## 12-33 @Repeatable
반복해서 붙일 수 있는 애너테이션을 정의할 때 사용한다  
```java
@Repeatable(ToDos.class)
@interface ToDo {
	String value();
}
```
이렇게 ToDo에 Repeatable을 붙이게 되면
```java
@ToDo("delete test codes.")
@ToDo("override inherited methods")
class MyClass {
	...
}
```
이렇게 애너테이션을 여러개 붙일 수 있다  

**주의할 점**은  
@Repeatable인 @ToDo를 하나로 묶을 컨테이너 애너테이션도 정의해줘야 한다  
```
@interface ToDos {
	ToDo[] value();
}
```
  
## 12-34 애너테이션 타입 정의하기
애너테이션은 물론 앞서 봤듯 직접 만들어 쓸 수 있다  
```java
@interface 애너테이션이름 {
  타입 요소이름();
    ...
}
```
  
그리고 애너테이션의 메서드는 추상 메서드이며, 애너테이션을 적용할 때 지정한다

```java
// 애너테이션 정의 예시
@interface TestInfo {
  int       count();
  String    testedBy();
  String[]  testTools();
  TestType  testType();
  DateTime  testDate();
}
```
```
// 위에서 정의한 애너테이션 사용 예시
@TestInfo(
  count=3, testedBy="Kim",
  testTools={"JUnit", "AutoTester"},
  testType=TestType.FIRST,
  testDate=@DateTime(yymmdd="160101", hhmmss="123456")
)
public class NewClass { ... }
```

## 12-35 애너테이션의 요소  
### 기본값 지정 가능
적용시 값을 지정하지 않으면, 사용될 수 있는 기본값 지정 가능(null예외)  
```java
@interface TestInfo {
  int count() default 1;
}
```
```java
@TestInfo
public class NewClass { ... }
```
이렇게 default를 이용하면  
\@TestInfo에 count값을 일일이 안줘도 자동으로 기본값으로 동작하게 된다  
  
### 요소가 하나만 있으면 이름 생략 가능
단, 요소의 이름이 value여야 함  
```java
@interface TestInfo {
  String value();
}
```
```java
@TestInfo("passed")     // @TestInfo(value="passed") 이렇게 안써도 됨
class NewClass { ... }
```

### 요소의 타입이 배열인 경우 {}를 사용해야함
```java
@interface TestInfo {
  String[] testTools();
}
```
```java
@Test(testTools="JUnit")  // 하나일때는 그냥 값만 적어도됨

@Test(testTools={"JUnit", "AutoTester"}) // 둘 이상이면 {} 사용

@Test(testTools={}) // 빈 값이면 비어있는 {}를 사용
```

## 12-36 모든 애너테이션의 조상 
모든 애너테이션은 사실 Annotation이라는 공통의 조상을 갖고 있으며  
java.lang.annotation.Annotation에 있다   
  
사실 Annotation은 인터페이스인데, 상속은 할 수 없다     
  
좀 더 파고들어보면  
```java
package java.lang.annotation;

public interface Annotation {
  boolean equals(Object obj);
  int hashCode();
  String toString();
  
  Class<? extends Annotation> annotationType();
}
```
이렇게 Annotation은 인터페이스면서 추상매서드를 갖고 있다.  
따라서 모든 애너테이션은 이 추상매서드를 갖고있고, 모든 애너테이션은 이 추상매서드를 또 받을 수 있지만  
어차피 애너테이션도 또 다시 추상매서드이므로 이를 구현하지는 않는다  
하지만 그냥 이런게 있다 정도로... 알아두자   
뭐 알아서 애너테이션 받아서 활용하는 다른 프로그램에서 잘 쓰는 용도가 있겠지  

## 12-37 마커 애너테이션 (Marker)
요소가 하나도 정의되지 않은 애너테이션을 말한다  
```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {}
```
이렇게 정의된 요소가 하나도 없는 것을 말한다   
  
이걸 어디다가 쓰냐면  
이 메서드가 Override 목적을 갖습니다 라고 컴파일러에게 알려주는 용도로만 사용하는 것이다   

## 12-38 애너테이션 요소의 규칙 
#### (1) 요소의 타입
기본형 String enum 애너테이션 Class 만 허용된다  
Class가 된다는 말이지 인스턴스가 된다는 말이 아니니까 혼동하지 않도록   
#### (2) 괄호안에 매개변수 선언 불가 (int sum(int a, int b); 못한다는 뜻)
#### (3) 예외를 선언할 수 없다 (Exception 못씀)
#### (4) 타입 매개변수 정의할 수 없다 (\<T\> 못씀)
  
애너테이션 규칙은 굳이 외울 필요는 없고  
이런게 있다 정도만 알아두고, 나중에 애너테이션을 만들거나 자주 활용해야 할 때가 오면   
그때 다시 보면 된다  
  
<br><br><br>  
  
---  
  
<br><br><br>  
  
# 13. 쓰레드

## 13-1 프로세스와 쓰레드 
프로세스 : 실행 중인 프로그램, 자원(resource)과 쓰레드로 구성된다  
쓰레드 : 프로세스 내에서 실제 작업을 수행. 모든 프로세스는 최소한 하나의 쓰레드를 가지고 있다   
  
프로세스 : 쓰레드 = 공장 : 일꾼  

### "하나의 새 프로세스보다, 하나의 새 쓰레드가 더 비용이 적다"  
따라서 요청을 다중으로 처리하려면 멀티 쓰레드로 처리하는게 좋다     

## 13-2 멀티쓰레드의 장단점  
대부분 프로그램이 멀티쓰레드로 작성되어 있다. 그러나 멀티쓰레드 프로그래밍이 장점만 있는 것은 아니다  

### 장점
- 시스템 자원 효율적으로 사용 가능
- 사용자 응답성 향상
- 작업이 분리되어 코드가 간결해진다

### 단점
- 동기화에 주의해야 한다
- 교착상태(dead-lock)가 발생하지 않도록 주의
- 쓰레드가 효율적으로 고르게 실행될 수 있게 해야한다  

#### 교착상태 
서로 다른 쓰레드가 서로의 자원을 요청하는 경우를 말한다  
예를 들어, 사람 A는 못을 들고있고, 사람 B는 망치를 들고 있다고 해보자.  
근데 여기서 A는 B보고 "야 망치 주면 내가 못질할게" 라고 하고  
B는 A보고 "야 못 주면 내가 못질할게" 하고 있는 것이다.  
  
#### 기아 상태(Starvation)
특정 스레드가 작업할 기회를 갖지 못해서, 실상 작업을 하지 못하는 상태  
  
  
### 멀티쓰레드는 잘 짜는게 어렵다  
그냥 쓰레드를 구현하고자 코드 짜는건 쉬운데  
좋은 멀티쓰레드 코드를 짜는게 어렵다  


## 13-3 쓰레드의 구현과 실행
쓰레드 구현하는 방법은 2가지가 있다  
(1) Thread 클래스를 상속 (2) Runnable 인터페이스를 구현
둘 중 Runnable인터페이스 구현 방식이, 인터페이스는 여러 종류를 받을 수 있기 때문에 좋다    
자바는 단일 상속만 허용하기 때문에 Thread를 상속받으면 다른 클래스를 상속받을 수 없기 때문이다  
  
### (1) Thread 클래스 상속
```java
class MyThread extends Thread {
  public void run() {
    ...
  }
} 
```
```
// Thread 클래스 실행 방법
MyThread t1 = new MyThread();
t1.start();
```  

### (2) Runnable 인터페이스를 구현
```java
class MyThread2 implements Runnable {
  public void run() {
    ...
  }
} 
```  
```java
// Runnable 인터페이스 구현체 실행 방법
Runnable r  = new MyThread2();
Thread t2   = new Thread(r);
// 위의 두 줄을 한 줄로 쓰면 Thread t2 = new Thread(new MyThread2());
  
t2.start();
```

## 13-5 쓰레드 실행 메서드 start()
(1)쓰레드 생성  
(2)start() 호출 -> 작업 시작  
  
### OS 스케쥴러가 실행 순서를 결정한다  
```
t1.start();
t2.start();
```
t1 t2 중에서 뭐가 먼저 실행될지 알 수 없다    
OS 스케쥴러가 알아서 뭘 실행 시킬지를 결정하기 때문이다    


## 13-6 start()와 run()  
  
#### 우리가 작성한건 run()인데, 왜 start()를 별도로 호출하나요?   
요약 : run()은 메인 콜 스택에서 실행되는거고, start()가 새 콜 스택 만들고 거기다가 run()을 집어넣는거임  
  
차근차근히 아래 그림과 설명 따라서 읽어보면 이해가 될 것  

![image](https://user-images.githubusercontent.com/101965836/166426659-a82527f8-1621-46c1-8e7f-a34c8725bdc3.png)  
  
(1) 콜 스택에서 start를 실행   
(2) 이에 따라 새로운 콜 스택이 생성됨  
(3) 새 콜 스택에 run()이 집어넣어지고, start()는 할 일을 마치고 종료됨  
(4) 마침내 각각 독립적인 작업이 이뤄지는 두 스택이 만들어짐  

## 13-7 main쓰레드
- main 메서드의 코드를 수행하는 쓰레드   
  
### 쓰레드에는 '사용자 쓰레드'와 '데몬 쓰레드' 두 종류가 있다  

**"실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료 된다**  
이는 곧, 사용자 쓰레드가 없고 데몬 쓰레드만 있으면 프로그램은 종료된다는 뜻이며  
데몬 쓰레드는 곧 보조 쓰레드구나 정도로 일단 알아두면 된다   
    
헷갈리지 말것은  
데몬 쓰레드가 보조 쓰레드라고 했다고, Thread th = new Thread(); 해서 만든 쓰레드가 모두 보조적이니 데몬 쓰레드라는 뜻이 아니다  
데몬 쓰레드인지 아닌지를 우리가 따로 지정해줘야하며, 기본적으로는 사용자 쓰레드가 된다.  
즉, 우리가 앞서 멀티 쓰레드 코드를 짠건 다 사용자 쓰레드이고, 데몬 쓰레드는 13\-18에서 배우겠지만 따로 "이게 데몬쓰레드다" 라고 설정해주어야한다. 

## 13-8 싱글쓰레드와 멀티쓰레드  
### 싱글쓰레드
![image](https://user-images.githubusercontent.com/101965836/166428265-3becbe52-2cab-4a74-97d7-0330effb5909.png)   
당연하지만 A 반복문이 다 실행되고나서 B 반복문이 실행된다  

### 멀티쓰레드
![image](https://user-images.githubusercontent.com/101965836/166428876-e43cacfe-e6d0-46ff-801c-73a7c45130cb.png)  
![image](https://user-images.githubusercontent.com/101965836/166428898-8538d586-8ae0-441f-83b5-56856762a5a1.png)  
멀티쓰레드 동작 그래프는 정확히 걸리는 시간이나 순서를 뜻하는게 아니고  
OS 스케쥴러에 따라서 매 번 동작이 달라진다  
그리고 **동시에 두 작업을 수행하지만 오히려 시간이 더 걸릴 수 있다**   

## 13-11 쓰레드의 I/O 블로킹(Blocking)  
(I/O는 Input/Output을 의미한다)  
쓰레드 I/O 블로킹이란  
입 출력시에 작업을 중단하는 것을 말한다   
![image](https://user-images.githubusercontent.com/101965836/166436626-6d924a35-b76e-4397-b39f-e6db6bf0f5a7.png)  
![image](https://user-images.githubusercontent.com/101965836/166436672-15423732-e875-4b49-9187-92c3e42c48e1.png)  
멀티 쓰레드를 사용하면 사용자 입력을 기다리는 동안 다른 쓰레드가 작업을 진행해서  
작업을 싱글 쓰레드보다 더 빨리 끝마칠 수 있다  
  
  
## 13-14 쓰레드 우선순위  
작업의 중요도에 따라 쓰레드의 우선순위를 다르게 해서, 특정 쓰레드가 더 많은 작업시간을 갖게 할 수 있다  
```java
void  setPriority(int newPriority)  // 쓰레드 우선순위 변경
int   getPriority()                 // 쓰레드 우선순위 반환

public static final int MAX_PRIORITY  = 10  // 최대우선순위
public static final int NORM_PRIORITY = 5   // 보통우선순위
public static final int MIN_PRIORITY  = 1   // 최소우선순위
```
1~10까지 우선 순위가 있으며, 숫자가 클수록 우선적으로 처리한다. (가장 중요한건 10)
  
![image](https://user-images.githubusercontent.com/101965836/166437416-779642df-5861-4301-8c78-d731d39cada7.png)  
이론상 이렇게 돌아가겠지만  
이는 JVM의 우선순위를 말하는거지, OS의 실질적인 우선순위가 아니다  
JVM이 "이런 우선순위로 실행 해주세요" 하고 던지면  
OS가 "그렇게 하도록 노력은 해 볼게" 정도로 받아서 동작한다  
따라서 상황에 따라 우선순위가 제대로 반영되지 않을 수 있다  
   
그러나 항상 우선순위에 따라서 작업이 끝난다고 할 수 없다   
따라서 너무 우선순위에 너무 기대지는 말자   
  
  
## 13-16 쓰레드 그룹
- 서로 관련된 쓰레드를 그룹으로 묶어서 다루기 위한 것이다  
- 모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함되어 있어야 한다   
- 쓰레드 그룹을 지정하지 않으면 'main 쓰레드 그룹'에 속한다
- 자신을 생성한 쓰레드(부모 쓰레드)의 그룹과 우선순위를 상속받는다  

관련된 메서드로는    
![image](https://user-images.githubusercontent.com/101965836/166438044-696baebc-6537-47f0-97a0-fba7e86510b6.png)  
이렇게 있다 (이런게 있다 정도만 알아두자)  
  
## 13-17 쓰레드 그룹의 메서드  
![image](https://user-images.githubusercontent.com/101965836/166438561-ac47f527-b005-4a70-9107-dce8ba1f586f.png)  
대충 이 정도 있다  
대부분 쓰레드가 실행중인 상태나 얼마나 남아있는가 등을 체크하는데 사용한다  
  
  
## 13-18 데몬 쓰레드(daemon thread)
일반 쓰레드(non-daemon thread)의 작업을 돕는 보조적인 역할을 수행하는 쓰레드를 말한다   
따라서 데몬 쓰레드는 일반 쓰레드가 모두 종료되면 자동적으로 종료된다    
예를 들면 자동 저장하는 작업 같이 보조적인 역할을 수행한다

### 언제 데몬쓰레드가 생성되나?
가비지 컬렉터, 자동저장, 화면 자동갱신 등에 사용된다   
  
### 어떤 방식(의도)으로 작성하나?
무한루프와 조건문을 이용해서 실행 후 대기하다가 특정조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다   
```java
public void run() {
  while(true) {
    try {
      Thread.sleep(3 * 1000);
    } catch(InterruptedException e) {}
    
    // autoSave의 값이 true이면 autoSave()를 호출한다.
    if(autoSave) {
      autoSave();
    }
  }
}
```
  
#### 데몬쓰레드 관련 메서드  
```java
boolean isDaemon()          // 쓰레드가 데몬쓰레드인지 확인한다
void setDaemon(boolean on)  // 쓰레드를 데몬쓰레드 또는 사용자쓰레드로 변경한다. true를 지정하면 데몬쓰레드가 된다  
```  
setDaemon(boolean on)은 반드시 start()를 호출하기 전에 실행되어야 한다  
그렇지 않으면 IllegalThreadStateException이 발생한다  
  
## 13-20 쓰레드의 상태
![image](https://user-images.githubusercontent.com/101965836/166440763-789647ae-6e3d-452b-ac13-07b60e071c4c.png)  
간략하게 설명하면  
생성된 다음 start()가 되면 실행대기 라인에 들어가서 줄을 선다  
그 다음 자기 차례가 오면 실행되다가, 좀 작업을 하고 다시 실행대기 라인에 들어간다    
그러다가 오른쪽 위의 suspend() sleep() wait() join() I/O block 이 이뤄지면  
일시정지된 쓰레드들이 대기하는 곳으로 이동하고  
time-out resume() notify() interrupt() 등이 이뤄지면 다시 줄서기를 시작해서 실행되게 된다  
  
각각 메서드에 대해서는 뒤에서 자세히 배운다  

## 13-21 쓰레드의 실행제어  
쓰레드의 실행을 제어할 수 있는 메서드가 제공된다   
![image](https://user-images.githubusercontent.com/101965836/166441550-79894cfe-cc4b-47a9-a63e-6defcf3fa11a.png)  
**이 메서드들이 매우 중요**하고, 이 메서드들을 잘 활용해야지 효율적인 쓰레드 프로그램을 작성할 수 있다    
다음 강의들에서 메서드들에 대해 자세히 배운다    
  
여기서 파란색 박스친 부분을 보면 static 메서드임을 알 수 있다  
이 static 메서드들은 쓰레드 자기 자신에게만 호출 가능하다    

## 13-22 sleep()
![image](https://user-images.githubusercontent.com/101965836/166441705-c764f0ac-d76e-4e11-b4cc-ac13503dde3f.png)   
현재 쓰레드를 지정된 시간동안 멈추게 한다    
sleep()은 static 메서드이며, 항상 쓰레드 자기자신에 대해서 동작한다는 점을 명심하자       

### 예외처리를 꼭 해줘야 한다  
sleep()이 되면 (1) 시간이 다 되거나 (2)InterruptedException이 발생하면 깨어난다   
InterruptedException을 예외처리 해주지 않으면 에러가 난다  
```java
try { 
  Thread.sleep(1, 500000);
} catch(InterruptedException e) {}
```
{} 안에는 아무것도 안넣어줘도 된다  
여기서 InterruptedException은 무슨 문제가 있어서 발생하는게 아니라  
의도적으로 인터럽트가 발생해서 깨어나는 것이기 때문에 {}에 아무것도 안 넣어도 된다   

### 예외처리 귀찮으니 보통은 따로 매서드를 만들어 준다  
```java
void delay(long millis) {
  try { 
    Thread.sleep(1, 500000);
  } catch(InterruptedException e) {}
}
```
이렇게 하면   
sleep()을 호출하는 대신,    
직접 만든 delay()를 호출해서 일일이 예외를 처리해줘야 하는 불편함을 줄일 수 있다.   

### 다른 쓰레드를 지정해서 sleep()을 시킬 수 없다  
```java
try {
  th1.sleep(2000);
} catch(InterruptedException e) {}
```
이렇게 한다고 해서 에러는 안나는데, 오해의 여지가 있다    
예를 들어 main 쓰레드에서 저런식으로 th1.sleep()을 쓰면  
"아 th1을 sleep 시키는가보다" 라고 할 수 있는데  
실상은 main 쓰레드가 sleep 되어버린다  
  
  
따라서 꼭 아래와 같이 Thread.sleep()으로 써주자  
```java
try { 
  Thread.sleep(2000);
} catch(InterruptedException e) {}
```  
  
  
## 13-24 interrupt()  
대기상태(WAITING)인 쓰레드를 실행대기 상태(RUNNABLE)로 만든다  
```
void    interrupt()     // 쓰레드의 interrupted상태를 false에서 true로 변경
boolean isInterrupted() // 쓰레드의 interrupted상태를 반환
static boolean interrupted()   // 현재 쓰레드의 interrupted상태를 알려주고, false로 초기화
```
말이 어려우니 다시 설명해보면   
    
일단 interrupt가 뭐냐면  
말 그대로 자고있던 쓰레드를 깨우는 것이다   
그러면 쓰레드는 깨어나서 다시 일을 하게 된다   
  
그리고 interrupt() 가 호출되면 앞서 말했듯 쓰레드가 깨어나는 것 뿐만 아니라          
쓰레드 내부에서 "얘가 인터럽트가 됐는지 알려주는" boolean interrupted 가 true가 된다   
상태를 나타내는 인터럽트가 있다는 뜻은 곧, "이 쓰레드에 인터럽트가 일어날 때마다 어떤 작업을 하도록 하겠다" 라는 식으로 코드를 짤 수 있다  
  
그리고 상태를 얻어오는게 isInterrupted()랑 interrupted() 두 가지가 있는데, 둘이 비슷하지만 조금 다르다  
일단 알아둘 것은 (1) static 여부의 차이가 있으며, (2) 상태 확인 후에 상태가 false로 초기화가 이뤄지는지 아닌지 차이점이 있다    
상세한건 예제 코드 13\-9 (ch13\-25)를 통해서 확인할 수 있다  
  
  
사실 그냥 별거없고  

그냥 th1.interrupt() 해주면 th1이 인터럽트 발생되고  
th1 구현된 클래스 안에다가는  
그냥 "인터럽트 발생하면 어떻게 해라" 적어주면 된다   
  

## 13-26 suspend(), resume(), stop()  
- suspend() : 쓰레드 실행을 일시정지    
- resume() : 일시정지된 쓰레드를 다시 재개    
- stop() : 쓰레드를 즉시 종료    
  
![image](https://user-images.githubusercontent.com/101965836/166446659-b9236500-514e-4498-92cc-3892586d86dd.png)  

### 근데!!! Deprecated 됐으니 쓰면 안된다  

이 메서드들은 교착상태(dead-lock)에 빠지기 쉬워서 deprecated 되었으니    
쓰지 않는 것을 권장한다  
  
  
## 13-28(1) join()
어떤 쓰레드가, 다른 쓰레드의 작업을 기다리도록 하는 것임.  
예를 들어 main 쓰레드에다가 th1.join() 으로 해주면  
th1 쓰레드의 작업이 모두 끝날 때까지 기다리게 된다.  
```java
void join()                         // 작업이 모두 끝날 때까지
void join(long millis)              // ms동안
void join(long millis, int nanaos)  // ms동안 + ns동안
```

### 예외처리를 해줘야 함  
InterruptedException이 발생하면 작업 재개    
  
```java
try {
  th1.join();
  th2.join();
} catch (InterruptedException e) {}
```


## 13-28(2) yield()
남은 시간을 다음 쓰레드에게 양보하고, 자신(현재 쓰레드)은 실행을 대기한다.  
yield()가 딱 언제 써야할지 쉽게 한마디로 말하긴 어려우니, 아래 코드를 참고하길 바란다    
yield()와 interrupt()를 적절히 사용하면, 응답성과 효율을 높일 수 있다.  

### yield() 사용 예시
busy-waiting 상황에서 쓰인다.  
busy-waiting이란  
쓰레드가 상태나 응답을 불필요할정도로 빠르게 반복적으로 체크하는 경우를 말한다.  
```
while(true) {
  if(응답왔으면) {
    ...  // 작업 수행
  }
}
```
이런식으로 되어 있다 해보자.  
계속 응답이 도착했는지 체크해야 하는 것은 맞는데  
이런식으로 while(true) 안에서 계속 조건문을 돌면  
불필요할만큼 반복적으로 응답이왔는지 체크하게 된다.  
따라서 이런 경우에는 그냥  
Thread.yield()를 사용해서  
다른 쓰레드들이 더 일할 수 있도록 해주는 게 좋다  
  
여기서 만약에 그냥 Thread.sleep(1000)을 써버리면 
인터럽트에 대한 응답성이 너무 떨어져서 안좋다  
  
### 사실 yield() 쓰고 안쓰고 큰 차이는 없다  
그냥 OS 스케줄러에게 알려준다는 것 뿐이지  
실상은 그리 큰 성능의 차이는 없지만  
강의에서 말하기를 아주 조금 빠르다고 한다    

## 13-30 쓰레드의 동기화(synchronization)
멀티 쓰레드로 작업하다보면, 어떤 동작이 또 다른 쓰레드의 작업에 영향을 미칠 수 있다.   
따라서 쓰레드의 동기화 개념이 필요하다   
  
**쓰레드 동기화**란   
어떤 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는 것을 말한다  
  
### 동기화 하려면
간섭받지 않아야 하는 문장들을 "임계 영역"으로 설정 하면 된다   
임계영역은 락(lock)을 얻은 단 하나의 쓰레드만 출입 가능하며  
객체 1개에 락 1개만 가능하다  
  
### 13-31 synchronized 를 이용한 동기화  
#### (1) 메서드 전체를 임계 영역으로 지정  
```java
public synchronized void calcSum() {
  ...
}
```
이러면 메서드 전체가 임계 영역이 된다  

#### (2) 특정한 영역을 임계 영역으로 지정  
```java
synchronized(객체의 참조변수) {
  ...
}
```

### 임계영역이 너무 많으면 성능이 떨어진다  
멀티 쓰레드 장점이 동시에 여러 쓰레드가 돌아가는 것인데  
임계 영역이 너무 많으면, 멀티 쓰레드의 의미가 없어지게 된다  
따라서 임계영역을 최소로 두기 위해서 (2) 처럼 임계 영역을 최소로 지정하는 편이 좋다  

### 동기화(임계 영역)가 필요한 경우 예시  
예를 들어 출금하는 메서드가 있고,  
이 메서드에 사람A 사람B가 동시에 멀티 쓰레드로 접근했다고 가정해보자  
또 출금 메서드의 구성은 "(if) 잔고가 출금액보다 크면 (then) 출금해줌" 으로 이뤄져있다  
  
이러한 상황에서  
**(잔고 100원 있음) A 100원 출금원함 / B 100원 출금원함** 상태일 때  
A가 if만 통과하고 B에게 작업을 넘기고  
B도 if 통과하고 100원 뽑아가게되면 잔고는 0원밖에 안남아있게 된다   
근데 A는 if를 통과했던 상황이니까, 조건문을 거치지 않고 바로 100원을 또 뽑게된다  
이렇게 되면 결과적으로 잔고는 -100원이 되어서 문제가 발생하게 된다   
   
   
이럴 때 바로 synchronized가 필요하다.  
임계영역으로 묶어주고 나면  
다른 쓰레드가 들어오지 못하므로  
A가 출금하고 나서 B가 조건을 검사하게 동작하기 때문에  
B는 잔고가 0원인 상태에서 if를 검사하므로 문제가 발생하지 않게 된다.   
  

## 13-34 wait()과 notify()  

### 동기화의 단점
동기화는 한번에 한 쓰레드만 돌아갈 수 있으니 비효율적이다  
따라서 동기화의 효율을 높이기 위해서 탄생한 게 wait()과 notify() 이다  

### wait()과 notify()
Object클래스에 정의되어 있으며, 동기화 블록 내에서만 사용할 수 있다   
- wait() : 객체의 lock을 풀고 쓰레드에 해당 객체의 waiting pool에 넣는다  
- notify() : waiting pool에서 대기중인 쓰레드 중에서 아무거나 하나를 깨운다    
- notifyAll() : waiting pool에서 대기중인 모든 쓰레드를 깨운다  

#### 쉽사리 의중을 알 수 없으니, 예제로 이해하는게 좋아보인다  

### 예제 1 - 출금 입금 예시
(코드는 예제13-12, 예제13-13 ; ch13-32)  
앞서 yield에서 busy-waiting 개념이 기억나는가?  
13-28(2) yield() 에서 했던 내용인데 다시 이야기 하자면   
입금 출금 상황에서 계좌에 돈이 충분히 없으면 출금이 되지 않는다  
근데 여기서 계속 무한반복으로 조건을 돌게되면   
불필요할 정도로 자꾸 조건을 검사하게 되니까 효율이 떨어진다  
그래서 yield를 써서 OS 스케쥴러에게 "아... 저는 그렇게 자주 체크 안해도 됩니다" 라는 식으로 스케쥴링에 참고 되도록 넘겨줬었는데  
실상은 그리 큰 성능 차이를 볼 수 없다고 했다   
   
synchronized 상태인 경우에는 앞선 busy-waiting보다 좀 심각해진다  
{} 블럭 안에는 lock 권한을 갖고 있는 쓰레드만 접근 할 수 있게 되기 때문에  
심지어 그 무한 조건을 도는 상황을 구제하기 위해서 입금해주려는 메서드를 하려고 해도  
lock이 걸려 있어서 입금할 수 없게 되어버린다  
  
따라서 이러한 문제를 해결하고자 wait()과 notify()를 쓴다  
##### wait()
``` 
synchronized {
  while(true) {
    if(잔고 > 출금액) { 
      // 돈 충분하면
      출금(); 
    } else { 
      // 돈 부족하면
      wait(); 
    }
  }
}
```
이렇게 돈이 부족하면 "돈 없으니까 저기 가서 대기하세요" 상태로 만들어 놓는다  
그러면 해당 쓰레드는 부를 때 까지 계속 대기하고 있다가  
아래와 같이 잔고에 돈이 들어오는 매서드가 생기면 notify()로 돈 생겼으니 할일 해봐라 라고 하게 된다    
##### notify() 
```
public synchronized void 입금(int money) {
  계좌 += money;
  notify();
}
```
근데 여기서 주의할 점은  
이렇게 notify();를 쓰면  
출금을 대기하던 쓰레드들이 여럿 있다고 할 때, 그 중 무작위로 아무나 깨우게 된다  
즉, 운 나쁜 쓰레드가 있으면, 계속 notify()의 랜덤룰랫에 선택되지 못하고 계속 기다리기만 할 수도 있다는 뜻이다  
따라서 경우에 따라 notifyAll()을 적절히 사용해, 모든 쓰레드를 깨우기도 해야함을 알 수 있다  
일반적으로는 notifyAll()을 쓰는게 좋다고 하는데, 이에 대해서는 차차 알아가보자. 사실 아직 notify()를 어떻게 잘 써야할지 감이 안온다   
  
### 예제 2 - 요리사와 손님의 음식 주문
(예제13-14,13-15)  
예제13-14는 wait() notify()가 없을 때 문제가 어떻게 발생하는지를 보여주는 예제이고  
예제13-15는 wait() notify()를 사용해 문제를 해결한 예제이다   
  
간략히 설명하면  
요리사 쓰레드 : 음식을 랜덤으로 만듦. 테이플이 꽉 차면 음식을 더이상 만들지 않고 wait(). 음식을 만들면 notify().    
손님 쓰레드 : 테이블에 있는 음식을 랜덤으로 먹음. 테이블에 음식이 없으면 wait(). 음식을 먹으면 notify().  
  
근데 이 예제 13-15에도 문제가 있는데  
손님이 음식을 먹고 notify()를 했는데  
이 notify()는 랜덤으로 하나의 쓰레드만 깨우는 방식이다  
따라서 요리사가 깨면 좋겠지만, 계속 다른 wait 중인 손님만 notify 할 수 있다  
그러므로 이쯤에서 "아 원하는 대상을 notify 할 수 없을까?" 라는 요구가 생기게 되고  
이를 해결한게 **Lock & Condition**이다  
자바 정석 본책에서 공부하거나, 그냥 검색해서 공부해도 되는 부분이다  
아무튼 일단 이런 것들이 있구나 정도만 알아두자   
  
<br><br><br><br><br>  
  
---
  
<br><br><br><br><br>  

# 14. 람다와 스트림(Lambda & Stream)  

### 함수형 언어
빅데이터 출현과 함께 많은 양의 데이터를 처리하기 위해서 함수형 언어가 필요해지기 시작했다  
이에 맞춰서 Java 뿐만 아니라 python javascript 모두 함수형 언어의 기능을 받아오고자 하여 람다가 도입되었다  
즉, 람다부분 확실히 잘 해두면, 다른 언어를 배울때도 많은 도움이 될 것이다  

## 14-1 람다식 Lambda Expression
- 함수를 간단한 식으로 표현하는 방법을 람다식이라고 한다   
- 람다식은 익명함수 이다 (anonymous function) (화살표 함수로 바꾸면 이름이 없어지므로)
### 함수와 메서드의 차이
메서드는 클래스 안에 종속적이고, 함수는 클래스에 독립적이다  
근본적으로는 동일한 기능이며 함수는 일반적인 용어이고 메서드는 객체지향적 용어이다  

## 14-2 람다식 작성방법
```java
// 기존 메서드
int max(int a, int b) {
  return a > b ? a : b;
}

// (1) 이름과 반환타입 제거
(int a, int b) -> { return a > b ? a : b; }

// (2) return만 있으면 return문 생략 가능
(int a, int b) ->  a > b ? a : b

// (3) 매개변수 타입이 추론 가능하면, 생략가능
(a, b) ->  a > b ? a : b
```

### 주의사항
![image](https://user-images.githubusercontent.com/101965836/166616376-4d4bd8c5-5c62-4783-9214-35c58913ddc8.png)

#### (1) 매개변수 생략
매개변수 하나인 경우 괄호 생략 가능  
그러나 타입이 있으면 생략 불가

#### (2) 문장이 하나 뿐일때 { } 생략가능
  
단, 하나 뿐인 문장이 return일 경우 괄호 생략 불가  
  
## 14-3 람다식의 예
어떻게 만드는지 예제를 바탕으로 풀어보자 
```java
// 메서드
int max(int a, int b) {
  return a > b ? a : b;
}

// 람다식
(a, b) -> a > b ? a : b
```
```java
// 메서드
int printVar(String name, int i) {
  System.out.println(name+"="+i);
}

// 람다식
(name, i) -> System.out.println(name+"="+i)
```

```java
// 메서드
int square(int x) {
  return x * x;
}

// 람다식
x -> x * x
```
```java
// 메서드
int roll() {
  return (int)(Math.random()*6);
}

// 람다식
() -> (int)(Math.random()*6)
```

# 14-4 java에서 람다식은 익명 객체
자바는 모든게 다 객체다  
따라서 람다식도 사실 익명 '함수'가 아니라 익명 '객체' 이다  

```java
// 이러한 람다식은
(a,b)-> a > b ? a : b

// 사실 이런식으로 익명 객체이다
new Object() {
  int max(int a, int b) {
    return a > b ? a : b;
  }
}
``` 
  
근데 람다식(익명 객체)를 다룰려면 참조변수가 필요한데  
참조변수의 타입은 뭘까?  
이게 무슨 말이냐면 일단 아래 코드를 보면서 이야기 해보자  
![image](https://user-images.githubusercontent.com/101965836/166617558-939803f4-6952-4ee7-916e-0547bad8185a.png)

위에서 보면 그냥 new Object()라서  
이름도 없이 그냥 Object 형으로 람다 객체가 만들어 졌는데  
이걸 실질적으로 다룰려면 참조변수로서 참조형을 정해야 한다    
  
근데, Object로 받으면 문제가 있다. 일단 참조변수를 담을 수는 있겠지만 max(a,b) 메서드를 호출할 수 없다    
코드에서 보다시피 obj.max에 빨간줄이 그어져 있는 것을 볼 수 있다.  
그러면 어떻게 해야할까?  
이거에 대해서 다음 장에서 알아본다  


## 14-5 함수형 인터페이스
단 하나의 추상 메서드만 선언된 인터페이스    
근데 함수형 인터페이스가 왜 있냐면  
사실 람다식을 다루기 위해서 있는 것이다  
  
일단 함수형 인터페이스는 아래와 같은 것이고...    
```java
@FunctionalInterface
interface MyFunction {
  public abstract int max(int a, int b);
}
```
위에 애너테이션으로 @FunctionalInterface 라고 붙여줘야 한다  
(에러는 안나지만 이렇게 붙여줘야지 올바르게 작성했는지 컴파일러가 체크를 해준다)    
   
이거를 구현하면 아래와 같은 모습인데  
```java
MyFunction f = new MyFunction() {
                  public int max(int a, int b) {
                    return a > b ? a : b;
                  }
                };  

int value = f.max(3,5);
```
이걸 이제 람다식으로 바꿔보자   
  
  
  
### 람다식을 함수형 인터페이스 타임으로 다룰 수 있다  
```java
MyFunction f = (a, b) -> a > b ? a : b;  
int value = f.max(3,5); // 실제로 람다식이 호출됨  
```
이렇게 이제 함수형 인터페이스 덕분에 람다식을 다룰 수 있다  
    
물론   
람다식과 함수형 인터페이스가 맞아 떨어져야 한다.    
매개변수 타입과 반환 타입이 같아야 한다   
  
### 함수형 인터페이스의 사용 예시  

```java
List<String> list = Arrays.asList("abc","aaa","bbb","ddd","aaa");
		
Collections.sort(list, new Comparator<String>() {
  public int compare(String s1, String s2) {
    return s2.compareTo(s1);
  }
});
```
예전에는 이렇게 불필요하게 길게 적었어야 했다   
하지만 함수형 인터페이스를 활용해서  
```java
Collections.sort(list, (s1,s2)->s2.compareTo(s1));
```
이렇게 간결하게 적을 수 있게 됐다    

## 14-6 함수형 인터페이스 타입의 매개변수, 반환타입   
함수형 인터페이스를 매개변수나 반환타입으로 정할 수 있다.  
람다식을 주고받기 위해서 사용하는 것이며, 람다식은 익명이니까 함수형 인터페이스의 메서드 이름에 따르게 된다  

## 14-7 java.util.function 패키지  
자주 사용되는 다양한 함수형 인터페이스를 제공한다   
### 매개변수가 1개인 함수형 인터페이스
![image](https://user-images.githubusercontent.com/101965836/166620264-69e16557-c9fa-418f-9657-7186aae86c86.png)  
Fucntion\<T,R\>에서 R은 Return 타입을 말하고 T는 매개변수 타입을 말한다  
Predicate\<T\>는 생소하니까 아래와 같은 예제 코드를 추가로 적겠다  
```java
Predicate<String> isEmptyStr = s.length()==0;
String s = "";

if(isEmptyStr.test(s))    // if(s.length()==0)
  System.out.println("This is an empty String");
```

### 매개변수가 2개인 함수형 인터페이스  
![image](https://user-images.githubusercontent.com/101965836/166620699-346e4e4c-5361-4fc0-a571-378ce5d8999e.png)  
두 개의 매개변수가 있다고 해서 앞에 접두어로 Bi가 붙는다   
BiSupplier가 없는 이유는 당연히 매개변수가 없는 인터페이스이기 때문이다.  

### 매개변수 타입 = 반환타입 함수형 인터페이스
![image](https://user-images.githubusercontent.com/101965836/166620880-5a4271dc-9456-4608-a3b1-a90c2dafeb4f.png)  

## 14-9 Predicate의 결합  
### and() or() negate()
Predicate가 조건식을 집어넣으면 boolean으로 나오는 건데  
이걸 **default 메서드**인 **and() or() negate()** 로 두 Predicate를 하나로 결합할 수 있다    
  
```
Predicate<Integer> p = i -> i < 100;
Predicate<Integer> q = i -> i < 200;
Predicate<Integer> r = i -> i%2 == 0;
```
이렇게 세가지 p q r이 있을 때  
```
Predicate<Integer> notP = p.negate();
Predicate<Integer> all = notP.and(q).or(r);
Predicate<Integer> all2 = notP.and(q.or(r));
```
이렇게 && || ! 같은 것들을 Predicate로도 할 수 있다   
  
### isEqual()  
```
Predicate<String> p = Predicate.isEqual(str1);
Boolean result = p.test(str2);  // str1과 str2가 같은지 비교한 결과를 반환

// 한줄로 쓰면
boolean result = Predicate.isEqual(str1).test(str2);
```
조금 낯설다. 일단 이렇게 Predicate로 isEqaul() 이라는 스테틱 메서드로 비교할 수 있다 정도 알아두면 되겠다   

### .andThen()
![image](https://user-images.githubusercontent.com/101965836/166625482-d4964ec3-5a08-489e-ba93-9b4ddf0ba6ac.png)  
```
// String -> f -> Integer -> g -> String 으로 이뤄져 있다고 하면

Function<String, String> h = f.andThen(g);
```
이렇게 여러 함수를 하나로 연결할 수 있다   

### 항등함수(identity function)
```
x -> x  
```
이런게 왜 필요함? 이라고 생각이 드는데  
그냥 이런게 있다고만 일단 알아두자  


## 14-11 컬렉션 프레임워크과 함수형 인터페이스  
JDK1.8에 함수형 인터페이스가 들어오면서  
컬렉션 프레임워크에도 변화가 생겼다  
바로, 함수형 인터페이스를 사용하는 메서드들이 추가가 됐다  

### 함수형 인터페이스를 사용하는 컬렉션 프레임워크의 메서드들
![image](https://user-images.githubusercontent.com/101965836/166625944-c7dc3a40-58be-402d-b07d-1e1ee2aa63c6.png)  


## 14-13 메서드 참조(method reference)
람다식을 더 간단히 한 것       
![image](https://user-images.githubusercontent.com/101965836/166628075-d00e02c4-fed6-4fda-b57a-6771ac4be4bd.png)   
  
### (1) static 메서드 참조
```
Integer method(String s) {
  return Integer.parseInt(s);
}

int result = Integer.parseInt("123");
```
이걸 람다식으로 바꾸면  
```
Function<String, Integer> f = (String s) -> Integer.parseInt(s);
```
이걸 다시 또 메서드 참조로 바꾸면  
```
Function<String, Integer> f = Integer::parseInt;
```
이렇게 간단해진다   
  
  
그냥 클래스이름::메서드이름 으로 쓰면 되며  
람다식을 메서드 참조로 더 간단하게 바꾸는 연습을 해야한다    

## 14-14 생성자의 메서드 참조  
### 생성자와 메서드 참조
```java
Supplier<MyClass> s = () -> new MyClass();
```
여기서 앞에 \<MyClass\>는 출력(return) 형이고, s에 저장되는 람다식은 MyClass 객체를 생성해서 반환한다.  
이런 코드를 메서드 참조를 사용해서 간단하게 만들 수 있다    
```java
Supplier<MyClass> s = MyClass::new;
```
이렇게 할 수 있다  
  
### 생성자에 매개변수가 있는 경우  
매개변수가 있는 경우 Function\<매개변수, 출력형식\> 으로 쓰면 된다
```java
// 람다식으로 적으면
Function<Integer, MyClass> s = (i) -> new MyClass(i);
  
// 메서드 참조로 쓰면
Function<Integer, MyClass> s = MyClass::new;
```

### 배열과 메서드 참조  
많이 쓰는 예시로 배열 생성과 길이를 주는 경우가 있다  
배열을 생성 할 때 필요한게 배열 길이가 필요하다  
따라서 아래와 같이 길이를 나타내주는 Integer와 리턴형식인 int\[\]를 써줄 수 있다.  
```java
// 람다식으로 적으면
Function<Integer, int[]> f = x -> new int[x];

// 메서드 참조로 쓰면
Function<Integer, int[]> f2 = int[]::new;
```
  
  
  
## 14-15 스트림(Stream)
스트림이란 다양한 데이터 소스를 표준화된 방법으로 다루기 위한 것이다  
  
예를 들어  
컬랙션 프레임워크는 다양한 자료 구조들(List Set Map)을 같이 다루기 위해서 만든 것인데  
실상은 진정으로 한방에 다룰 수 있도록 통일했다고 보긴 어려웠다  
  
하지만 Stream이 JDK1.8에 나온 이후로 부터  
진정으로 데이터를 통일되게 다룰 수 있게 됐다   

### 스트림의 흐름
```
stream.distinct().limit(5).sorted().forEach(System.out::println)
```
(1) 스트림 만들기  
(2) 중간연산 (0 ~ n번)  
(3) 최종연산 (0 ~ 1번)  
  
자료들 -> (1) Stream 만들기 -> (2) 중간 연산 -> (3) 최종 연산 -> 결과   

### 스트림의 뜻  
강 물줄기를 스트림이라 하는 것 처럼  
데이터들의 연속적인 흐름이라서 stream 이라고 부른다고 한다  

### 스트림의 특징
#### (1) 스트림은 데이터 원본을 건드리지 않고, 읽기만 한다  
원본 데이터는 메서드 내에서 읽기만 이뤄지며, return으로 메서드 output을 줄 뿐이다  
#### (2) 스트림은 Iterator처럼 일회용이다 
필요하면 다시 스트림을 생성해야 한다.
#### (3) 최종 연산 전까지 중간연산이 수행되지 않는다 - 지연된 연산
```java
IntStream intst = new Random().ints(1,46);
intst.distinct().limit(6).sorted()
     .forEach(i->System.out.print(i+","));
```
#### (4) 내부 반복으로 작업을 처리한다  
#### (5) 스트림의 작업을 병렬로 처리한다 - 병렬스트림  
여러 개의 쓰레드가 나눠서 작업을 병렬로 처리한다  
```
int sum = strStream.parallel()
              .mapToInt( s -> s.length()).sum();
```
parallel()을 해주면 병렬 스트림으로 전환한다     

#### (6) 기본형 스트림
**IntStream, LongStream, DoubleStream ...**   
오토박싱과 언박싱의 비효율이 제거된다(Stream\<Integer> 대신 IntStream을 사용)  
숫자와 관련된 유용한 메서드를 Stream\<T>보다 더 많이 제공한다  
물론 데이터 소스의 타입이 기본형일때만 쓸 수 있다    

## 14-17 스트림 만들기 - 컬렉션
앞서 말했을 스트림 만들기는  
(1) 스트림 생성 (2) 중간연산 (3) 최종연산  
으로 이뤄진다고 했다  

### Collection인터페이스의 stream()으로 컬렉션을 스트림으로 변환
```
Stream<E> stream()
```
```java
List<Integer> list = Arrays.asList(1,2,3,4,5);
Stream<Integer> intStream = list.stream(); // list를 스트림으로 변환

// 스트림의 모든 요소 출력
intStream.forEach(System.out::print);    // 12345 출력
// intStream.forEach(System.out::print); // 에러. 스트림이 이미 닫혔기 때문  
```

## 14-18 스트림 만들기 - 배열
### 객체 배열로부터 스트림 만들기    
![image](https://user-images.githubusercontent.com/101965836/166658999-edeb3353-60d8-4be4-82dc-cb7c259eb96e.png)    
![image](https://user-images.githubusercontent.com/101965836/166659057-8df6f2e9-b748-4f15-a503-f36292c2b014.png)   

### 기본형 배열로부터 스트림 만들기
![image](https://user-images.githubusercontent.com/101965836/166659312-c36824c4-5feb-4f35-a428-9d707ad4402a.png)  

## 14-19 스트림 만들기 - 난수
### 난수를 요소로 갖는 스트림 생성하기  
![image](https://user-images.githubusercontent.com/101965836/166661404-20892f66-72ec-4ed4-97c9-40f52fee09a1.png)
위에는 난수 스트림 생성하는 예제 코드이고, 아래는 형별 난수 생성 스트림의 값의 범위이다  
  
스트림에는 유한 스트림과 무한 스트림 두 가지가 있는데, 난수를 생성하는 이 스트림은 무한 스트림에 해당한다  
즉 놔두면 미친듯이 계속 무한하게 값을 생성하므로,  
limit(5) 같이 딱 5개만 출력하도록 짤라줘야 한다  
  
아니면 처음부터 .ints(5) 처럼 스트림 크기를 지정해줄 수 있다  
  
![image](https://user-images.githubusercontent.com/101965836/166661661-5c9d4de4-bda3-458d-8449-aef0ad9a41ed.png)  
지정된 범위의 난수를 요소로 갖는 스트림을 생성하는 메서드들도 위와 같이 있다  
  
## 14-20 스트림 만들기 - 특정 범위의 정수  
![image](https://user-images.githubusercontent.com/101965836/166662398-c7162b95-1a46-4c87-81da-5df96d079e27.png)  
1부터 5까지 생성 같은 식으로 특정 범위의 정수를 생성하는 것  
closed 붙은건 end 값도 포함하는 매서드다  

## 14-21 스트림 만들기 - 람다식 iterate(), generate()
람다식을 갖고 스트림을 만드는 것들  
![image](https://user-images.githubusercontent.com/101965836/166664181-793962bd-98ed-42a6-b68d-1486943f7b7f.png)  
이것들도 무한 스트림이다   

### iterate()
이전 요소를 seed로 해서 다음 요소를 계산한다  
![image](https://user-images.githubusercontent.com/101965836/166664420-01d1f75f-f902-4e84-a8a9-8d4bc5fbcb14.png)  

### generate()
seed를 사용하지 않는다  
![image](https://user-images.githubusercontent.com/101965836/166664483-fc0b3805-518f-49b5-ad15-b202a931d57f.png)  
위 코드들은 각각    
randomStream은 계속 랜덤 값을 출력하고    
oneStream은 계속 1을 출력한다   

## 14-22 스트림 만들기 - 파일과 빈 스트림  
### 파일을 소스로 하는 스트림 생성하기  
![image](https://user-images.githubusercontent.com/101965836/166665278-a6b7c7bf-8452-4324-b0dd-42f876de0ad3.png)  

![image](https://user-images.githubusercontent.com/101965836/166665303-46dc7801-19f8-4a4f-91cd-20a00dd40fc2.png)  

### 비어있는 스트림 생성하기  
```
Stream emptyStream = Stream.empty(); // empty()는 빈 스트림을 생성  
long count = emptyStream.count(); // count 값은 0
```
이런게 있다는 정도만 알아두면 된다  


## 14-23 스트림의 연산  
### 스트림이 제공하는 기능 - 중간 연산과 최종 연산  
![image](https://user-images.githubusercontent.com/101965836/166677172-68206a89-1210-41ff-92fd-a4753fa65624.png)  

중간연산 : 연산결과가 스트림인 연산. 반복적으로 적용가능  
최종연산 : 연산결과가 스트림이 아닌 연산. 단 한번만 적용가능(스트림의 요소를 소모)  

## 14-24 중간 연산
![image](https://user-images.githubusercontent.com/101965836/166678942-04b7c9c8-4ca4-48ce-887c-afcb7a1a6cbe.png)  
  
distinct : 1,1,2,3,3,3,4,5 이렇게 있으면 1,2,3,4,5 만 딱 남기도록 중복 제거     
skip : 스트림의 일부를 건너뛰는것. 1,2,3,4,5,6,7,8 이 원래 값이라면 skip(3) 하면 4,5,6,7,8이 된다.      
peek : forEach랑 비슷하고, 작업 중간에 확인할 때 쓴다고 한다. 나중에 다시 배움    
map에 관한 것도 다음 강의에서 본다    

## 14-25 최종 연산
![image](https://user-images.githubusercontent.com/101965836/166679387-368be8b3-97a6-43d8-a745-7c56b5dc7154.png)   
forEachOrdered는 병렬스트림일때 작업의 순서를 유지해서 출력하도록 해준다  
max와 min은 전렬 기준을 따지는 Comparator가 들어간다  
  
findAny는 병렬 처리할 때 findFirst는 직렬일때 사용한다  
또 findAny와 findFirst는 filter와 같이 쓰여서 조건에 맞는 요소를 아무거나 하나 또는 첫 번째 요소를 반환하는데 쓰인다  
Optional은 래퍼 클래스로, 어떤 타입의 값을 감싸고 있는 것이며, 작업 결과를 객체에 담아서 주는 것이다  
객체에 담아서 주면, 예를 들어 작업 결과가 null 일 경우에도, null을 줘버리면 예외처리가 나거나 하기 때문에, 그냥 객체에 감싸서 주는게 일관된 결과를 볼 수 있으므로 장점이 있다  
  
allMatch, anyMatch, noneMatch는 주어진 조건을 만족시키는지 아닌지를 확인한다   
  
toArray는 () 안에다가 어떤 generator를 주면 특정 오브젝트로 받을 수 있다  
  
reduce와 collect가 이제 있는데, 이게 최종 연산의 핵심이다  
다른 것들은 쉽게 이해할 수 있는데, reduce와 collect는 좀 설명이 필요하므로 뒤에 더 자세히 다룬다    

## 14-26 \[중간연산\] 자르기 - skip() limit()  

```
Stream<T> skip(long n)          // 앞에서 부터 n개 짤라냄
Stream<T> limit(long maxSize)   // maxSize 이후의 요소를 잘라냄
```

```java
IntStream intStream = IntStream.rangeClosed(1,10);      // 12345678910
intStream.skip(3).limit(5).forEach(System.out::print);  //    45678
```

## 14-27 \[중간연산\] 걸러내기 - filter() distinct()
```
Stream<T> filter(Predicate<? super T> predicate)  // 조건에 맞지 않는 요소 제거
Stream<T> distinct()  // 중복제거
```

![image](https://user-images.githubusercontent.com/101965836/166681116-fa49c4ad-5ecf-436e-9456-b8347f56c470.png)  
filter는 여러번 써도 되고, 논리 연산으로 묶어도 된다  

## 14-28 \[중간연산\] 정렬하기 - sorted()
```
Stream<T> sorted()  // 기본 정렬로 정렬
Stream<T> sorted(Comparator<? super T> comparator) // comparator에 따라 정렬
```
![image](https://user-images.githubusercontent.com/101965836/166681294-e5296abb-8a2d-4a45-a543-2f011eca9054.png)

## 14-29 Comparator의 메서드  
Comparator의 comparing()으로 정렬 기준을 제공한다     
     
![image](https://user-images.githubusercontent.com/101965836/166688121-729053a8-f243-4458-980a-99c3ac1166b8.png)    
여기서 매개변수에 key라는 말이 들어가는데  
복잡할 거 없이, 정렬의 기준이 되는 값을 말한다   
그러므로 Function\<T,U\> keyExtractor는 "키를 뽑아주는놈을 달라"는 소리인거고  
Comparator\<U\> keyComparator는 "혹시 경우에 따라서, 비교 기준도 달라"는 말이다  
  
예를 들어    
각 학생을 구현하기 위해 만든 학생 클래스가 있다 해보자  
여기서 반별로 학생들을 정렬하려면,   
(1) 학생 객체에서 반을 뜻하는 값을 얻어오는 방법이 뭔지 알려줘야 하고 (반 value를 return해주는 메서드)  
(2) 앞서 얻은 값을, 어떤 기준으로 정렬할지 알려줘야 한다  
  
근데 여기서 만약에  
학생 클래스가 Comparable 이라는 인터페이스를 구현하여 compareTo() 메서드를 구현한다면  
정렬 기준을 알려주는 (2)는 적지 않아도 된다.  
  
아래는 위의 예시를 구현한 코드이며, 예제14-5에서 볼 수 있다  
```java
studentStream.sorted(Comparator.comparing(Student::getBan) // 반별 정렬
		 	.thenComparing(Comparator.naturalOrder()))     	// 기본 정렬
			.forEach(System.out::println);
```

## 14-30 \[중간연산\] 요소 변환하기 - map()  
```
Stream<R> map(Function<? super T,? extends R> mapper)
```
그냥 딱   
Stream\<T\> 형식을 Stream\<R\> 형식으로 바꾸는 것이다    
![image](https://user-images.githubusercontent.com/101965836/166691827-5373e05e-5daf-479e-a289-9fedaf4ff5e7.png)   
위 예시는 어떤 내용의 코드냐면   
![image](https://user-images.githubusercontent.com/101965836/166692307-2aa4ca02-9dbc-499a-8312-ee061544c5da.png)  
File 형식 스트림으로 먼저 파일들을 읽어온다   
그 다음, 파일 이름만 갖고있는 Stream으로 바꾸기 위해서   
File\:\:getName으로 이름을 추출하면 됩니다 라고 map에다가 알려주고, map으로 String 형식으로 변환한다  
  
또 다른 예시를 보면  
아래 코드는 파일 스트림에서 파일 확장자를 중복없이 뽑아내는 코드이다  
![image](https://user-images.githubusercontent.com/101965836/166692476-19aeda4f-1cb8-4c0a-8d95-9f754e2c4b9f.png)  
코드 흐름을 풀어서 간략히 설명하면    
파일 이름 String으로 변환 -> 필터로 확장자 없는 것들 제외 -> substring으로 abc.txt라 치면 . 다음 t부터 끝까지만 남김 -> toUpperCase로 대문자로 전환 -> 중복제거 -> 출력   
이렇게 된다.  
여기서 스트림 형 변환 없이 String 형식에서 String 형식으로 가는데에도 map을 쓰는 것을 볼 수 있는데  
이는 각 요소에다가 어떤 매서드를 적용하는 용도로 쓴 것이다  

## 14-32 \[중간연산\] 스트림 소모하지 않고 출력 - peek()  
![image](https://user-images.githubusercontent.com/101965836/166698854-70934857-dc71-41dd-aa71-fc26b181cd57.png)   
peek은 forEach랑 동작이 똑같은데, 중간중간에 요소들이 어떤 상태인지 확인할 때 쓴다.   
   
## 14-33 \[중간연산\] "스트림의 스트림"을 스트림으로 변환 - flatMap()   
### map()을 썼을때 문제가 발생하는 예시
![image](https://user-images.githubusercontent.com/101965836/166699070-90296232-ec6a-4761-adc6-547948d77b5e.png)   
![image](https://user-images.githubusercontent.com/101965836/166700123-a74ce629-0343-49b3-aba7-fceec8bf69a9.png)  
위에 있는 strArrStrm은 문자열 배열이고, 아래에서 map은 문자열 배열을 스트림으로 바꾸는 작업을 한다  
근데 이렇게 하면 두 번째 strStrStrm은 Stream\<Stream\<String\>\>이 된다  
이게 무슨 말인지 아래 그림을 보자  
  
![image](https://user-images.githubusercontent.com/101965836/166700580-8da9b0fe-b8f2-4129-b25f-f8323c200d39.png)  
map(Arrays::stream)으로 하면, Array들의 요소를 Stream으로 바꾸는 게 아니라, Array 통째로 Stream으로 바꿔버리기 때문에  
각 문자열 배열마다 묶여서 Stream으로 되어 버리는 것이다  
  
따라서 이 문제를 해결하고자 flatMap()을 쓴다  
### flatMap() 사용   
![image](https://user-images.githubusercontent.com/101965836/166701964-f7662f9e-39a6-420e-9f4a-b5ec6f98fb1f.png)  
여러개의 문자열 배열을 하나의 문자열 배열로 바꿀 수 있게 된다.    
    
물론 flatMap 안쓰고 그냥 최종연산하고 배열 다 풀고 다시 만들어서 하면 되는거 아니냐? 라고 할 수 있는데  
당연히 중간연산에 이런 게 있으면 간결해지고 좋으니까 쓰는거다  

  
## 14-35 Optional\<T\>
Optional\<T>는 T 타입 객체의 래퍼클래스이다.  
```java
public final class Optional<T> {
  private final T value;
    ...
}
```
이런식으로 T타입 value를 Optional이란 래퍼클래스로 감싼것이다  
value에는 우리가 저장할 값이 들어가는데 그 밖을 Optional로 감싼형태이다  
value에는 T타입의 어떠한 값도 들어갈 수 있으며, null도 들어갈 수 있다  

### 그러면 이걸 왜 쓰는가?  
(1) Null을 직접 다루는 것은 위험하다  
NullPointException이 발생할 수 있으므로, 철저히 예외처리를 해주지 않는 이상은 위험하다  
(2) null 체크  
앞서 말했듯 철저히 예외처리를 하다보면, if문이 계속 길게 늘어지고 지저분해진다  
예를 들어 result.toString() 이라고 했는데 result가 null이면 NullPointException이 발생하니 예외를 체크해줘야 한다  
근데 if(result!=null) { ... } 이런식으로 다 일일이 들어가면 너무 지저분해지니까  
이를 해결하기위해 나온 게 Optional이라는 래퍼 클래스이다  
  
  
### 래퍼 클래스로 감싸면 왜 null 문제가 안생기나요?  
![image](https://user-images.githubusercontent.com/101965836/166853616-e06ca334-511a-4372-ac0c-9caec73078dc.png)  
위에 result는 그냥 값을 담는 형태이고  
아래의 result는 optional 객체를 이용해서 value 위치를 참조하고, value에다가 값을 담는 것이다  
위에 있는 경우에는 직접 null이 떠버릴 수 있어서 에러가 날 수 있는데  
아래의 경우에는 간접적으로 다루니까 result를 쓸 때 에러가 나지는 않는다  

## 14-36 Optional\<T> 객체 생성하기  
![image](https://user-images.githubusercontent.com/101965836/166853876-02c4f296-f778-464e-a931-06ee42540bfe.png)   
    
Optional 클래스의 static 메서드인 .of를 쓰면 생성할 수 있다.  

### null이 될 수 있는 값 대신, 빈 Optional\<T> 객체를 사용하자  
```
Optional<String> optVal = null; // 바람직하지 않음
Optional<String> optVal = Optional.<String>empty(); // 빈 객체로 초기화. empty앞에 <String>은 생략가능
```
empty 쓰는 이유가 당연한게 앞서 null로 직접 다루면 안좋다는 이유랑 똑같다  

## 14-37 Optional\<T> 객체의 값 가져오기
#### get() orElse() orElseGet() orElseThrow()
![image](https://user-images.githubusercontent.com/101965836/166854902-184ab854-7a3e-4f34-ad4f-3c8c1313b2c3.png)  
get()은 null일때 예외가 발생해서 잘 안쓰고  
.orElse()는 null일때 대체값을 ()에 적어서 값을 갖고 오기 때문에 .orElse()를 많이 쓴다  
또는 대체값에 람다식을 사용해서 orElse랑 같은 동작을 할 수 있는 orElseGet을 쓰기도 한다   
마지막 orElseThrow는 예외 종류를 지정 가능하며, 위 코드로 널포인터예외로 메서드참조 넘기면 .get()이랑 똑같이 동작한다  
  
### isPresent() 
Optional객체에 값이 있으면 true, null이면 false  
```java
if(Optional.ofNullable(str).isPresent()) {
  System.out.println(str);
}
```
근데 여기서 if 문 들어가니까 여전히 지저분하다  
따라서 ifPresent를 사용할 수 있다  
  
### ifPresent()
isPresent + if문 이라고 보면 된다   
null이 아닐때만 () 안의 내용을 수행한다  
```java
Optional.ofNullable(str).ifPresent(System.out::println);
```
  
## 14-38 OptionalInt, OptionalLong, OptionalDouble  
기본형 값을 감싸는 래퍼클래스인데  
그냥 Optional로 써도 되지만, 성능때문에 위의 기본형을 위한 전용 Optional을 쓴다  

### OptionalInt 값 가져오기
![image](https://user-images.githubusercontent.com/101965836/166856050-aa5c2520-6757-4993-9408-4a14670c7a7a.png)  
    
### 빈 Optional객체와의 비교  
```java
OptionalInt opt = OptionalInt.of(0);
OptionalInt opt2 = OptionalInt.empty();
```
위 두 경우를 구별 가능할까?   
기본형 int는 값이 지정되지 않으면 default로 0이 되는데  
그러면 0을 넣는것과 empty가 같은 value를 가지지 않을까?  
  
이를 구별하기 위해서 OptionalInt 내부는 아래와 같이 이뤄져있다   
```java
public final class OptionalInt { 
  ...
  private final boolean isPresent;
  private final int value;
  ...
}
```
여기서 boolean 타입인 isPresent가 empty인지 아닌지를 알려준다    
  
이제 위에서 정의한 opt와 opt2를 비교해보면  
```
System.out.println(opt.isPresent());  // true
System.out.println(opt2.isPresent()); // false
System.out.println(opt.equals(opt2)); // false  
```
이렇게 optional은 isPresent까지 같아야 equals 메서드에서 같다고 판별한다  

## 14-40 스트림의 최종연산 - forEach()
스트림의 최종연산은 중간연산과 달리 스트림이 닫히기 때문에 더이상 해당 스트림을 사용할 수 없게된다  

### forEach() forEachOrdered()  
forEachOrdered()는 병렬스트림을 쓸 때 사용한다  
```
IntStream.range(1,10).forEach(System.out::print); // 123456789

IntStream.range(1,10).parallel().forEach(System.out::print); // 683945172 순서가 막 뒤죽박죽으로 나온다
```
위처럼 parallel() 했는데 forEach 해버리면 순서가 섞여버리므로   
아래와 같이 forEachOrdered()를 해주면  
```
IntStream.range(1,10).parallel().forEachOrdered(System.out::print); // 123456789
```
깔끔하게 순서대로 나온다  
  
기본적으로 스트림은 직렬인데 .sequential()로 중간연산 붙여줄 수도 있다   

### 조건 검사(1) - allMatch() anyMatch() noneMatch()
![image](https://user-images.githubusercontent.com/101965836/166857913-f912b297-150a-482e-a01b-18783c211b08.png)  
Predicate로 조건식을 받아서 boolean으로 반환한다  
예를 들어 학생들이 모두 합격 점수를 넘었는지는 allMatch로 true/false 판단할 수 있고  
학생 중 한 명이라도 100점이 있다면 anyMatch로 true/false 판단할 수 있다  
#### 사용방법
![image](https://user-images.githubusercontent.com/101965836/166858178-20a2a9b1-c165-4015-a0f8-eb3fde9b43cf.png)  
  
  
### 조건 검사(2) - findFirst() findAny()
![image](https://user-images.githubusercontent.com/101965836/166858068-304332ab-90e4-489e-8c2d-2058080d9302.png)  
findFirst()는 조건에 맞는 첫 번째 요소를 반환하고  
findAny()는 조건에 맞는 아무 요소를 반환한다  
또한, 결과가 null일 수 있어서 Optional로 감싸서 반환한다  

#### 사용방법
![image](https://user-images.githubusercontent.com/101965836/166858150-cc326178-b15f-4af7-aeb5-56853d70e2e9.png)  
filter와 같이 이렇게 쓴다  
앞서 조건에 맞는 요소를 반환한다고 설명했는데, 사실은 앞에서 중간연산인 filter로 조건을 줘서 추려내고, 그 다음 최종 연산인 findFirst나 findAny로 값을 추출해내야 한다  

### 가장 중요한 최종연산 - reduce()  
스트림의 요소를 하나씩 줄여가며 누적연산을 수행한다  
누적 연산은 accumulator가 수행한다    
![image](https://user-images.githubusercontent.com/101965836/166858567-3e28ff9a-573a-4c20-b444-022fbef279c5.png)    
매개변수 설명   
![image](https://user-images.githubusercontent.com/101965836/166858588-734ab598-6d1d-48ee-97a7-0aca1e941bb1.png)  
이 중에서 identity와 accumulator가 핵심이다    
아래의 사용 방법을 보면 쉽게 이해가 된다  
  
#### 사용방법
![image](https://user-images.githubusercontent.com/101965836/166859009-7083546a-e658-4544-9eb6-ce4b931e4881.png)   
accumulator는 이렇게 람다식으로 동작하고, (a,b) 에서 a에 값이 축적되고 b에는 해당 반복회차에서 스트림에서 얻은 값이 된다  

## 14-45 collect()와 Collectors
collect()는 Collector를 매개변수로 하는 스트림의 최종연산이다  
reduce()와 collect()의 차이는  
collect는 그룹별 리듀싱이 가능하고, reduce는 전체에 대한 리듀싱이다  

### collect 정의 부분  
![image](https://user-images.githubusercontent.com/101965836/166865684-1157101a-1d4d-4080-a06a-29507a481fad.png)  
Collector 클래스로 구현한 객체collector를 넘기면 된다.  
일단 이거 빤히 쳐다보면서 이해할 생각 할 필요없고, 그냥 기록 순서에 맞추기 위해서 여기다가 정의부분 캡쳐해둔거니까  
아래에 Collector 인터페이스와 Collector 클래스에 어떤 구현된 메서드들이 있는지 보고, 예제 코드도 쫌 보고나서 이 정의부분 보면 그냥 별 거 아니구나 하고 쉽게 이해할 수 있다  
그러니 여기부분 빤히 쳐다볼필요없으므로, 일단 아래 부분 보고 다시 보자    
  
### Collector 인터페이스  
수집(collect)에 필요한 메서드를 정의해 놓은 인터페이스이다  
![image](https://user-images.githubusercontent.com/101965836/166864984-0a4290e4-6a6c-48bd-ae8a-e025c61a3581.png)  
 
combiner는 병렬 작업을 했을 때 쓰레드가 각각 한걸 합치는거고 finisher는 말그대로 최종적으로 어떻게 변환할지이다  
핵심은 supplier와 accumulator이다  
  
  
이전에 reduce는 (identity, accumulator) 두 가지가 각각 초기값과 누적 수행 작업을 정의했었다  
마찬가지로 Collector는 누적할곳인 supplier와 누적 작업을 정의하는 accumulator로 나뉜다  
복잡해 보이지만 그냥 reduce랑 똑같다  
  
### Collectors 클래스
Collector 인터페이스를 구현한 다양한 기능을 모아둔 클래스이다    
직접 구현할 일이 거의 없고, 그냥 Collectors 클래스를 가져다가 쓰기만 하면 된다    
    
![image](https://user-images.githubusercontent.com/101965836/166865567-a4273c84-5cbd-4800-8795-2c86052c54a7.png)   
   
이것들 쓰는 방법만 알면 끝.  
  
## 14-46 스트림을 컬렉션, 배열로 변환   
### 스트림을 컬렉션으로 변환 - toList() toSet() toMap() toCollection()   
![image](https://user-images.githubusercontent.com/101965836/166865907-a2ae8dd6-c7a2-483a-951a-daa31452dc7d.png)   
map에 담을려면 key와 value를 정해줘야 한다. 따라서 Collectors.toMap(key 람다식, value 람다식) 으로 넘겨준다   

### 스트림을 배열로 변환 - toArray()  
![image](https://user-images.githubusercontent.com/101965836/166866267-8015dc17-91bc-4201-917d-a9b05953da86.png)  
stream에 있는 메서드이다   
매개변수 없는거는 Object 배열로 반환하니까 Student\[] 참조 객체로 받을 수 없다. 즉 자동형변환이 안된다는 뜻   
  
## 14-47 스트림의 통계
### 스트림의 통계정보 제공 - counting() summingInt() maxBy() minBy() ...
```java
long count = studentStream.count();
long count = studentStream.collect(Collectors.counting());
```
근데 그냥 count  쓰면 되는데 왜 Collectors 쓰는가? -> Collector는 그룹별로 나눠서 counting 할 수 있기 때문이다.   
예를 들면 남학생 총점 여학생 총점을 따로 알 수 있다  
이에 대해서는 나중에 배운다    

```java
long totalScore = stuStream.mapToInt(Student::getTotalScore).sum();
long totalScore = stuStream.collect(summingInt(Student::getTotalScore));
```

```java
OptionalInt topScore = studentStream.mapToInt(Student::getTotalScore).max(); // 최댓값
Optional<Student> topStudent = stuStream
	.max(Comparator.comparingInt(Student::getTotalScore));
Optional<Student> topStudent = stuStream
	.collect(maxBy(Comparator.comparingInt(Student::getTotalScore)));
```
세 방식 모두 똑같다. 총점이 제일 높은 학생의 점수를 topScore에 담은 것이다   

## 14-48 스트림을 리듀싱 - reducing()  
Collectors 가 제공하는 reducing() 이라는 메서드이다  
하는 일은 reduce()와 똑같지만, 계속 말했듯 reducing()은 Collectors에 있으니 그룹별로 reducing이 가능하다  
  
### 스트림을 리듀싱 - reducing()
![image](https://user-images.githubusercontent.com/101965836/166866920-0d9d4458-035d-417f-a26f-80b303014b00.png)   
Collectors.reducing()  
#### 사용 방법
```java
// (1) 인자 한 개 짜리 : 어떤 기준으로 누적하는지 넘기기 
IntStream intStream = new Random().ints(1,46).distinct().limit(6);

OptionalInt       max = intStream.reduce(Integer::max);  // 전체 리듀싱
Optional<Integer> max = intStream.boxed().collect(reducing(Integer::max)); // 그룹별 리듀싱 가능
```
여기서 boxed는   
long, int, double같은 기본형으로 스트림이 만들어지면, 특정 메서드들이 안되는 경우가 있다  
따라서 이럴때는 boxed로 해서 /(기본형) -> { return 래핑된 기본형; } 기능을 하는 boxed를 사용한다   

```java
// (2) 인자 두 개 짜리 : 초기값, 누적 방식(람다식 부분)
long sum = intStream.reduce(0, (a,b) -> a+b);
long sum = intStream.boxed().collect(reducing(0, (a,b) -> a+b));
```
여기서 0은 초기값이다  

```java
// (3) 인자 세 개 짜리 : 초기값, map 변환 작업, 누적 방식
int grandTotal = stuStream.map(Student::getTotalScore).reduce(0, Integer::sum);
int grandTotal = stuStream.collect(reducing(0, Student::getTotalScore, Integer::sum));
```

### 문자열 스트림의 요소를 모두 연결 - joining()  
Collectors.joining()    
![image](https://user-images.githubusercontent.com/101965836/166868442-046e8e86-f709-457b-8ab1-908db9eb1d8a.png)  
학생 객체에서 이름을 뽑아낸다음(map()) , collect로 Joining()  
3번째에 "\[", "\]"는 앞 뒤를 \[ 김자바, 이자바, 박자바 , ... , 최자바 \] 이렇게 감싸주는 것  

## 14-50 스트림의 그룹화와 분할
분할 방식에는 Collectors 안에 partitioningBy()와 groupingBy() 두 가지 메서드가 있다.  
Collectors.partitioningBy()는 스트림을 2분할 한다  
Collectors.groupingBy()는 스트림을 n분할 한다  

## 14-51 스트림의 분할 - partitioningBy()
스트림의 요소를 2분할  
![image](https://user-images.githubusercontent.com/101965836/166868892-878b6e96-2ee9-4336-8e3d-5eae1987d031.png)  
predicate로 true false로 분할해서 나누기 때문에 2분할이 된다  

#### 사용방법 1 - 단순 2분할
![image](https://user-images.githubusercontent.com/101965836/166869311-e71d6bfa-36da-4e7e-afcc-8ff0a1747ac3.png)

Map의 key를 true로 주느냐 false로 주느냐로 2분할 한다.  
Student::isMale 의 결과가 true/false임에 따라서    
  
|key|value|  
|---|---|  
|true|List\<Student\> 남학생 저장하는 list|  
|false|List\<Student\> 여학생 저장하는 list|    
  
이렇게 map이 만들어 진다  

#### 사용방법 2 - 2분할 + 통계 (counting)
![image](https://user-images.githubusercontent.com/101965836/166869586-0ba642ef-ff7b-4976-8493-7a7a1c8d6c86.png)  
Collectors.counting() 메서드를 사용해서 통계정보를 넣었다. 이렇게 하면  
  
|key|value|  
|---|---|  
|true|남학생 수|  
|false|여학생 수|   
  
이렇게 Map에 저장된다  

#### 사용방법 3 - 2분할 + 통계 (maxBy)
![image](https://user-images.githubusercontent.com/101965836/166869767-9cd4525d-9325-42a1-ad51-b9cb0fdb6023.png)  
  
#### 사용방법 4 - 다중 분할 (2분할 여러번)
![image](https://user-images.githubusercontent.com/101965836/166869860-a76b54fe-0cc8-4327-b5c8-335fca1231a5.png)  
map에 map이 또 들어간 것이다   
![image](https://user-images.githubusercontent.com/101965836/166870662-b42d152f-42aa-49ab-b4df-7bd3084b65dd.png)  
이런 구조이다  


## 14-53 스트림의 그룹화 - groupingBy()  
스트림의 요소를 n분할 해서 그룹화하는 메서드이다      
![image](https://user-images.githubusercontent.com/101965836/166870798-06363547-ae88-42f0-9aaf-ed64943d05ef.png)  
  
#### 사용방법 1 
![image](https://user-images.githubusercontent.com/101965836/166870785-bfbac303-4b13-4e64-9c3a-1c5950bbdfc2.png)   
리턴된 map의 key는 1반 2반 3반 같은 식으로 Student::getBan의 리턴 값에 따른다    
  
  
#### 사용방법 2  
![image](https://user-images.githubusercontent.com/101965836/166871035-42fdd025-b86b-44e7-81b2-d56f159fe9ba.png)  
이것도 앞서 partitioningBy의 사용방법 4의 결과와 비슷하게 다중 그룹화 된다.    


#### 사용방법 3 - 좀 더 복잡하고 다양하게  
![image](https://user-images.githubusercontent.com/101965836/166871151-eaf324f2-eda7-4b60-b0bd-5c4e316e0c11.png)  
이렇게 mapping()을 써서 더 복잡하게 나눈다  

사용방법 3은 이렇게도 할 수 있겠구나 라고 참고로 알아두면 되겠다  
    
    
## 14-55 스트림의 변환 정리  
![image](https://user-images.githubusercontent.com/101965836/166871351-7085203d-2d5d-44f9-8745-7967112950b9.png)  
![image](https://user-images.githubusercontent.com/101965836/166871390-255ddc56-a863-49e5-8a72-7e6d29f5ab64.png)  
  
  
<br><br><br>
  
  ---
  
<br><br><br>  
  
# 15 입출력

## 15-1 입출력(I/O)와 스트림(stream)
(여기서 stream은 14장에서 데이터를 하나로 묶어서 다루기 위해 만들어진 Stream 클래스와는 다르다)  
### I/O  
Input과 Output의 약자, 키보드 입력같은 외부 입력이나 System.out.println() 같은 화면 출력 등이 있다.  
### 스트림(stream)
입출력을 수행하려면, 어느 한쪽에서 다른 쪽으로 데이터를 전송할 수 있는 무언가가 필요하다. 이것을 stream이라고 한다.  
스트림은 데이터 흐름이 물줄기처럼 졸졸졸 한방향으로 흐른다 해서 붙여진 이름이다. 물이 한방향으로 흐르는 것처럼 스트림도 데이터를 단방향통신으로 보내기 떄문이다.   
즉, 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다.  
  
![image](https://user-images.githubusercontent.com/101965836/167071657-624f5823-295e-48de-bdc2-c3c3f4fd7576.png)  
  
  
## 15-2 바이트 기반 스트림  
바이트 기반 스트림은 데이터를 바이트(byte) 단위로 주고 받는다  
|입력스트림|출력스트림|입출력 대상|
|---|---|---|
|FileInputStream|FileOutputStream|파일|
|ByteArrayInputStream|ByteArrayOutputStream|메모리(byte배열)|
|PipedInputStream|PipedOutputStream|프로세스(프로세스간의 통신|
|AudioInputStream|AudioOutputStream|오디오장치|
  
위와 같이 여러 종류 입출력 스트림이 있다.  
입출력 하고자 하는 파일 종류에 따라서 해당 스트림을 선택해 사용하면 된다   
위 입출력 스트림들은 모두 각각 InputStream 또는 OutputStream의 자손이며, 각각 읽고 쓰는데 필요한 추상 메서드를 알맞게 구현해 놓았다  
  
  
|InputStream|OutputStream|
|---|---|
|abstract int read()|abstract void write(int b)|
|int read(byte[] b)|void write(byte[] b)|
|int read(byte[] b, int off, int len)|void write(byte[] b, int off, int len)|  
  
위의 표에 나온 메서드의 사용법만 잘 알아도, 데이터를 읽고 쓰는 간단한 작업정도는 문제없이 할 수 있다  
  
## 15-3 보조 스트림  
### 보조 스트림의 존재 의의
바로 전 15-2에서 언급한 스트림들 이외에도, 기능을 보완하기 위한 보조 스트림들이 있다.  
보조 스트림은 데이터를 입출력할 수는 없지만, 새로운 기능을 추가하거나 기존 스트림의 기능을 향상시키는 역할을 한다.   
따라서 먼저 스트림을 생성한 뒤에 보조 스트림을 생성해야 한다  

### 보조 스트림 생성 예시
```java
// (1) 기반 스트림을 생성
FileInputStream fis = new FileInputStream("test.txt");

// (2) 기반 스트림을 이용해서 보조 스트림을 생성한다   
BufferedInputStream bis = new BufferedInputStream(fis);
bis.read();  // 보조 스트림인 BufferedInputStream으로부터 데이터를 읽는다  
```  
코드상으로는 마치 BufferedInputStream인 bis가 .read() 하는 것 처럼 보이지만   
사실은 fis를 기반으로 생성한 것이며, 내부적으로는 fis가 파일을 읽어오고, bis는 버퍼기능을 제공할 뿐이다  
이렇게 사용하는 이유는  
먼저 버퍼를 사용하는 이유는, 버퍼가 있어야 파일을 더 빨리 읽어올 수 있기 때문이고,  
보조 스트림을 이용하는 이유는, 앞서 말했듯 새로운 기능이나 향상된 기능을 사용하기 위해 덧붙여 놓았다고 생각하면 된다  

### 보조 스트림의 종류
![image](https://user-images.githubusercontent.com/101965836/167073105-646d003c-a778-4ba2-95b7-060644d0b5ef.png)  


## 15-4 문자기반 스트림
지금까지 알아본 스트림은 모두 byte 기반 스트림이다.  
### 문자기반 스트림의 필요성  
|C언어의 char형|java의 char형|
|---|---|
|char == 1byte|char == 2byte|
  
따라서 java에서는 한 문자가 2byte이기 때문에  
byte 단위로 스트림을 입출력하면 딱 떨어지지 않아서 처리에 어려움이 있다  
  
그러므로 이를 보완하고자 문자기반 스트림을 따로 두었다  

## 15-5 바이트 기반 stream VS 문자 기반 stream 
InputStream -> Reader    
OutputStream -> Writer    
  
### 스트림 종류
![image](https://user-images.githubusercontent.com/101965836/167073514-61e85ad8-5436-4cf7-9fe9-2da5f5e5dfb4.png)   
### 보조스트림 종류
![image](https://user-images.githubusercontent.com/101965836/167073572-b6d5ec2f-c32f-4a0b-a834-866e8fd17d50.png)  
### 조상 스트림의 내부 구조  
![image](https://user-images.githubusercontent.com/101965836/167073596-5944a558-a204-409f-ab71-3c1a363aeb51.png)  


