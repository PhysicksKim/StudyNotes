# 10. 날짜와 시간 & 형식화  

## 10-1~3 날짜와 시간, Calendar 클래스  

### java.util.Date 
날짜와 시간을 다룰 목적으로 만들어진 클래스 (JDK1.0;1995년)  
근데 Date 메서드는 거의 deprecated이지만, 여전히 쓰이고 있긴 하다  

### java.util.Calendar  
Date 클래스를 개선한 새로운 클래스(JDK1.1;1997년)   
그러나 여전히 단점이 존재  

### java.time패키지  
Date와 Calendar의 단점이었던 날짜와 시간을 같이 다뤄야 하는 단점을 개선해 새로운 클래스들을 제공한다 (JDK1.8)   
이외에도 몇 가지 단점들을 보완했고, 될 수 있으면 time 패키지를 쓰는게 좋다    
하지만 레거시들이 여전히 쓰이고 있으니 Date와 Calendar도 알아둬야 한다   
  
  
### 이걸 왜 배워야 하는가?    
날짜와 시간은 굉장히 중요하다. 실제로 비즈니스 구현에 날짜와 시간은 굉장히 중요하게 다뤄진다. 따라서 날짜와 시간을 어떻게 다뤄야 하는지에 대해서 배워야 한다.  
  
### Calendar 클래스
추상 클래스이므로 getInstance()를 통해 구현된 객체를 얻어야 한다.  
```
Calendar cal = new Calendar(); // 에러! 추상클래스는 인스턴스를 생성할 수 없다
```
```
Calendar cal = Calendar.getInstance(); // OK! getInstance()메서드는 Calendar클래스를 구현한 클래스의 인스턴스를 반환한다.
```

### 예제 
```java
Calendar today = Calendar.getInstance();
// today.get() 안에는 int형으로 숫자를 입력받는다. 1을 주면 YEAR, 2를 주면 MONTH, 3을 주면 WEEK_OF_YEAR을 반환한다.
// 약간 뇌피셜로 Switch CASE 구문으로 CASE 1 CASE 2 같은 식으로 있나보다.  
// 그래서 today.get(1); 이런식으로 할 순 없으니, Calendar 클래스 내부에 static으로 선언된
// Calendar.YEAR 같은 static 상수값을 줘서 값을 갖고온다
System.out.println("올해는... " + today.get(Calendar.YEAR));
System.out.println("오늘이 몇 월이냐면... " + (today.get(Calendar.MONTH)+1));
System.out.println("오늘은 올해의 몇째 주냐면... " + today.get(Calendar.WEEK_OF_YEAR));
```  

## 10-4,5 Calendar 클래스 예제 - set() 메서드 사용

### set()으로 날짜와 시간 지정
```
void set(int field, int value)
void set(int year, int month, int date)
void set(int year, int month, int date, int houfOfDay, int minute)
void set(int year, int month, int date, int hourOfDay, int minute, int second)
```

### 날짜 지정하는 방법
**월(Month)이 0~11** 임에 주의  
```java
Calendar date1 = Calendar.getInstance();
date1.set(2022, 4, 1); // 2022년 5월 1일 (4월이 아니라 5월임)
```
```java
// 이렇게도 가능
date1.set(Calendar.YEAR, 2022);
date1.set(Calendar.MONTH, 4);
date1.set(Calendar.DATE, 1);
```

### 시간 지정하는 방법
시간을 지정하는 방법은 따로 없어서 일일이 해줘야함  
```java
Calendar time1 = Calendar.getInstance();
time1.set(Calendar.HOUR_OF_DAY, 10);
time1.set(Calendar.MINUTE, 20);
time1.set(Calendar.SECOND, 30);
```
### clear() 
옛날에 "이거 날짜를 언제를 기준으로 할건가?" 라는 논의에서    
그냥 "1970-01-01T00:00:00"을 기준으로 하자  
라고 결론지었다.  
그냥 컴퓨터가 나오기 전에 대충 적당한 날짜로 정한 것이다  
그래서 .clear();로 초기화를 하면 1970년 1월 1일 00시 00분 00초로 초기화 된다.  
  
```
Calendar dt = Calendar.getInstance(); // 현재 시간
dt.clear(); // 초기화
System.out.println(new Date(dt.getTimeInMillis(); //
```

한편, clear(int field)를 하면 특정 필드를 초기화 한다.  
예를 들어 clear(Calendar.SECOND) 라고 하면 초를 초기화 하게 된다.  

### clear()의 용도 (예제10-5)  
예를 들어   
두 날짜 값을 인자로 받고, 두 날짜간 며칠 차이인지를 반환하는 메서드를 구현한다 해보자.  
그러면 Calendar 형식으로 2개의 인스턴스를 얻고  
여기다가 .set()해서 인자로 받은 날짜를 대입해서   
두 인스턴스를 .getTimeInMillis()로 빼주고, 다시 일(date) 단위로 변환하면 된다고 생각할 수 있다.  
  
하지만 이렇게 하면 문제가 발생하는데   
아래 코드를 보자  
```
static int getDayDiff(String yyyymmdd1, String yyyymmdd2) {
  ...
  try {
    ... // (인자로 받은 String을 분해해서 int형으로 year, month, day로 변환 
    
    Calendar date1 = Calendar.getInstance();
    Calendar date2 = Calendar.getInstance();
    date1.set(year1, month1, day1);
    date2.set(year2, month2, day2);
    ... // millisecond 단위로 get 해서 두 날짜 빼고 일(date)로 전환
  } catch ...
```

근데 이렇게 하면 date1과 date2가 딱 2일 차이라 하더라도  
1.999999.... 이런식으로 뜬다   
왜냐하면    
date1과 date2 가 생성되는 시간에서 약간의 millisecond 차이가 발생할 수 있기 때문이다  
따라서 이럴 때 아래와 같이 clear를 해주고 set해야 한다.  
```
Calendar date1 = Calendar.getInstance();
Calendar date2 = Calendar.getInstance();
date1.clear();
date2.clear();
date1.set(year1, month1, day1);
date2.set(year2, month2, day2);
```

## 10-6 add와 roll
add와 roll 둘 다 특정 필드의 값을 더해준다  
```
date.add(Calendar.DATE, 1); // 날짜(DATE)에 1을 더한다
date.add(Calendar.MONTH, -8); // 월(MONTH)에 8을 뺀다
```
  
#### 차이점  
add()는 **다른 필드에 영향O**    
roll()은 **다른 필드에 영향X**    
  
```
date.set(2020, 7, 31);

date.roll(Calendar.DATE, 1); // 2020년 7월 1일
date.roll(Calendar.MONTH, -8); // 2020년 1월 31일
```  
  
  
## 10-7 커맨드라인으로 달력 모양으로 출력하는 예제
특별한 내용은 없고, 그냥 필요하면 한 번 그때 보면 좋은 정도다  
대충 달력을 만들 때 어떻게 작성하면 좋을지 약간 노하우 스러운 예제다  

## 10-8 Date와 Calendar간의 변환  
Date의 메서드는 대부분 deprecated 되었지만 여전히 사용하기 때문에 변환 방법 정도는 알아두는 것이 좋다  

### Calendar -> Date
```
Calendar cal = Calendar.getInstance();  
...
Date d = new Date(cal.getTimeINMillis());
```

### Date -> Calendar
```
Date d = new Date();
...
Calendar cal = Calendar.getInstance();
cal.setTime(d);
```

## 10-9 형식화 클래스
#### 형식화 클래스란?  
java.text 패키지에 DecimalFormat, SimpleDateFormat이 있는데  
숫자나 날짜를 원하는 형식으로 쉽게 출력하도록 할 때 사용하는 클래스이다  
  
예를 들면 아래와 같이  
double형 숫자를 지수형으로 바꿔주고 싶으면  
아래와 같이 format을 사용할 수 있다.  
```
double number = 123456.789;
DecimalFormat df = new DecimalFormat("#.#E0");
String result = df.format(number);  // result = "1.2E6"
```
    
반대로 형식화된 숫자나 날짜에서 데이터를 편리하게 정제할 수 있다  
```
DecimalFormat df = new DecimalFormat("#,###.##");
Number num = df.parse("1,234,567,89");
double d = num.doubleValue(); // 1234567.89
```

## 10-10 DecimalFormat
숫자를 형식화할 때 사용한다  
이때 패턴을 어떻게 주는지는 굉장히 다양하다  
```
DecimalFormat df = new DecimalFormat("#.#E0");  
```
패턴에 관한 것은 자주 사용하는 패턴들은 알아두면 좋겠지만  
그냥 상황에 따라서 필요하면 그 때 검색해서 알아봐도 된다  

## 10-11,12 DecimalFormat에 관한 예제
대충 그냥 패턴을 어떻게 쓰는지 알려주는 간단한 예제다  

## 10-13~16 SimpleDateFormat
날짜와 시간을 다양한 형식으로 출력할 수 있게 해준다  
```
Date today = new Date();
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");

String result = df.format(today);
```

반대로 문자열에서 날짜와 시간을 간단히 뽑아낼 수도 있고,  
날짜 문자열을 다른 형식으로 바꾸는 것도 아래 예제와 같이 두 단계를 거치는 식으로 해서 가능하다  
```
DateFormat df = new SimpleDateFormat("yyyy년 MM월 dd일");
DateFormat df2 = new SimpleDateFormat("yyyy/MM/dd");

Date d = df.parse("2015년 11월 23일");
String result = df2. format(d);
```
  
  <br><br><br>
  
  ---
  
  <br><br><br>
  
# 11. 컬렉션 프레임워크  
컬렉션 프레임웍은 객체지향 다음으로 중요한 개념이다  
이 장은 여러번 전체적으로 빠르게 반복해서 보는 게 좋다  
컬렉션 프레임웍 쪽은 분량이 많기 때문에 까먹기 쉬우므로 잘 정리한 다음 반복학습이 중요하다  

## 11-1 컬렉션 프레임워크
#### 컬렉션 collection 
여러 객체(데이터)를 모아 높은 것을 의미   
#### 프레임워크 framework  
표준화, 정형화 된 체계적인 프로그래밍 방식   
특정 프레임웍을 이용해서 프로그램을 짜면 다른 사람이 봐도 그 프레임웍에 따르기 때문에 이해하기가 쉬워지게 된다  
  
#### 그러면 컬렉션 프레임워크은 뭔가?  
컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식을 말하며  
컬렉션을 쉽고 편리하게 다룰 수 있도록 다양한 클래스를 제공한다   
  
많은 데이터를 효율적으로 다룰려면 CRUD를 효율적으로 구현해야 한다  
따라서 JDK1.2부터 다수의 데이터를 다룰 수 있도록 표준화해서 제공한게 컬렉션 프레임웍이다  

#### 컬렉션 클래스
다수의 데이터를 저장할 수 있는 클래스를 말한다 (ex. Vector, ArrayList, HashSet)  
  
## 11-2 컬렉션 프레임워크의 핵심 인터페이스  
1. List   
2. Set   
3. Map   
  
List : 순서가 있음. 중복을 허용.  
ex. 대기자 명단  
  
Set : 순서가 없음. 중복을 허용하지 않음  
ex. 양의 정수 집합, 소수 집합  
  
Map : Key - Value로 이뤄진 데이터 집합. 순서 없음. key는 중복X, Value는 중복O  
ex. 우편번호, 지역번호, Id-Password  
  
여기서 **List와 Set의 공통된 부분** 을 **Collection** 으로 묶는다.  

## 11-3~6 Collection 인터페이스의 메서드, List Set Map 인터페이스의 메서드    
![image](https://user-images.githubusercontent.com/101965836/166133207-d376e76f-24de-4b58-9f0d-15222135f9c4.png)   
이렇게 List와 Set은 공통적으로 Collection으로 묶인다    
Collection에는 구체적으로 아래와 같은 메서드 들이 있는데, 그냥 추가 삭제 검색 정도만 유의해서 보면 된다. 생각보다 그렇게 메서드가 다양하지 않다.   
또 List, Set, Map에도 각각 메서드들이 있는데...   
그냥 일단은 각 챕터마다 어떤 메서드들이 있는지 표를 보여주면서 대략 이런 메서드들이 있다는 것만 알아두고  
뒤에서 하나하나 배워보자  
  
  
## 11-7~11 ArrayList
![image](https://user-images.githubusercontent.com/101965836/166133948-12f7d4ab-ec77-4d12-a9a7-5bce81fb9508.png)  
- 순서O 중복O
- 데이터의 저장공간으로 배열을 사용한다(배열기반)

List 인터페이스는 순서 O 중복 O 이며  
위의 계층도와 같이  
List는 Vector, ArrayList, LinkedList가 있다.  
  
여기서 먼저 ArrayList에 대해서 볼꺼고  
Vector는 ArrayList의 레거시이며 거의 동일하다.   
Vector와 ArrayList 둘의 차이는 Vector는 동기화O ArrayList는 동기화X 이다. (동기화는 13장 쓰레드에서 배운다)  
   
### ArrayList의 메서드  

#### 생성자들
```
ArrayList() // 기본 생성자
ArrayList(Collection c) // 컬랙션에 저장되어 있는 것을 담은 ArrayList를 생성
ArrayList(int initialCapacity) // 배열의 길이를 줘서 생성
```
배열의 길이를 주는 것은,   
배열은 한번 만들면 길이를 바꿀 수 없다.  
따라서 배열 공간이 부족하면, 또 다시 새로 만들고 복사해야하기 때문에 연산 리소스를 차지하게 된다.  
예를들어 나중에 가서 배열의 길이가 엄청 길어져서 100만개가 됐다고 해보자.  
그런데 넉넉하게 배열을 안만들어놓고, 찔끔찔끔 계속 배열 공간을 늘리게되면  
계속 새로 배열을 생성하고 복사하는 작업이 이뤄져서  
말도 안되게 프로그램이 느려지게 된다.  
그러니 처음부터 제대로 예상되는 만큼 배열의 길이를 확보해서 생성해주는 것이 좋다.  
  
#### 추가하는 매서드
```
boolean add(Object o)
void add(int index, Object element)
boolean addAll(Collection c)
boolean addAll(int index, Collection c)
```
boolean으로 된 것들은, 성공하면 true 실패하면 false를 반환한다.  
각 매개변수에서 Object나 Collection들은 저장할 객체를 담은 것을 말하며,  
int index는 저장 위치를 말한다.  

#### 삭제하는 매서드  
```
boolean remove(Object o)
Object remove(int index)
boolean removeAll(Collection c)
void clear()
```
역시나 boolean은 성공 실패 여부를 반환한다.   
특정 위치 삭제에 index를 쓰며 clear는 모든 객체를 삭제한다.  
  
  
#### 검색하는 매서드  
```
int indexOf(Object o) // List 앞에서 부터 찾음
int lastIndexOf(Object o) // List 뒤에서 부터 찾음
boolean contains(Object o) // 객체가 있는지
Object get(int index) // 특정 위치 객체 반환
Object set(int index, Object element) // 특정 위치 객체 변경
```

#### 그외
```
List subList(int fromIndex, int toIndex) // 특정 Index 범위 내의 리스트 추출해서 반환
Object[] toArray() // ArrayList의 객체 배열을 반환
Object[] toArray(Object[] a)
boolean isEmpty() // 비어있는지
void trimToSize() // 빈공간 제거
int size() // 저장된 객체의 갯수
```
  

### 예제 Ex11_1  
간단히 ArrayList를 메서드로 다루는 법에 대한 예제이다  
  
몇 가지 주의할 점은    
Collections는 Collection과 다르다  
Collection은 인터페이스고   
Collections는 Collection을 다루기 위한 유틸 클래스이다  
  
  
그리고  
list1:\[1, 0, 1, 2, 3, 4, 5]  이런 ArrayList가 있다고 해보자  
여기다가 list1.remove(1)을 하면 어떻게 될까?  
정답은 list1:\[1, 1, 2, 3, 4, 5] 가 된다.  
  
왜? remove에다가 int 값을 넘기면 index로 인식해버리기 때문이다.  
따라서 ArrayList에 있는 특정 값을 지우고 싶은데 그게 Int다 라고 하면   
list1.remove(new Integer(1)) 이렇게 적어줘야 한다.    
  
  
### ✨\[중요] ArrayList에서 삭제 할 때 어떤 일이 일어날까?  
ArrayList에 저장된 세 번째 데이터(data\[2]) 를 삭제하는 과정을 예시로 들어서 보자    
![image](https://user-images.githubusercontent.com/101965836/166134982-de363dc8-cc63-44ab-885c-65303c0a8471.png)    
(1) 2를 삭제하고 나면, 그 뒤에 있는 데이터들을 한칸씩 밀어 올리게 된다    
(2) 그 다음 마지막 데이터였던 data\[4]의 값을 null로 바꾸고  
(3) size의 값을 감소시킨다  
여기서 (1)의 과정이 부담이 많이가므로, (1)이 일어나지 안도록 하는 것이 좋다  
  
  
### 오해할 만한 것
만약 for문 돌려서  
list.remove(index)로 index 0부터 ++ 하면서 마지막 index까지 삭제하면  
전부 다 지워질까??  
**삭제가 제대로 안된다.**  
무슨 말인가 하니  
![image](https://user-images.githubusercontent.com/101965836/166135134-122d9de5-ee01-4fc0-abe6-2a928e8d232d.png)  
이렇게 된다는 뜻이다  
   
#### 그럼 어떻게 해야 하느냐?     
그냥 **뒤에서 부터 삭제** 하면 된다  
이러면 또 **배열 복사도 발생하지 않는다**  
![image](https://user-images.githubusercontent.com/101965836/166135173-c4082e9e-d007-4e87-999b-a7d07ecae745.png)  
  
## 11-12~14 LinkedList
### 우선, 배열의 장단점에 대해
배열 장점 : (1) 구조가 간단 (2) 데이터 접근 시간이 짧다 (3) 순차적인 추가 삭제는 빠르다
(1) 그냥 물리적 논리적으로 쫘라락 순서대로 나열된 간단한 구조이다  
(2) 만약 index 10000 이라 하더라도, 그냥 각 배열 크기만큼에다가 10000을 곱하면 물리적으로 논리적으로 해당 위치로 바로 갈 수 있기 때문에 간단하게 해당 위치로 접근할 수 있다  
(3) 간단한 구조기에 뭐 짜잘하게 다른 내용 담긴거 없이 바로 값을 담는다. 따라서 제일 끝에 데이터를 추가하고 삭제하는 경우만 일어난다면 배열이 빠르다.    
    
배열 단점 : (1) 크기를 변경할 수 없다 (2) 비순차적 데이터 추가 삭제에 많은 시간이 걸린다  
(1) 크기 변경해야 할 경우, 새로운 배열을 생성 후 데이터를 복사해야 한다. 그렇다고 너무 큰 배열로 넉넉히 만들어버리면 메모리가 낭비된다  
(2) 중간에 있는 데이터를 추가 삭제 한번 할려고 하면 다 옮기는 작업을 해야해서 연산이 너무 많이 든다.   
물론 그냥 안옮겨버리는 방법이 있기도한데, 일단은 그냥 그렇다는 점만 알아두자   
  
### 그래서 LinkedList - 배열의 단점을 보완   
앞서 본 것과 같이 배열의 단점을 보완하기 위해서 LinkedList가 나왔다   
각각의 요소를 노드(Node) 라고 하며  
노드는 다음 데이터가 어디있는지 참조 변수를 갖고 있다.  
![image](https://user-images.githubusercontent.com/101965836/166135406-e5729605-347b-45ad-814f-87e4cc19db67.png)  
  
따라서 삭제 추가가 일어나면, 그냥 중간에 넣어두고 참조변수만 바꿔주면 된다  
  
### 그런데 LinkedList의 단점도 있다
배열은 연속적이라서 한번에 index로 찾아갈 수 있다  
그런데 LinkedList는 불연속적이라서 한번에 갈 수 없다  
물론 한번에 쫙 갈 수 있도록 해결할 수 는 없지만  
그냥 역방향으로도 갈 수 있도록 한게 이중 연결리스트 이다  

### 이중 연결 리스트(doubly linked list)
그래서 이 접근성이 나쁜 것을 해결한 것이 이중 연결 리스트이다  
![image](https://user-images.githubusercontent.com/101965836/166135554-546bb07b-6c01-498a-8860-481d363d0fb9.png)  
이전 요소가 있기 때문에 앞뒤로 이동할 수 있지만  
삭제, 추가가 일어나면 연결 고리를 앞 뒤 둘다 수정해줘야 하니까 연산 하나가 더 필요하다는 정도의 차이가 있다  

### 이중 원형 연결 리스트(doubly circular linked list)  
![image](https://user-images.githubusercontent.com/101965836/166135654-1d62eed9-571d-42ad-866d-16d54bdbab6b.png)  
맨 앞과 끝에다가도 앞뒤 방향을 추가해서 원형으로 순환하도록 만들 수 있도록 한 것이다    
  
근데 이런게 있긴 한데 자바에서는 앞서 본 그냥 이중 연결 리스트를 쓴다   

### ArrayList vs LinkedList  성능 비교  
![image](https://user-images.githubusercontent.com/101965836/166135687-531cc139-f5a7-4ed7-aa63-bfd729de4023.png)  
  
**(1) 순차적 데이터 추가 삭제** 의 경우 ArrayList가 빠른데   
**(2) 비순차적 데이터 추가 삭제** 의 경우 LinkedList가 압도적으로 빠르다  
**(3) 접근 시간** 의 경우 ArrayList가 엄청 빠르다  
  
  
### 연결 기반과 배열 기반
자료 구조는 모두 배열 기반과 연결 기반으로 이뤄져 있다  
따라서 앞서 본 ArrayList와 LinkeList의 구조와 성능 비교에 대해서 확실히 알아둬야 한다  
  
  
  
## 11-15~18 Stack과 Queue
  
### Stack
![image](https://user-images.githubusercontent.com/101965836/166135812-4edc738d-89ec-4034-8b23-fb674fe7171c.png)    
Stack : LIFO (Last In First Out) => (Last)마지막에 (In)들어간게 (First)제일먼저 (Out)나온다  
밑이 막힌 상자 모양이며, 넣는걸 push라 하고 빼는걸 pop이라 한다   
Array로 만드는게 유리하다   
    
### Queue
![image](https://user-images.githubusercontent.com/101965836/166135835-2957c1db-cc4d-47f8-b51b-f820754013b3.png)  
Queue : FIFO (First In First Out) => (First)처음에 (In)들어간게 (First)제일먼저 (Out)나온다  
밑이 뚫린 상자 모양이며, 넣는걸 offer라 하고 빼는걸 poll이라 한다  
LinkedList로 만드는게 유리하다    

### JAVA에서 Stack과 Queue
자바에서 Stack은 구현된 클래스로 있으며, Queue는 인터페이스로는 Queue가 있고 구현된 형태는 LinkedList가 있다   
```
Stack st = new Stack();
Queue q = new LinkedList();	// Queue인터페이스의 구현체인 LinkedList를 사용
```

### Stack의 메서드  
Object push(Object o) 추가(저장)  
Object pop() 맨 위에 객체 삭제    
  
boolean empty() 비어있는지 알려줌   
Object peek() 맨 위에 저장된 객체를 보는 거    
int search(Object o) 검색해서 같은 object가 있으면 index 반환, 못찾으면 -1 반환   
  
### Queue의 메서드  
boolean offer(Object o) 저장 하고 성공여부 반환    
Object poll() 삭제 하고 반환    
     
Object remove() 삭제인데 객체를 꺼내서 반환. 비어있으면 NoSuchElementException 발생   
Object peek() 삭제 없이 요소를 읽음 비어있으면 null  
Object element() 삭제 없이 요소를 읽음 비어있으면 NoSuchElementException 발생  
boolean add(Object o) 지정된 객체를 Queue에 추가. 저장공간 부족하면 illegalStateException 발생  
  
위의 6개 메서드들은  
각각 예외가 발생하는 메서드들이랑, 예외가 발생하지 않는 메서드로 나눌수 있다.  
![image](https://user-images.githubusercontent.com/101965836/166136419-eb065ed1-3d75-4b38-839e-fe14c5cecae0.png)  

|예외 여부|추가|삭제|확인|  
|---|---|---|---|  
|예외 없음|offer()|poll()|peek()|  
|예외 발생|add()|remove()|element()|  
  
### Queue는 인터페이스다 -> 객체 생성 불가  
Stack은 
```
Stack st = new Stack();
```
이 가능하다  
  
하지만 Queue는 인터페이스이므로 위처럼 **객체 생성이 불가능하다**  
따라서 Queue를 직접 구현하거나 다른 사람이 만든 클래스를 사용하면 된다  
![image](https://user-images.githubusercontent.com/101965836/166136532-fb85c3ba-090a-45a4-b8ca-ba88ee5f1473.png)  
JAVA API문서에서 위와 같이 Queue 인터페이스를 구현한 것들을 보면 우리에게 익숙한 LinkedList가 있다  
그러므로 LinkedList를 사용해서 Queue를 활용하자  
```
Queue q = new LinkedList();
```
근데 그냥 LinkedList라고 쓰면 되지 왜 Queue라고 쓰느냐?    
그건 그냥 공통되게 Queue를 쓰는 것들로 변환할 수 있기 때문이다  
예를 들면 위의 API 문서에서 나와있듯  
q가 LinkedList를 가리키다가 ArrayDeque를 가리킬 수 있다 (다형성)  

## 11-19~21 StackQueue 활용  

스택 활용 - 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저 뒤로가기/앞으로가기  
큐의 활용 - 최근사용문서, 인쇄작업 대기목록, 버퍼    

### Stack활용 예제 - 괄호검사  (예제 11_3)  
((3+5)\*8-2) 라는 수식이 있다고 해보자  
그러면  
```
(             // [ ( ,   ,   ,   ,   ]
((            // [ ( , ( ,   ,   ,   ]
((3+5)        // [ ( ,   ,   ,   ,   ] 
((3+5)\*8-2)  // [   ,   ,   ,   ,   ]
```
이런식으로 (를 만나면 stack에 괄호를 추가하고, )를 만나면 stack에서 괄호를 빼는 식으로 괄호 검사를 한다    

### Queue활용 예제 - 최근사용문서
예를 들어 10개의 문서만 저장한다고 치면,   
사용한지 오래된 기록부터 삭제하는 것이 맞기 때문에   
가장 먼저 들어온(오래된) 기록을 삭제하기 용이하도록 Queue를 활용해 구현하는 것이 적합하다    
  
  
## 11-22~23 Iterator, Enumeration, / Map과 Iterator  
### Iterator, Listiterator, Enumeration  
- 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스이다  

(1) Enumeration은 Iterator의 구버전에 해당한다     
그냥 Iterator를 쓰면 되고, 레거시가 나오면 그때 보면 된다     
(2) Iterator와 Listiterator의 차이는 조회 방향의 차이다    
Iterator는 -> 정방향만 가능한데    
Listiterator는 <- -> 양방향 가능하다    

### 왜 Iterator를 쓰냐? 
컬렉션의 종류가 List Set Map이 있는데  
컬렉션마다 구조가 달라서 요소들을 읽어오는 방법이 다르다  
따라서 이를 표준화 한 것이 Iterator이다  
  
예를 들면 List를 쓰다가 Set으로 바꿨다 치자   
그러면 읽어오는 코드도 바꿔야 하는데,  
Iterator를 사용하면 코드를 변경하지 않아도 된다  
  
  
### 어떻게 쓰느냐  
```
List list = new ArrayList();
Iterator it = list.iterator();

while(it.hasNext()) {
  System.out.println(it.next());
}  
```
컬렉션에 있는 iterator()를 호출해서, Iterator를 구현한 객체를 얻어서 사용한다   
iterator()는 Collection 인터페이스에서 public Iterator iterator(); 라고 정의되어 있으며   
구현은 각각 종류에 따라서 이뤄져있다    
   
### Map과 Iterator  
List Set Map 중에서  
Map에는 iterator()가 없다  
  
List와 Set은 Collection의 자손이지만  
Map은 Collection의 자손이 아니다  
  
### 그러면 Map에 저장된 요소들을 어떻게 가져와야 할까?  
keySet() entrySet() values()를 호출해야 한다  
아래 예제 코드를 보면서 설명해보자  
```
Map map = new HashMap();

Iterator it = map.entrySet().iterator();
```
  
entrySet()은 Key하고 Value 쌍을 갖는 Set을 반환한다. 이 말은 뭐냐면  
map을 set으로 바꾸는 entrySet으로 Set을 얻고   
Set은 iterator를 갖고 있으니 그걸로 쭉쭉 접근해주면 된다  

map에다가 iterator를 쓰는건 나중에 map 배울 때 자세히 알아보자  

## 11-25~29 Array  
### Arrays 유틸 메서드
배열을 편리하게 다루기 위한 메서드를 제공한다   

1. 배열의 출력 - toString()   
2. 배열의 복사 - copyOf() copyOfRange()  
3. 배열 채우기 - fill() setAll()  
4. 배열의 정렬과 검색 - sort(), binaraySearch()   여기서 이진탐색은 정렬된 배열에만 가능함  
5. 다차원 배열 출력 - deepToString()    
6. 다차원 배열 비교 - deepEquals()    
7. 배열을 List로 변환 - asList(Object... a)  여기서 Object 뒤에 ...은 가변 매개변수를 말함  
> 여기서 그냥 List는 읽기 전용이며, ArrayList로 다시 만들어 줘야지 변경 가능한 형태가 된다.  
  
8. 람다와 스트림(14장) 관련 - parallelXXX(), spliterator(), stream()  
  
예제 코드 11_6에서 각각 활용법에 대해 본다  
자세히 각 매서드에 대한 내용은 때에 따라 책이나 문서를 참고하고  
이런 것들이 있구나 정도 알아두고 필요에 따라서 검색해서 쓰도록 하자  
  
### 유의할 점
(1) copyOf()는 딥카피임   
(2) 향상된 for문   
예제코드에서 for(int i : arr7) 이런 코드를 썼는데, 향상된 for문이라 해서    
```
for(int x=0; x<arr7.length;x++) {
  int i = arr7[x];
  ...
}
```
이거를 간단히 한 것이 for(int i : arr7) 이다 (i에 각 배열 인덱스가 아니라 요소가 들어간다는 점을 주목)   
마치 javascript에서 forEach 문 같은 느낌이다     
  
  
## 11-30~33 Comparator와 Comparable  
객체 정렬에 필요한 메서드를 정의한 인터페이스 이다   
정렬 기준을 제공한다   
Comparable : 기본 정렬기준을 구현하는데 사용  
Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용  

### 근데 걔들은 인터페이스고, 어떻게 정렬하는데 쓰는데?  
Arrays.sort() 에서 앞선 기존 예제에서는 Arrays.sort(arr) 같은 식으로 딸랑 배열 하나만 던져주면 자동으로 정렬해버렸다  
(이건 사실 arr의 형식들이 Comparator를 갖고있기 때문이다)  
근데 여기다가 어떻게 정렬해라고 명령을 던져주면 좋지 않겠는가?  
그래서 .sort() 메서드는 arr 다음 인자로 Comparator 인터페이스를 implements 한 클래스의 객체를 같이 던져주면  
거기에 메서드의 구현부에 따라서 정렬하고 다시 결과를 반환해준다  
```
static void sort(Object[] a)  
static void sort(Object[] a, Comparator c)  
```
말이 좀 어려운데...    
일단 설명 차근히 보면서 뒤에서 예제 11-7을 보자    
  
### 그래서 Comparator와 Comparable이 뭘 가지고 있는데?
```java
public interface Comparator {
  int compare(Object o1, Object o2);  // o1, o2 두 객체를 비교
  boolean equals(Object obj); // equals를 오버라이딩하라는 뜻
}
```
compare는 결과가 같으면 0을 반환, 양수면 왼쪽이 크고, 음수면 오른쪽이 크다  

```java
public interface Comparable {
  int compareTo(Object o);
}
```
compareTo는 주어진 객체 o와 자기 자신을 비교하는 것이다  
  
### 근데 어떻게 정렬?  
정렬 기준은 다양하다.   
오름차순, 내림차순 같은 내용도 있으면서   
숫자기준, 이름기준 등등이 있을 수 있다   
어찌됐건 Comparator와 Comparable 둘 다 인터페이스이므로   
compare()와 compareTo()는 두 객체의 비교결과를 반환하도록 작성해주고, 같으면 0 오른쪽이 크면 음수, 작으면 양수로 해서 만들어주면된다   

### 예제코드 11-7
```java
import java.util.*;

class Ex11_7 {
	public static void main(String[] args) {
		String[] strArr = {"cat", "Dog", "lion", "tiger"};

		Arrays.sort(strArr); // String의 Comparable구현에 의한 정렬
		System.out.println("strArr=" + Arrays.toString(strArr));

		Arrays.sort(strArr, String.CASE_INSENSITIVE_ORDER); // 대소문자 구분안함
		System.out.println("strArr=" + Arrays.toString(strArr));

		Arrays.sort(strArr, new Descending()); // 역순 정렬
		System.out.println("strArr=" + Arrays.toString(strArr));
	}
}

class Descending implements Comparator { 
	public int compare(Object o1, Object o2){
		if( o1 instanceof Comparable && o2 instanceof Comparable) {
			Comparable c1 = (Comparable)o1;
			Comparable c2 = (Comparable)o2;
			return c1.compareTo(c2) * -1 ; // -1을 곱해서 기본 정렬방식의 역으로 변경한다.
						                // 또는 c2.compareTo(c1)와 같이 순서를 바꿔도 된다.
		}
		return -1;
	} 
}
```
여기서 보면  
```
Arrays.sort(strArr, String.CASE_INSENSITIVE_ORDER);
```
이 부분에서는 String 클래스 내에서 미리 정의된 Comparator를 넣어주는 식으로 했다   
이런식으로 미리 정의된 Comparator들이 있기도 하다  
  
  
### Integer와 Comparable
Integer 같은 경우 딱 비교 방식이 명확하지 않은가?  
int처럼 비교할 수 있을법한 자료형들은 Comaprable 인터페이스를 받아서 구현하고 있다  
  
### 그럼 Comparator 계속 구현해줘야 하나?  
아니다. 이미 그냥 뭐 대표적인 것들은 다 구현되어있고,  
우리는 "아~ 이런식으로 Comparator Comparable 이란것들이 있는거구나~" 하고 이해한다음  
가져다가 쓸 수 있기만 하면 된다  

## 11-34~36  HashSet
![image](https://user-images.githubusercontent.com/101965836/166145490-41e28dde-bfc6-4806-97c3-54088fd29c7a.png)  
Set 인터페이스는 순서X 중복X 이며,  
Set 인터페이스를 구현한 것은 (1) HashSet (2) TreeSet 이렇게 일반적으로 2가지가 있다   
  
#### HashSet  
- Set 인터페이스의 대표적인 녀석  
- 원래 순서X, 만약 순서가 필요하면 LinkedHashSet을 쓰면 된다  

#### TreeSet
- 범위 검색과 정렬에 유리한 컬렉션 클래스 (범위검색 : 예를 들면 10보다 크고 20보다 작은 것을 검색 하는 것) 
- HashSet보다 데이터 추가, 삭제에 시간이 더 걸림  

### HashSet의 주요 메서드 

#### 생성자
![image](https://user-images.githubusercontent.com/101965836/166145678-a7796ba9-bd40-4366-b558-bc6e50eba631.png)   
여기서 마지막 생성자에 float loadFactor가 있는데    
이거는 "얼마나 용량이 차면 미리 Hash를 늘릴거냐?" 라는 인자이다    
디폴트는 0.75이며 75%가 차면 용량을 늘리는 작업을 한다    
용량을 늘리는 작업은 한 번에 2배씩 늘어난다    

#### 추가 삭제
![image](https://user-images.githubusercontent.com/101965836/166145800-38756a2b-27bd-4ae5-bd44-9e4c3069ff7f.png)    
보면 이제  
추가, 삭제로 크게 나누고, 위의 2개 add 붙은 것들은 추가에 해당하며, 아래 4개들은 삭제에 해당한다  
간단한 것부터 말하면, add(Object o) remove(Object o)는 인자로 넘기는 객체 o를 추가하고 삭제하는 메서드이다  
그 다음 addAll과 removeAll인데  
인자로 넘기는 Collection c 를 통해서 합집합과 교집합을 구한다 (자세한 내용은 뒤에서 다시 다룬다)  
그리고 retainAll은 마찬가지로 Collection c를 통해서 조건부로 삭제를 한다.  
  
#### 포함 여부
![image](https://user-images.githubusercontent.com/101965836/166145908-396de5a0-45b8-4d0c-929b-0c85bf55a01c.png)   
여기서 iterator()는 이전에 알아봤듯 반복해서 다음 요소에 접근할 수 있도록 하기 위해 쓰는 것이다  
```
Iterator it = set.iterator();

while(it.hasNext()) {
	System.out.println(it.next());
}
```
  
#### 그외
![image](https://user-images.githubusercontent.com/101965836/166145941-1eea7744-e4a9-4086-844b-aa6162c1fe0d.png)    
  
  
## Hashset을 이용할 때 주의 할 점  
HashSet에다가 add 할 때, 이미 같은 값을 갖는 객체가 있으면 더이상 저장하지 않는다.    
근데 이러한 작업은 기본적으로 "같은 값이 뭔데?" 에 대해 답할 수 있어야 한다    
따라서 "같은 값"을 정의해주기 위해 equals()를 오버라이딩해서 구현해줘야 한다    
또한 HashSet이라는 이름 그대로 hash를 사용하기 때문에, hashCode()를 호출하므로    
hashCode()도 오버라이딩 되어 있어야 한다    
  
예제 11_11코드를 보면, equals() 오버라이딩을 안해서 문제가 발생하는 예시를 볼 수 있다  
  
	
### 그럼 오버라이딩 어떻게 해요?    
![image](https://user-images.githubusercontent.com/101965836/166146728-879cfa10-e3fa-470d-a970-51b63f536181.png)   
이렇게 하면 된다   
hashCode() 오버라이딩은   
```java
// 방법 1
public int hashCode() {
	return (name+age).hashCode();
}
```
```java
// 방법 2
public int hashCode() {
	return Object.hash(name,age); // 매개 변수는 가변 인자이므로 마음대로 넣어주면 된다  
}
```
원래는 만들어 줘야 하는데   
방법 2처럼 Object에서 제공하는 메서드를 사용하는 새로운 방법이 있다   
방법 2로 쓰면 되는데 방법 1로 써도 상관없다   
  
	
### HashSet으로 합집합 / 교집합 / 차집합 
예제 11_12를 통해 합,교,차집합의 구현 예시를 볼 수 있다.   
```java
Iterator it = setB.iterator();
while(it.hasNext()) {
	Object tmp = it.next();
	if(setA.contains(tmp))
		setKyo.add(tmp);
}

it = setA.iterator();
while(it.hasNext()) {
	Object tmp = it.next();
	if(!setB.contains(tmp))
		setCha.add(tmp);
}

it = setA.iterator();
while(it.hasNext())
	setHab.add(it.next());

it = setB.iterator();
while(it.hasNext())
	setHab.add(it.next());
```

그런데 **사실 그냥 메서드를 쓰면 쉽게 구현** 할 수 있다다  
```java
setA.retainAll(setB); 	// 교집합. 공통 요소만 남기고 삭제
setA.addAll(setB);			// 합집합. setB의 모든 요소를 추가 (중복은 HashSet 특성상 자동으로 제외됨)
setA.removeAll(setB);		// 차집합. setB와 공통 요소 제거
```

## 11-39~41 TreeSet이란?
- 범위 탐색, 정렬을 위한 구조이다   
- 이진 탐색 트리(binaray search tree)로 구현. 범위 탐색과 정렬에 유리하다  
- 모든 노드가 최대 2개(0개~2개)의 하위 노드를 가질 수 있다
- 각 요소(node)가 나무(tree) 형태로 연결되어 있다 (LinkedList의 변형)  

![image](https://user-images.githubusercontent.com/101965836/166147996-7a5f62bd-c69a-4068-bbc9-eb495e64b313.png)  
이진트리는 이렇게 생겼고  
root가 제일 위에 있으며, 자식을 2개 가지고  
또 자식이 부모로서 자식을 갖게 된다.  
그리고 나무 뿌리처럼 생겼다고 해서 Tree 라고 이름을 붙였다  
	 
### TreeSet이 LinkedList의 변형?? 무슨 뜻이냐 하면  
LinkedList는 next가 어디에 있는지 가리키는 값을 갖고 있다  
TreeSet도 비슷하게 next 자식 노드 2개가 각각 어디에 있는지 가리키는 값을 갖는다   
따라서 일종의 LinkedList라고 할 수 있다  

### 이진 탐색 트리  
Binary Search Tree  
그냥 "이진 트리" 가 아니라  
"이진 **탐색** 트리" 이다  
   
![image](https://user-images.githubusercontent.com/101965836/166148354-8cfc97ba-5fc8-41fc-96ba-6f04c17dede4.png)  
![image](https://user-images.githubusercontent.com/101965836/166148378-e9f17daa-2c7d-469d-9b8a-1b3460fbfe3f.png)  
(이렇게 왼쪽 오른쪽 자식을 가리키는 참조 변수 갖는다)  
  
이진 탐색 트리는 이진 트리에서 조건을 하나 추가하면 된다  
부모보다 작은 값은 왼쪽, 큰 값은 오른쪽에 저장하면 된다  
    
#### 단점: 추가 삭제에 시간이 많이 걸린다  
큰지 작은지 비교해야 하니까 하나 추가하려면 계속 비교해야 한다.  
  
### TreeSet 저장과정 - add(Object o)  
중복을 허용하지 않기 때문에, 대소비교 뿐만 아니라 equals()도 필요하다   
![image](https://user-images.githubusercontent.com/101965836/166149720-416f7f71-e44d-408d-8003-22d8ae3c5cd0.png)   
위 그림은 TreeSet에 7,4,9,1,5 순서로 데이터를 저장하는 과정을 나타낸 그림이다  
보다시피 처음에는 7만 딱 있으니 비교횟수가 적지만  
나중에 갈 수록 비교 횟수가 점점 많아지는 것을 알 수 있다  

## 11-42~45 TreeSet이 가지는 메서드들 
![image](https://user-images.githubusercontent.com/101965836/166149995-96ee20fd-91f7-4a21-89cd-3c93652990df.png)  
기본적인 add remove 등은 제외하고, 알아둘만한 메서드들만을 요약한 내용  
  
#### 예제 11_13,14,15 를 통해서 TreeSet의 기본 사용법에 대해 알아봄  

### 예제 11_15 => 범위 검색 예제  
![image](https://user-images.githubusercontent.com/101965836/166151532-630a6e75-4898-4e65-8e8d-62c1d5091ac8.png)  
TreeSet은 범위검색에 특화된 자료구조이므로  
위와 같이 범위 검색에 관한 메서드를 제공한다  

### 트리 순회(tree traversal)
이진 트리에서 모든 노드를 한번씩 읽는 것을 트리 순회라고 한다  
순회 방법에도
1. 전위순회
2. 후위순회
3. 중위순회
4. 레벨순회
이렇게 있다  
나중에 자료구조 할 때 다시 자세히 알아보자    


## 11-46~47 HashMap 이란?

![image](https://user-images.githubusercontent.com/101965836/166174019-a829975b-0bf5-4868-8f42-a998d6da2a12.png)   
  
- 데이터를 Key - Value 형식으로 저장한다  
- 위 그림과 같이 Map 인터페이스를 구현한다  
 
순서 X , 키 중복 X , 값 중복 O  
  
Hashtable : old버전, 동기화O   
HashMap : New버전, 동기화X   
별 이유 없으면 그냥 HashMap 쓰면 된다   
  
TreeMap : 이진 탐색 트리와 같은 특성을 갖고 있음 (사실 TreeSet이 TreeMap을 갖고 만든 것)    
LinkedHashMap : 순서가 필요하면 쓰면 된다  
  
### HashMap의 Key - Value  
- 해싱(hashing)기법으로 데이터를 저장.  
- 데이터가 많아도 검색이 빠르다  
- Map인터페이스를 구현해서, 데이터를 Key - Value 쌍으로 저장한다  
- Key는 유일해야하며, value는 중복을 허용한다

```java
HashMap map = new HashMap();
map.put("myId", "1234");
map.put("asdf", "1111");
map.put("asdf", "1234");  // 기존에 asdf : 1111 값이 있던게, 1234로 덮어씌워진다. 
// result : { myId : 1234 , asdf : 1234 }
```

### Hashing 이란?  
예를 들어   
환자 정보가 엄청 많이 쌓여있으면 어떻게 저장할까?   
주민번호에 따라서 캐비넷에 저장할 수 있을 것이다  
그러면 환자 정보를 조회할 때 마다 주민번호 앞자리에 해당하는 캐비넷에서 찾으면 되기 때문에  
환자 정보가 많아지면 캐비넷 수를 늘려서 탐색 시간을 줄일 수 있을 것이다   
  
	  
마찬가지로, 해싱이란  
해쉬함수를 이용해서 데이터를 저장하고 읽어오는 것을 말하는데  
해쉬코드가 마치 앞선 예시에서 캐비넷의 위치를 알려주는 것과 같다  

### 해싱으로 저장하는 개괄적 모습  
![image](https://user-images.githubusercontent.com/101965836/166174604-42888684-d645-43f7-b9e4-5837df5d8b7c.png)   
  
### 해쉬는 어떻게 계산?  
그냥 Object.hash() 함수를 쓰면 된다.  	
	
### 해시테이블
배열과 LinkedList가 조합된 형태이다   
![image](https://user-images.githubusercontent.com/101965836/166174702-82b9efe2-89b1-483f-b55d-a240205b97ea.png)   
이렇게 2차원 배열처럼 생겨서 Table 이라고 한다   
왜 LinkedList? 변경하기 쉽게 하기 위해서    
  
### 해시 테이블에서 데이터 가져오는 과정
![image](https://user-images.githubusercontent.com/101965836/166174865-e13a1250-30a2-49f8-86cc-582b6920e483.png)   
1. 키로 해시함수를 호출해서 해시코드를 얻는다  
2. 해시코드(함수 output)에 대응하는 LinkedList를 배열에서 찾는다   
3. LinkedList에서 키와 일치하는 데이터를 찾는다   
  
서로 다른 키 일지라도 같은 해시값을 가질 수 있다  
그래도 어차피 LinkedList로 연결되기 때문에 상관없으며, Key 값에 따라서 구별할 수 있다  

## 11-48~51 HashMap 주요 메서드  

### 생성자 
![image](https://user-images.githubusercontent.com/101965836/166175015-c016692f-a21a-4099-82fd-eb71ac7f4d3a.png)    
int형 값을 넘겨서 초기 용량을 넘길 수 있고,   
Map형 값은 다른 Map을 받아서 HashMap으로 생성하는 생성자이다    
  
### 추가 삭제 변경
![image](https://user-images.githubusercontent.com/101965836/166175087-02e7c769-8a6b-411a-b4dd-c09d440fc7e5.png)    
putAll(Map m)은 m에 저장된 값을 전부 넣어주는 메서드  

### 값 읽기
![image](https://user-images.githubusercontent.com/101965836/166175128-acae269c-b1e0-4b89-961b-4c4042b3391d.png)
entrySet() : key - value 쌍을 갖고옴    
keySet() : key 값들만 갖고옴  
values() : value 값들만 갖고옴  
  
![image](https://user-images.githubusercontent.com/101965836/166175218-caa804de-3280-4c56-b533-ec53681a9559.png)   
get은 키 값을 주면 그 값에 해당하는 값을 반환한다   
getOrDefault는 키 값을 주고 없으면 디폴트 값을 반환하는 메서드이다  


### 그외
int size()  
boolean isEmpty()  
void clear()  
Object clone()  

### 예제 11_16~18


## 11-52~56 Collections 클래스, 컬렉션 클레스 요약  

### Collections 클래스
Objects Arrays 같은 것들은 각 형에 맞는 유용한 메서드들을 제공한다.  
마찬가지로 Collections도 컬렉션에 유용한 static 메서드를 제공한다   
   
#### 컬렉션 채우기 복사 정렬 검색
fill() copy() sort() binarySearch() 등  

#### 컬렉션의 동기화된 메서드들 구분  
synchronizedXXX() 처럼 앞에 synchronized가 붙은 것들이 동기화된 메서드들이다  
ex) synchronizedList(List list) synchronizedMap(Map m)  

#### 변경 불가 컬렉션 만들기 (readOnly)  
unmodifiableXXX()라고 된 걸 쓰면된다  
ex) unmodifiableList(List list) unmodifiableMap(Map m)  

#### 싱글톤 컬렉션 만들기
싱글톤 컬렉션이라는건 객체 한 개만 저장하는 컬렉션을 말한다  
singletonXXX() 라고 된 걸 쓰면 된다  

#### 한 종류 객체만 저장하는 컬렉션 만들기  
checkedXXX() 라고 된 걸 써서  
한가지 타입만 저장 가능하도록 만들 수 있다  
예를 들어 String만 저장 가능한 list를 만들고 싶다면   
List chkList = checkedList(list, String.class);  
라고 해서 쓸 수 있다  

#### 이외에도 여러 메서드들이 있다  
어떤 메서드들이 있는지 개괄적으로 알아두면 좋다   

### 전체 정리
![image](https://user-images.githubusercontent.com/101965836/166176535-377a675c-40a5-4646-a803-4c8593484dc4.png)  
11장에 나왔던 각종 자료구조들에 대해서 정리  
  
  
    
  <br><br><br>
  
  ---
  
  <br><br><br>
  
  
  
# 12. 제네릭, 열거형, 애너테이션  
  
## 12-1 제네릭스(Generics)란?  
컴파일시 타입을 체크해 주는 기능(compile-time type check) - JDK1.5  
```java
ArrayList<Tv> tvList = new ArrayList<Tv>();

tvList.add(new Tv()); 		// OK
tvList.add(new Audio());	// 컴파일 에러. Tv 외의 타입은 저장 불가  
```

마치 매개변수처럼, 타입을 넘겨주는 것이다    
특히나 **컴파일 에러**로 이걸 잡아줄 수 있다는게 큰 장점이다  
제네릭스 덕분에 **타입 체크**를 강화해서 코딩할 수 있다  

### 제네릭스 쓰는 곳에는 꼭 타입을 써주자  
지금까지는 ArrayList list = new ArrayList(); 이렇게 썼지만  
앞으로는 
```java
ArrayList<Object> list = new ArrayList<Object>(); 
```
이렇게 꼭 써주자  
  
### 생성자에 \<Tv>는 생략 가능  
다이아몬드 연산자라고도 하는데  
생성자에서 \<\> 안에 내용은 생략 가능하다  
```java
ArrayList<Tv> tvList = new ArrayList<>();  // JDK 1.7부터 가능
```
	
	
### 제네릭스 장점  
1. 타입 안정성 증가
2. 형변환의 번거로움 줄여줌 -> 코드 간결해짐   

형변환을 잘못하면 ClassCastException 형변환 예외가 발생한다  
근데 이러한 문제를 제네릭스를 통해 막을 수 있어서 코드가 간결해진다  
![image](https://user-images.githubusercontent.com/101965836/166193815-d767093b-51e6-4e5d-8003-b293b7547a4d.png)   

실행시에 이런 예외들이 발생하는 것 보다   
컴파일시에 발생하는 것이 좋으니까  
컴파일로 잡을 수 있다는것이 큰 장점이 된다  
  
	
## 12-2 타입 변수  
클래스 작성할 때, Object 타입 대신 타입 변수(E)를 선언해서 사용  
  
![image](https://user-images.githubusercontent.com/101965836/166194062-4c866fea-498e-4d22-9e78-9f6b0ad0766e.png)  
옛날에는 위처럼 Object라고 다 써줬어야 했는데  
타입 변수를 통해서 제네릭 클래스를 사용할 수 있다  
  
타입변수는 보통 관례적으로 Type의 T 또는 Element의 E를 쓴다  
  
	
## 12-3 타입 변수에 대입하기  
객체 생성시, 타입변수 대신 실제 타입을 지정    
```java
ArrayList<Tv> tvList = new ArrayList<Tv>();
```
제네릭스 써주는 곳이 곧 타입변수 위치인 것이다   
    
### 형변환 생략 가능		
옛날에는 Object 같은 식으로 인자를 받아왔기 때문에  
반환도 어쩔 수 없이 Object 형으로 했어야 했고  
사용자가 return을 받을 때 마다 계속 형변환을 해서 아래와 같이 코드를 써줬어야 했다   
```
Tv t = (Tv)tvList.get(0);
```
  
근데 타입변수 덕분에 return의 타입도 가변적으로 타입변수를 통해 가능하게 되면서  
저런 형변환 없이 그냥 바로 받을 수 있게 된것이다  
```
public class ArrayList<E> extends AbstractList<E> {
	...
	public E get(int index) // 반환형을 E로 타입변수로 정할 수 있다. 
	...
}
```
이런 코드가 E를 받아서
```
public class ArrayList<Tv> extends AbstractList<Tv> {
	...
	public Tv get(int index) // 반환형이 E에서 Tv로 가변적으로 바뀐다 
	...
}
```
이렇게 반환타입이 가변적으로 바뀌는 것이다.  
굳   
  
  
  	
## 12-4 제네릭스 용어  
![image](https://user-images.githubusercontent.com/101965836/166194872-b0d3dcd5-2edf-40ad-9e96-26206f0e03d3.png)  
Box\<T> : 제네릭 클래스. **"T의 Box"** 또는 **"T Box"** 라고 읽는다    
T : 타입 변수 또는 타입 매개변수 (T는 타입 문자)    
Box : 원시 타입(raw Type)   
```
Box<String> b = new Box<String>();
```
이렇게 생성하면 된다   
여기서 \<T> 부분에 들어가는 타입을 **대입된 타입(매개변수화된 타입, parameterized type)** 이라고 한다  
  
	
## 12-5 제네릭 타입과 다형성  
참조 변수와 생성자에 대입된 타입은 일치해야 한다   
즉 **다형성으로 퉁쳐서 제네릭스 안에 넣는건 안된다**  
```
// 정직하게 이렇게 제네릭스 타입 일치해야함
ArrayList<Tv> 		list = new ArrayList<Tv>();  // OK

// 다형성 퉁치기 안됨
ArrayList<Product> 		list = new ArrayList<Tv>();  // 에러. Product가 조상이고 Tv가 자손일지라도 안됨
```
  
### 다만, 제네릭 클래스간 다형성은 성립  
```
List<Tv> list = new ArrayList<Tv>();
```
List가 조상, ArrayList가 자손이며, 클래스간 다형성은 성립한다  

### 매개변수 다형성도 성립한다  
```java
ArrayList<Product> list = new ArrayList<Product>();
list.add(new Product());
list.add(new Tv());
list.add(new Audio());
```
다만 이렇게 되면   
list에서 get 해올때 return 타입은 \<Product\> 이므로  
형변환을 해서 가져와야한다  
```java
Product p = list.get(0);
Tv t = (Tv)list.get(1);  
```  
  
	
## 12-7 Iterator\<E>
클래스를 작성할 때, Object타입 대신 T와 같은 타입 변수를 사용하도록 바뀌었다  
  
옛날에는 Iterator가 아래와 같은 식으로 쓰여져 있었다   
```java
public interface Iterator {
	boolean hasNext();
	Object next();
	void remove();
}
```
그러나 제네릭스가 도입된 이후 다음과 같이 변했다   
```
public interface Iterator<E> {
	boolean hasNext();
	E next();
	void remove();
}
```
이에 따라서 Iterator를 사용할 때 형변환을 할 필요가 없어졌다  
   
	 
예를 들어 과거에는 아래와 같이 사용했었다  
```java
Iterator it = list.iterator();
while(it.hasNext()) {
	Student s = (Student)it.next();
	...
```
하지만 제네릭스가 나온 이후 아래와 같이 변했다  
```java
Iterator<Student> it = list.iterator();
while(it.hasNext()) {
	Student s = it.next();
	...
```
보다시피 형변환을 일일이 써 줄 필요 없이   
선언 또는 생성 할 때만 딱 Student 형이라고 써주기만 하면 되니까  
(1) 타입 체크 (2) 형변환 실수 같은 것들을 줄일 수 있게 된다   
매우 굳  

## 12-8 HashMap\<K,V\>
여러 개의 타입 변수가 필요한 경우, 콤마를 구분자로 선언한다   
   
HashMap 같은 경우 Key와 Value로 2종류 타입이 필요하기 때문에   
이렇게 두 가지 타입 변수가 필요하다  
  
	
HashMap의 구현 부분을 간단하게 보면 아래와 같다
```java
public class HashMap<K,V> extends AbstractMap<K,V> { 
	...
	public V get(Object key) { ... }
	public V put(K key, V value) { ... }
	public V remove(Object key) { ... }
	...
}
```
근데 여기서 보면 get에서 K로 key를 안받고 이상하게 Object로 받는다.   
이건 왜그렇냐면 뭐 대단히 문법적이고 그런 내용은 아닌데   
get(Object key) 에서 안에 hash와 관련된 메서드를 사용하는 부분이 있는데  
여기서 hash() 라는 메서드가 Object 타입으로 값을 받기 때문에  
hash(Object o) 로 값을 줘야한다  
근데 여기다가 굳이 \<K|>로 형변환 했다가 다시 또 (Object)key 로 또 바꾸고... 하면  
불필요하게 형변환이 일어나기 때문이다  
그래서 그냥 Object로 받는 거다.  
  
## 12-9 제한된 제네릭 클래스  
extends로 대입할 수 있는 타입을 제한할 수 있다.  
예를 들어  
```java
class FruitBox\<T\> { 
	ArrayList<T> list = new ArrayList<T>();
	...
} 
```
라고 했는데   

``` 
FruiteBox<Elephant> BigElephant = new FruitBox<Elephant>();
```
이렇게 코끼리가 과일박스에 들어가버릴 수 있다.  
(Elephant가 FruiteBox에 들어가는 것은 의도한 바가 아니다)  
따라서 \<T\>로 넘어오는 형식을 제한하기 위해서, 특정 클래스의 자손만 가능하도록 할 수 있다  

### 제한된 제네릭스 지정하기  
간단하게, extends로 제한한다  
```java  
class FruitBox<T extends Fruit> { 
	ArrayList<T> list = new ArrayList<T>();
	...
}
```
이렇게 타입을 제한하면   
```java 
FruitBox<Apple> appleBox = new FruitBox<Apple>();
// 에러  
// FruitBox<Elephant> elephantCase = new FruitBox<Elephant>();  
```
이렇게 제한할 수 있게 된다    
  
	
### 인터페이스인 경우에도 extends로 제한한다  
```
interface Eatable {}
calss FruitBox<T extends Eatable> { ... }
```
implements 안쓰고 extends로 쓴다  
  
	
## 12-11 제네릭스의 제약   
타입 변수에 대입은 인스턴스 별로 다르게 가능하다     
```java
Box<Apple> appleBox = new Box<Apple>();
Box<Grape> grapeBox = new Box<Grape>();
```
  
	
### (1) static멤버에 타입 변수 사용 불가  
```java
class Box<T> {
	static T item; // 에러
	static int compare(T t1, T t2) { ... } // 에러
	...
```

### (2) 배열 생성할 때 타입변수 사용 불가 
쉽게 말해서 **new 다음에 T가 오면 안된다**    
```java
class Box<T> { 
	T[] itemArr;  // OK. T타입 배열을 위한 참조 변수  
			...
	T[] toArray() {
		T[] tmpArr = new T[itemArr.length];  // 에러. 제네릭 배열은 생성 불가능하다  
```
이건 왜 그럴까 추측해보면  
new로 배열을 생성하려면 메모리 할당 문제도 있기 때문이라고 생각한다  
예를 들어 int형으로 크기 5짜리 배열을 만들게 되면  
메모리에서 4byte \* 5 = 20byte 만큼 할당해야 한다.  
하지만 여기서 형이 지정되어 있지 않으면  
얼마짜리 크기로 메모리에서 배열에 할당해야 할 지 알 수 없으므로  
에러를 발생시키는 것 같다   
  
##### 정리하자면, new 연산자 뒤에 T는 안된다
new는 객체나 배열을 생성하는 놈이기 때문이다.   
근데 T\[] itemArr 같은건 상관없다.  
뇌피셜로 왜 그럴까 생각해보면  
요거는 참조변수이므로 그냥 주소를 가리키는 참조형은   
안에 들어가는 내용이 메모리 주소이므로   
얼마나 메모리 공간을 변수에 할당할지 명확하기 때문인 것 같다   
