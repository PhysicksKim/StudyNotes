[자바의정석 기초편 강의로 이동](https://www.youtube.com/playlist?list=PLW2UjW795-f6xWA2_MUhEVgPauhGl3xIp)  

# 6. 객체지향 프로그래밍 I

## 6-2 클래스와 객체
Q. 클래스가 왜 필요함?    
A. 객체를 생성하기 위해서  
  
Q. 객체가 왜 필요한가?  
A. 객체를 사용하기 위해서    
  
Q. 객체를 사용한다는 게 무슨뜻?  
A. 객체가 가진 속성(프로퍼티;변수)과 기능(매서드;함수)을 사용하려고  

Q. 왜 클래스를 만들어서까지 사용해야함?  
A. 비슷한 속성과 기능을 가졌지만 설정 값 같은 것들만 다른 녀석들을 여럿 찍어내서 사용하려고  

## 6-3 객체의 구성요소 - 속성과 기능
어떤 사물이 있으면 그 사물의 속성과 기능이 있다.  

Tv  
- 속성 : 크기 길이 높이 색상 볼륨 채널 등
- 기능 : 켜기 끄기 볼륨조절 채널변경 등 

속성(property) - 멤버변수(variable)  
기능(function) - 메서드(method)   
  
## 6-4 객체와 인스턴스   
#### 인스턴스   
어떤 클래스로부터 만들어진 객체  
#### 인스턴스화    
클래스로부터 객체를 만드는 과정을 인스턴스화(instantiate)라고 한다.   

객체와 인스턴스는 거의 같은 말.   
서로 차이는.  
```
책상은 객체다  
책상은 책상 클래스의 인스턴스다
```
인스턴스는 클래스로부터 만들어졌음을 강조하는 의미가 담겨있다.  
두 용어를 엄밀히 구분할 필요까지는 없지만, 문맥에 따라 구별하는게 좋다.   

## 6-5 하나의 소스 파일에 여러 클래스 작성 
파일 이름과 public, 대소문자구분 정도만 유의하면 된다.

1. public class 가 있다면, 해당 클래스와 파일 이름이 일치해야 한다.   
2. public class 가 없다면, 파일 이름은 어떤 클래스의 이름이건 가능하다.   
3. public class는 하나의 파일에 하나만 존재 가능하다.   
4. 대소문자 일치해야한다.   
  
## 6-6 객체의 생성과 사용

### 1. 객체의 생성
```
클래스명 변수명;
변수명 = new 클래스명();
```
```
Tv t; // Tv 클래스 타입의 참소변수 t를 선언
t = new Tv();  // Tv 인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```
이걸 한줄로 쓰면
```
Tv t = new Tv();
```
### 2. 객체의 사용
```
t.channel = 7;
t.channeldown();
System.out.println("현재 채널은 " + t.channel + " 입니다.");
```

## 6-7 생성과 사용 예제 - (실제로 메모리 상에서 어떻게 생겼는지)

```
Tv t = new Tv();
```
Tv t로 생성된 t는 참조 변수가 생성됨. 그 다음 new에 의해서 Tv클래스 설계도에 따라서 Tv형식 인스턴스가 생성됨. 그리고 대입연산자 =에 의해서 t가 새로 생성된 Tv()형식 인스턴스를 가리키게됨.  
  
  
생성된 인스턴스는 가비지 컬랙터가 알아서 관리(필요 없어지면 삭제) 해줌. 이 점에서 C++보다 편리함.      

## 6-8 객체 배열
객체 배열 생성
```
Tv tv1, tv2, tv3;
Tv tvArr = new Tv[3];
tvArr[0] = tv1;
tvArr[1] = tv2;
tvArr[2] = tv3;
```
배열 초기화 아래와 같이도 가능
```
Tv tvArr = {new Tv(), new Tv(), new Tv()}; 
```

## 6-9 클래스의 정의(1)
클래스는 아래의 3 가지 용도로 쓰인다  
1. 설계도
2. 데이터와 함수의 결합
3. 사용자 정의 타입
  
=> 클래스 == 데이터 + 함수  

처음에 데이터를 저장하는 방식은 **변수** 만 있었다.  
그런데 같은 종류를 묶어서 쓰고 싶어서 **배열** 이 나왔다.  
근데 서로 다른 타입의 데이터들도 하나로 묶고 싶어서 **구조체** 가 나왔다.  
   
여기서 더 나아가서  
관련있는 **데이터들** 뿐만 아니라 **함수** 도 같이 묶고 싶어졌다. 그래서 
#### 클래스 
가 나왔다

## 6-10 클래스의 정의(2)
앞서 클래스 용도에서 **사용자 정의 타입** 으로도 쓰인다고 했다.  
즉 원하는 타입을 만들 수 있다.  
  
  
예를 들어 **시간** 데이터들을 처리해야 한다고 해보자  
```
int hour1, hour2, hour3;
int minute1, minute2, minute3;
int second1, second2, second3;
```
이렇게 일일이 다 따로따로 나뉘어 있으면 너무 귀찮게 된다.
따라서 아래와 같이 사용자 정의 타입으로 Time 클래스를 정의할 수 있다.
```
Time t = new Time();
Time[] timeArr = {new Time(), new Time(), new Time()};
```
이렇게 아주 간결하게 만들어 질 수 있다.  

## 6-11 선언 위치에 따른 변수의 종류
<strong>어디에서 선언</strong>됐는가에 따라서 <strong>3가지</strong>로 나뉜다.  
영역은 **1.클래스영역** **2.메서드영역** 으로 나뉜다. 
  
```
class Variables
{
  int iv;         // (1) 인스턴스 변수 instance variable
  static int cv;  // (2) 클래스 변수(static 변수, 공유 변수)
  
  void method()
  {
    int lv = 0;   // (3) 지역 변수 local bariable
  }
}
```

여기서 상식적으로 일단 lv는 메서드가 실행 될 때 생성되고, 메서드 안에서 선언 될 것이다.   
  
  
그러면 클래스 영역에 있는 in와 cv는 어떻게 될까?  
먼저 iv는 **인스턴스가 생성** 될 때 생성된다. 각 인스턴스가 개별적으로 iv값을 갖게된다. 예를 들어서 tv1.channel == 3이고 tv2.channel == 4 일 수 있다.  
반면 cv는 **클래스가 갖는 값** 이므로 **클래스가 메모리에 올라갈 때** (달리 말하면, 클래스가 정의될 때) 생성된다.   

## 6-12 클래스 변수와 인스턴스 변수

**선언 위치** 에 따라서 변수가 달라진다 했다. 
1. 클래스 영역
2. 메서드 영역 
  
그럼 클래스 변수와 인스턴스 변수가 어떻게 다른지 알아보자  

![image](https://user-images.githubusercontent.com/101965836/164894339-97d78f28-d5fe-45a2-8175-aa6ddcc23b3e.png)  
![image](https://user-images.githubusercontent.com/101965836/164894356-f36eb891-b90b-408c-9655-df4cea072b71.png)  
카드의 높이와 폭은 공통적으로 같아야 한다. 따라서 클래스 변수(static)로 선언한다.     
카드의 무늬나 숫자는 카드마다 달라야 한다. 따라서 인스턴스 변수로 선언한다.  

```
Card c = new Card();
c.kind = "HEART";
c.number = 5;

// c.width = 200; 가능은 하나 권장하지 않는 방법
// c.height = 300;

Card.width = 200;
Card.height = 300;
```


## 6-14~19 메서드란? 메서드 선언 구현 호출 실행 흐름
기본적인 메서드 내용이라 생략

## 6-20 return문
반환 타입이 void이면 return 생략 가능  
void가 아닌 경우 반드시 return문 필요  
```
int max(int a, int b) {
  if(a > b)
    return a;
}
```
이런 경우 if가 false일 때 return문이 없으므로 에러가 난다. 따라서 분기가 나뉘면 모든 경우에 return이 있도록 해야한다.  

## 6-21 반환값
반환 형이 일치해야한다. 또는 자동 형변환이 가능해야한다.  

## 6-22 호출 스택(call stack)
  ![image](https://user-images.githubusercontent.com/101965836/164895231-a6af2c10-7577-4bf2-9a88-937906ff8705.png)  
메서드가 호출 될 때마다, 콜 스택에 쌓이게 된다. 콜 스택에서는 한 번에 하나의 메서드만 실행되며, 실행이 끝난 메서드는 사라지게 된다.   
  
  
## 6-23 기본형 매개변수
메소드의 매개변수 타입이 기본형이라는 뜻.  
- 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.  (Read)
(int 같은 것들)
- 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.  (Read & Write)
(배열 같은 것들)


## 6-24 참조형 매개변수
![image](https://user-images.githubusercontent.com/101965836/164895783-10f16311-5e1f-4dcc-884a-1bab681142a9.png)

### 참조형 반환타입
![image](https://user-images.githubusercontent.com/101965836/164895802-b02ee9fc-3e32-4cf1-9bb3-46bbefe44967.png)  

## 6-26 ~ 29 static 메서드 & 인스턴스 메서드

|인스턴스 메서드 | static 메서드 |
|--------------|---------------|
|인스턴스 변수 사용 가능|인스턴스 변수 사용 불가|
|참조변수.메서드이름()|클래스이름.메서드이름()|

static 메서드는 instance variable을 사용하지 않을 때 쓴다. 딱 이 차이밖에 없다. 메서드 안에서 iv를 써야하면 인스턴스 메서드로 만들어야 하고, iv를 안 쓰면 static으로 만들어도 된다.  

### static 메서드는 인스턴스 변수(iv)를 사용할 수 없다
왜?  
static 메서드는 객체가 생성되지 않았을 때도 사용이 가능하다 ex. Math.random()  
근데 만약, 객체를 생성하지 않은 채로 static 메서드에서 인스턴스 변수를 사용한다면?  
인스턴스 변수가 아직 초기화 되지 않았는데, 인스턴스 변수를 갖고와야 하기 때문에 에러가 난다.  
따라서 인스턴스 변수는 static 메서드에서 사용될 수 없다.  
매개변수로 값을 받아와서 사용하거나 static 변수를 사용하는 메서드로만 만들어야 한다.   

### 메서드간 호출과 참조
인스턴스 메서드에서는 다른 인스턴스 메서드나 static 메서드를 호출 할 수 있다.  
다른 인스턴스 메서드는 객체를 생성할 때 같이 생성 됐기 때문이다. static 메서드는 어차피 항상 호출 가능한 메서드이므로 문제없다.  
   
반면 static 메서드는 인스턴스 메서드를 호출할 수 없다. 당연히 인스턴스가 선언되지 않은 경우에 에러가 나기 때문이다.  

### 정리
1. static 메서드에서 static 메서드 호출 => O
2. static 메서드에서 인스턴스 변수 사용 => X
3. static 메서드에서 인스턴스 메서드 호출 => X


## 6-30,31 메서드 오버로딩(overloading)
같은 이름의 메서드를 여러 개 정의하는 것  
![image](https://user-images.githubusercontent.com/101965836/164896354-a060e56c-53a9-4e33-9660-2a292949fa1e.png)  

### 오버로딩 성립 조건
1. 메서드 이름이 같아야 함
2. 매개변수 개수 또는 타입이 달라야 함

**반환 타입은 상관없음**  
예를 들어, 
```
int add(int a, int b) { return a+b; }
long add(int a, int b) { return (long)(a+b); }
```
이 경우 반환 타입은 상관 없으므로 오버로딩이 정의되지 않는다.  
왜? 호출 될 때 myClass.add(10,20); 으로 호출 될 텐데, 언제 int 반환 타입으로 쓸지 long 반환 타입으로 쓸 지 모호하기 때문이다.  

## 6-32~35 생성자, 기본 생성자
### 생성자
생성자는 이름이 클래스 이름과 같아야 한다  
생성자도 오버로딩 가능  
```
class Card {
  Card() {
  
  }
  Card(String kind, int number){
  
  }
}
```


### 기본 생성자 (= 매개변수가 없는 생성자)
```
Card c = new Card()
```

생성자가 하나도 없을 때만 컴파일러가 기본 생성자를 자동으로 추가한다.  
반대로 생성자가 한 개라도 있을 경우, 기본 생성자 Card() 같은 식으로 만들어 놓지 않고서 기본 생성자 처럼 호출하면 에러가 난다  
```
// 에러나는 경우
class Card {
  String kind;
  Card(String k){
    kind = k;
  }
}
...
  
  // Card c = new Card(); //에러
  
```

### 매개변수가 있는 생성자

## 6-36,37 생성자 this() 참조변수 this
### 생성자 this()
생성자에서 다른 생성자 호출할 때 사용한다
![image](https://user-images.githubusercontent.com/101965836/164897622-1ebbffee-9ebb-450b-afa2-a16ed05ad743.png)  

**반드시! 생성자 호출시 첫 줄에서만 사용가능**

```
Car(String color) {
  door = 5; // (1) 첫 줄에 this()를 쓰지 않아서 에러!
  Car(color, "auto", 4); // (2) this()라고 쓰지 않고 클래스이름()으로 써서 에러!
}
```

### 참조변수 this
생성자 this()랑은 관련 없음  
  
  
- 인스턴스 자신을 가리키는 참조변수
- 인스턴스 메서드에서 사용 가능 + 생성자에서도 사용 가능
- 지역변수(lv)와 인스턴스 변수(iv)를 구별할 때 사용  

## 6-38~41 변수 초기화, 멤버변수 초기화
### 1. 명시적 초기화 (=)
```
class Car {
  int door = 4;             // 기본형 변수의 초기화 (primitive type)  
  Engine e = new Engine();  // 참조형 변수의 초기화 (reference type)  
  ...
}
```
참조형 변수는 기본은 null 값을 가지므로, 객체 주소 값을 갖도록 초기화 해줘야 한다.   
Engine e; 라고만 해버리면 null 값을 갖게 된다.  

### 2. 초기화 블럭
복잡한 초기화에서 사용한다. 괄호 안에 여러 문장을 넣을 수 있다.  
- 인스턴스 초기화 블럭 : { }  
- 클래스 초기화 블럭 : static { }  

### 3. 생성자  
iv 초기화에 사용. 복잡한 초기화에 사용.  

  
정리하면  
1. 자동초기화
2. 간단초기화
3. 복잡초기화  

### 멤버변수의 초기화
클래스 변수 초기화 시점 : 클래스가 처음 로딩될 때 단 한번(메모리에 올라갈 때)  
인스턴스 변수 초기화 시점 : 인스턴스가 생성될 때 마다
  
  ---
  
  <br><br><br><br><br><br><br><br><br><br>
  
  ---
  
# 7. 객체지향 프로그래밍 II

## 7-1,2 상속(Inheritance)
기존 클래스로 새로운 클래스를 만드는 것    
  
두 클래스는 부모와 자식 관계를 갖는다.  

```
class Parent {}
class Child extends Parent {
  // ...
}
```

- 자손은 조상의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)   
- 자손의 멤버 수는 조상보다 적을 수 없다.  

![image](https://user-images.githubusercontent.com/101965836/164959195-4797ad22-645b-4589-b89d-1513e73b9764.png)  
  
- 자손의 변경은 조상에 영향을 미치지 않는다.  
  
![image](https://user-images.githubusercontent.com/101965836/164959249-06a6472e-ef06-4623-95c3-0ec6bf0833ff.png)
  
  
### 그냥 부모 멤버들을 다 별개로 상속 받는다
![image](https://user-images.githubusercontent.com/101965836/164959389-00083428-0b39-4961-a86f-e992e921b6c3.png)  
(1)방식이든지 (2)방식이든지 둘 다 똑같이 자신만의 x,y,z 멤버를 갖는다.  
단 상속받는경우 부모가 변경되면 자식도 변경된다.  

## 7-3,4 포함관계
### 포함(composite)이란?
클래스 안에 멤버로다가 다른 클래스를 선언해서 쓰는 것.  
```
class Point {
  int x; 
  int y;
}
class Circle {
  Point c = new Point();
  int r;
}
```
Point 클래스를 사용해 참조변수 c를 생성했다.  
  
### 클래스간 관계 결정하기
상속관계 : "~은 ~이다" (is - a)  
포함관계 : "~은 ~을 가지고 있다" (has - a)  
  
## 7-5,6 단일상속, Object클래스
### Java는 단일상속만 허용
(c++은 다중상속 허용)  
```
class TvDVD extends Tv, DVD { } // 에러
```
Tv와 DVD 둘 다 상속하면 편할 수 있다. 하지만 기존 C++에서 다중 상속이 갖는 문제점 때문에 프로그래머들이 JAVA에서는 단일상속만 가능하도록 했다.  

예를 들어, Tv와 DVD 둘 다에서 void power() 라는 메서드가 있으면 충돌이 발생하게 된다.  
이러한 상속 구조가 복잡해지면 충돌문제를 해결하기 어려워진다.  
인터페이스를 이용하면 충돌문제를 해결하면서 다중상속과 같이 작성할 수 있다.  
비중이 높은 클래스 하나만 상속받고, 나머지는 포함관계로 한다.   
![image](https://user-images.githubusercontent.com/101965836/164959851-c305365a-a18c-4b71-99b9-bc855145eeda.png)  

### Object클래스
모든 클래스의 조상  
부모가 없는 클래스는 자동적으로 Object 클래스의 상속을 받게된다.  
```
class Tv {  // class Tv extends Object 와 같음
  // ...
}
```
Object 클래스에 정의된 11개의 메서드를 상속받는다.  
11개가 뭔지 다 알 필요는 없고, 대표적으로 toString() equals(Object obj) hashCode() 정도 알아두면 되며, 9장에서 배운다.  
  
  
## 7-7~9 오버라이딩
### 메서드 오버라이딩(overriding)
override 덮어쓰다  
  
상속받은 조상 메서드를 덮어쓰는 것   
선언부는 변경할 수 없고, 구현부만 변경 가능하다.  
구현부는 {}안에 있는 내용을 말한다.  
매개변수를 바꿔서 또 쓰는건, 오버라이딩이 아니라 오버로딩이다.  
```
class Point {
  int x;
  int y;
  String getLocation() {
    return "x :" + x + ", y :"+ y;
  }
}

class Point3D extends Point {
  int z;
  
  String getLocation() {
    return "x :" + x + ", y :" + y + ", z :" + z;
  }
}
```
이렇게 하면 Point.getLocation() 이랑 Point3D.getLocation()이랑 동일한 의도로 동작하기 때문에 직관적인 코드가 된다.  

### 오버라이딩 조건
#### 1. 선언부가 조상 클래스의 메서드와 일치해야 한다.  
![image](https://user-images.githubusercontent.com/101965836/164960145-f2a87ac2-f51d-44ea-a567-ed9648ec956d.png)  
선언부 일치! 선언부 = (1) 반환 타입 (2) 메서드 이름 (3) 매개변수 목록    
#### 2. 접근 제어자를 조상 메서드보다 좁은 범위로 변경할 수 없다.
접근 제어자 = public protected (default) private
#### 3. 예외는 조상 메서드보다 많이 선언할 수 없다.  
![image](https://user-images.githubusercontent.com/101965836/164960200-97c6ecd2-7b87-4a19-8a84-7ca0f31690f5.png)  
예외는 지금 이해는 안되겠지만, 8장가서 배우게 된다.  

### 오버로딩 vs 오버라이딩
오버로딩(overloading) 이름만 같을 뿐 새로운 메서드를 정의하는 것(new) 상속이랑 전혀 관련없음  
오버라이딩(overriding) 상속받은 메서드의 내용을 변경하는 것(change, modify) 상속과 관계있음  

## 7-10,11 참조변수 super
this와 거의 같다  
객체 자신을 가리키는 참조변수, 인스턴스 메서드(생성자) 내에만 존재 (static에서 사용 불가)  
this는 lv와 iv 구별에 사용하고  
super는 조상멤버와 자신멤버를 구별할 때 사용한다.  
  
예를 들어 이름이 같은 멤버 변수를 가지는 경우, 조상의 멤버 변수를 선택 할 때 사용된다.   

### 예시
(1) 조상 자식 둘 다 x라는 이름의 변수가 있는 경우
```Java
class Ex7_3 {
  public static void main(String args[]){
    Child c = new Child();
    c.method();
  }
}

class Parent { int x = 10; }

class Child extends Parent {
  int x = 20;
  
  void method() {
    System.out.println("x=" + x);             // x=20
    System.out.println("this.x=" + this.x);   // this.x=20
    System.out.println("super.x=" + super.x); // super.x=10
  }
}
```
(2) 조상 자식 둘 다 x라는 이름의 변수가 있는 경우
```Java
class Ex7_3 {
  public static void main(String args[]){
    Child2 c = new Child2();
    c.method();
  }
}

class Parent2 { int x = 10; }

class Child2 extends Parent2 {
  
  void method() {
    System.out.println("x=" + x);             // x=10
    System.out.println("this.x=" + this.x);   // this.x=10
    System.out.println("super.x=" + super.x); // super.x=10
  }
}
```  
### super() - 조상의 생성자 
super랑은 전혀 관련 없다.  
조상의 생성자를 호출할 때 사용한다.  
**super()는 왜 있는거임?**  
-> 생성자와 초기화블럭은 상속이 안되기 때문에 필요하다.   
  
```Java
class Point {
  int x, y;
  
  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}

class Point3D extends Point {
  int z;

  Point3D(int x, int y, int z) {
    super(x, y);
    this.z = z;
  }
}
```  
조상의 멤버를 직접 this.x = x; 같은 식으로 초기화해버리면 안좋다.  
왜? 조상 멤버의 초기화는 조상 생성자가 해야지 코드가 안꼬인다.  
  
## 중요  
### super() 사용시 유의사항
생성자의 첫 줄에 반드시 생성자를 호출해야 한다.  
그렇게 안하면? 컴파일러가 생성자의 첫 줄에 super();를 삽입한다.  
![image](https://user-images.githubusercontent.com/101965836/164960773-10138c32-021a-4fff-ade5-9f1e7d62940d.png)  

### 예시 
![image](https://user-images.githubusercontent.com/101965836/164960825-b35feb22-ef06-47a6-9192-353aea20dfcf.png)  

에러가 왜 났을 까?  
모든 생성자는 첫 줄에 다른 생성자를 호출해야 한다.  
그렇지 않으면? super(); 를 넣어주게 된다.  
  
Point 클래스의 생성자는 super();가 자동으로 들어가고, super의 정체는 Object(); 이다.  
왜냐하면 따로 상속하는 클래스가 없으면 Object를 자동으로 상속하기 때문이다.  
  
  
근데 Point3D의 생성자에서도 첫줄에 따로 생성자를 호출하지 않는다.  
따라서 super();가 자동으로 들어가게 된다.  
근데 Point3D의 조상은 Point클래스인데, Point클래스에는 super(); // = Point(); 라는 생성자가 없다.  
따라서 에러가 발생하게 된다.  

### 해결방안
1. Point() 생성자를 추가한다
2. super(x,y)를 추가한다.  

근데 기본 생성자 ()를 추가해주는 편이 어지간하면 좋다.  

## 7-12~14 패키지, 클래스 패스  
### 패키지란?  
- 서로 관련된 클래스의 묶음

### 패키지는 어떤 구조로 저장되어있나?
- 클래스는 .class 파일에 저장됨
- 패키지는 폴더에 저장됨
- 하위 패키지는 하위 폴더에 저장됨  

### 클래스의 진짜 이름
- 진짜 이름은 사실 패키지를 포함한다 (ex. java.lang.String)

### rt.jar 파일
- 클래스들을 압축한 파일 (JDK 설치경로의 \jre\lib에 위치)
- Java9부터 없어짐 (9부터 module 개념이 들어가는데, rt.jar이 너무 커서 module로 나뉘게 된다)  

### 패키지 선언
- package (패키지 이름); 으로 선언
```
package mypackage;
```
- 소스파일의 첫 문장에서 선언 해줌
- 단 한번만 선언 
- 그 소스파일 안의 클래스들은, 해당 패키지 아래에 속하게 된다
- 패키지 선언이 없으면, 이름 없는 패키지에 속하게 된다. (default package)   
![image](https://user-images.githubusercontent.com/101965836/164964687-bfb4d3ac-83d3-4547-a4ec-29fed1722faf.png)  
  
### 클래스 패스
클래스 파일의 위치를 알려주는 경로   
OS의 환경 변수에다가 classpath를 추가해주면 일일이 클래스 패스를 입력하지 않아도 자동으로 환경 변수 안에있는 path에서 해당 클래스 이름을 인식하게 된다.    

## 7-15,16 import문 static import문
### import문 예시
```
import 패키지명.클래스명;
import 패키지명.*; // 모든 클래스
```

### import문
- 클래스를 사용할 때 패키지이름을 생략할 수 있다.    
- 컴파일러에게 클래스가 속한 패키지를 알려준다.    
- 단축키 \[ **ctrl + shift + O** ] 를 누르면 자동으로 import 문이 만들어 진다.  

### 예시
```
java.util.Date today = new java.util.Date();
```
이런 식으로 일일이 다 칠 필요없이
```
import java.util.Date;

class ImportTest {
  Date today = new Date();
}
```
이렇게 import를 넣어서 간단하게 줄일 수 있다.  

### java.lang 패키지는 생략가능
String 같은 패키지들은 생략가능  

### import문은 패키지문과 클래스선언 사이에 위치
```
package mypackage;

import java.util.*;

public class PackageTest {
  ...
}
```

### import 많이 써도 성능에 영향 없음
어차피 컴파일러에게 import할 위치를 알려주는 작업이므로 성능과 무관하다. 그냥 컴파일 할때만 더 오래걸릴 뿐, 런타임에서는 상관없다.  

### static import문
![image](https://user-images.githubusercontent.com/101965836/164966587-846c9bee-1a16-49a0-ace2-a526ecff95d7.png)  


## 7-17~20 제어자 static final abstract

### 제어자 (modifier)
- 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여  

접근제어자 : public, protected, (default), private  
그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp  
  
- 접근 제어자는 하나만 쓸 수 있다  
- 그 외 제어자들은 여러 제어자를 같이 쓸 수 있다  
- 제어자의 순서는 상관없지만, 관례적으로 접근 제어자를 제일 앞에 쓴다  

### static 
- 클래스의, 공통적인 이라는 뜻
- 클래스 외에도, 클래스 변수, 클래스 초기화 블럭, 클래스 메서드에도 사용된다.  

### final
- 마지막의, 변경될 수 없는 이라는 뜻
  
final의 대상 : 클래스, 메서드, 멤버변수, 지역변수  

```
final class FinalTest {       // 조상이 될 수 없는 클래스
  final int MAX_SIZE = 10;    // 값을 변경할 수 없는 멤버변수(상수)
  
  final void getMaxSize() {   // 오버라이딩 할 수 없는 메서드(변경불가)
    final int LV = MAX_SIZE;  // 값을 변경할 수 없는 지역변수(상수)
    return MAX_SIZE;
  }
}
```
final 클래스는 예를 들어 String이나 Math 등이 있다.  
  
  
### abstract
- 추상의, 미완성의  
abstract의 대상 : 클래스, 메서드  
```
abstract class AbstractTest { // 추상 클래스 (추상 메서드를 포함한 클래스)
  abstract void move();       // 추상 메서드 (구현부가 없음)
}
```
추상(미완성) 클래스란 추상 메서드를 갖고 있는 클래스를 말한다  
추상 메서드란 아직 구현부를 완성하지 않은 메서드를 말한다  
따라서 추상 클래스는 인스턴스를 생성할 수 없다  
```
AbstractTest a = new AbstractTest(); // 에러. 
```
#### 그러면 추상 클래스는 언제 쓰냐?
추상클래스를 상속받아서 완전한 클래스를 만든후에 객체 생성이 가능하다  
이 내용은 나중에 또 다시 설명한다  

## 7-21 접근제어자
(access modifier)
|접근제어자|설명|
|---|---|
|private| 같은 클래스 내에서만 접근 가능 |
|(default)| 같은 패키지 내에서만 접근 가능|
|protected| 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근 가능 |
|public| 접근 제한 없음 |
  
![image](https://user-images.githubusercontent.com/101965836/164968070-77d46b12-dbee-4e5d-898e-02b6c843b511.png)   
![image](https://user-images.githubusercontent.com/101965836/164968681-2a1527c0-7edf-453a-870f-28133249a9f5.png)    
  

## 7-22 캡슐화
접근 제어자를 사용하는 이유 : 데이터를 외부로부터 보호하기 위해서 => 이걸 **캡슐화** 라고 한다

## 7-23 다형성(Polymorphism) 
- 여러 가지 형태를 가질 수 있는 능력

#### 다형성이 제일 중요하다
#### 다형성 이해 못하면 뒤에 내용 전부 이해 못함  

### 다형성이 뭔데?
조상 타입 참조 변수로 자식 타입 객체를 다루는 것  


```
class Tv { ... }                  // 부모

class SmartTv extends Tv { ... }  // 자손
```
```
Tv      t = new SmartTv();  // 가능
SmartTv s = new Tv();       // 불가능
```

### 자식 타입 참조가 부모 타입 객체를 가리킬 수 없는 이유 
아래의 논리 순서대로 차근히 생각해보자
1. 부모 타입 클래스보다 자식 타입 클래스에 멤버변수나 메서드가 더 많다 (상속 후 추가로 만들 수 있기 때문)  
2. 참조 변수는 정의되지 않은 것을 가리킬 수 없다
3. 앞서 **1.** 에 따라서 자식 참조 타입은 부모 참조 타입보다 더 많은 것을 가리킨다.
4. 위의 **2.** 와 **3.** 에 따라서, 더 많은것을 가리키는 자식 참조 타입은, 부모 타입 객체를 참조할 수 없다. (왜? 부모 타입에 멤버들이 더 적으니까)  
  
  
### Q&A
#### Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치해야 하나요?
A. No. 일치하는 것이 보통이지만 일치 하지 않을 수도 있습니다.  
#### Q. 참조변수가 조상타입일 때와 자손타입일 때의 차이?
A. 참조변수로 사용할 수 있는 멤버의 갯수가 달라집니다
#### Q. 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 있나요?
A. 아니요. 허용되지 않습니다.  

## 7-24,25 참조변수의 형변환(1)  
사용할 수 있는 멤버 수를 조절하는 것  
  
### 기본형의 형변환과 차이점
기본형의 형변환은? float -> int 같은 경우 **값이 바뀐다**  
그러나  
참조 변수의 형변환은? 값은 안 바뀌고, **멤버의 갯수만** 바뀐다  

### 조상 자손 관계의 참조 변수는 서로 형변환 가능
```
class Car { }
class FireEngine extends Car { }

...

FireEngine f = new FireEngine();
Car c = (Car)f;                 // OK. 부모 참조 <- 자식 참조 변환 (변환형 생략가능)
FireEngine f2 = (FireEngine)c;  // OK. 자식 참조 <- 부모 참조 변환 (변환형 생략불가)
```
### 근데. 이거 대체 왜 있는거임?
**사용할 수 있는 멤버 수를 조절** 하기 위해서   

### 그러면. 자식 타입 참조가 부모 객체를 가리켜도 됨?
=> FireEngine f = new FireEngine(); 말고  
Car c = new Car();로 만들어도됨?  

#### 컴파일은 되지만, 런타임에서 에러가 난다.  
```
Car c = new Car();
FireEngine fe = c; // 여기서 에러 발생. java.lang.ClassCastException

fe.water();
```
![image](https://user-images.githubusercontent.com/101965836/164976906-7bca38d2-92b6-437a-b497-df231dd67601.png)  
  
## 7-26 instanceof 연산자
- 참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환    
  
앞서 봤듯, 형변환이 가능한지 확인하지 않고 형변환 해버리면 에러가 난다.   
  
또한 Object -> Car -> FireEngine 순으로 상속되어 있으니  
  
```jsva
FireEngine fe = new FireEngine();
System.out.println(fe instanceof Object);     // true
System.out.println(fe instanceof Car);        // true
System.out.println(fe instanceof FireEngine); // true
```

### 그래서 instanceof의 핵심은?
1. 형변환이 가능한지 확인 하고 형변환 해야한다.  
2. instanceof는 조상과 자기 자신에 대해서 true를 반환한다  

## 7-27,28 다형성 장점 1 - 매개변수 다형성
이제 본격적으로 왜 다형성을 사용하는지 알게된다  

#### 매개변수 다형성의 장점
1. 다형적 매개변수
2. 하나의 배열로 여러 종류 객체 다루기
가 가능하다.

### 다형성에 대해서 다시 정리
1. Tv t = new SmartTv();  ( 조상 참조 = 자손 객체 )
2. 참조 변수의 형변환 : 한마디로 리모콘 바꾸기. 왜 리모콘 바꿈? 사용가능한 멤버 갯수 조절을 위해서.  
3. instanceoff 연산자 : 왜 씀? 형변환 가능 여부 확인.  

### 그러면 매개변수 다형성은 뭔가? 
Product라는 물건 타입에 대한 부모 클래스가 있고,  
자식으로는 Tv Computer Audio 라는 상품들이 있다고 해보자.  
  
이때 구매하는 사람을 정의하는 Buyer라는 클래스가 있고, Buyer가 buy()라는 메서드를 갖고 있다고 해보자.    
그러면 Buyer는 buy(Tv tv){ } buy(Computer com){ } buy(Audio audio){ }  이렇게 일일이 오버로딩 해야할까?   
아니다. 이 때 다형성을 활용하면, 부모 형식인 Product를 이용해서 buy(Product p){ }로 다 해결할 수 있다.    
  
이게 바로 다형적 매개변수의 장점이다.  
  
  
## 7-29,30 다형성 장점 2 - 여러 종류 객체를 배열로 다루기
다형성을 활용해서 하나의 배열에 여러 종류의 객체를 넣어서 다룰 수 있다.  

```
Product p1 = new Tv();
Product p1 = new Computer();
Product p1 = new Audio();
```
```
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

---

여기까지 정리가 되어 있어야지 뒷 부분을 제대로 이해할 수 있다

---

## 7-31,32 추상 클래스, 추상 메서드
미완성 설계도를 '추상' 이라고 말한다  

### 추상 메서드
몸통(구현부)이 없는 메서드.  

### 추상 클래스
미완성 메서드를 갖고 있는 클래스를 추상 클래스라고 한다.  
그냥 딱, 추상 메서드 갖고 있으면 

```
abstract class Player {         // 추상 클래스
  abstract void play(int pos);  // 추상 메서드
  abstract void stop();         // 추상 메서드
}
```

### 그럼 이걸 어디에 씀?  
다른 클래스 작성에 도움을 주기 위한 것.  
상속을 통해서 추상 메서드를 완성하기 위한 것이다.  
```
class AudioPlayer extends Player {
  void play(int pos) { /* 내용 생략 */ }  
  void stop() { /* 내용 생략 */ }       
}
```
이렇게 추상클래스를 상속받아서 추상 메서드의 구현부를 만들어 주면 이제 제대로 사용할 수 있게 된다.  

### 추상 클래스는 인스턴스 생성 불가
어찌보면 당연하다. 당연히 미완성이니까 쓸 수 없으므로, 인스턴스 생성도 불가능하다
```
Player p = new Player(); // 에러. 추상 클래스는 인스턴스 생성 불가
```
```
AudioPlayer ap = new AudioPlayer(); // OK
Player ap = new AudioPlayer();      // OK. 이부분이 백미. 추상 클래스 참조 타입으로 선언하고, 실제로 구현된 객체를 생성해서 참조 가능하다.
```

### 추상 메서드는 언제 씀?
꼭 필요하지만, 자손마다 다르게 구현될 것으로 예상되는 경우  
  
> 야 Player라면 play()랑 stop()은 있어야 될 거 아니야?!  
> 그니까 너희들 Player 상속하면 꼭 니들 상황에 맞게   
> play()랑 stop() 알아서 구현해서 써라  
  
이렇게 강제해서 쓴다는 의미가 있다.  
  
  
## 7-33,34 추상 클래스의 작성
결국 추상 클래스는  
" **코드가 복잡해지면** 상속 할 때 어떤 메서드는 별도로 꼭 만들어 줘야한다 " 라는 부분이다.  
![image](https://user-images.githubusercontent.com/101965836/165008722-a429286f-dadc-4903-8df0-5d52bd88d2b0.png)  
마린, 탱크, 드랍쉽 전부 공통적으로 위치(x,y), 이동 명령, 정지 명령을 갖고 있다. 따라서 이 공통된 부분을 뽑아서 부모 클래스를 만들 수 있다.  
![image](https://user-images.githubusercontent.com/101965836/165008804-d537c23a-07b1-4f70-8b30-42727c950df4.png)  
근데 이제 보면  
위치와 정지 명령은 동일하게 만들 수 있겠지만,  
움직이는 명령은 다를 수 있다.  
예를 들어 마린과 탱크는 지상유닛이지만, 드랍쉽은 공중유닛이므로 move() 메서드가 다르게 구현 되어야 한다.  
따라서 이런 경우, **"Unit 클래스를 상속받아서 만들 때 꼭 move()는 따로 구현하세요"** 라고 강제하는 효과를 갖도록 하기 위해서  
추상 클래스, 추상 메서드를 사용한다.  

### 다형성 까지 활용
이렇게 해놓으면  
![image](https://user-images.githubusercontent.com/101965836/165008983-2b2199d6-e729-4880-939d-08119b103110.png)  
  
Unit 으로 참조 타입 만들어서 각종 유닛들을 배열에 담을 수 있고,  
또 Unit에 move()가 있으므로 마치 리모콘의 버튼이 있는 형태가 되며,  
실제로 유닛별로 .move()로 실행해도 각 객체에서 상속 후 구현된 move()가 실행된다.  
  
이를 통해서 다양한 객체를 엄청나게 편리하게 다룰 수 있는 장점을 갖게된다.   

#### 홀리몰리 😲


### 그래서 추상화는...  
1. 추상화 코드는 온전히 구현된 코드보다 변경에 유리하다  
2. 추상화와 다형성을 합쳐서 활용하면 위 예시처럼 편하게 다양한 객체를 다룰 수 있다   
  
  
## 7-35~37 인터페이스의 선언, 상속, 구현
인터페이스는? **추상 메서드의 집합**    
추상 메서드 외에도 사실 static 메서드, 상수, 디폴트 메서드 등이 인터페이스 요소에 포함된다.  
하지만 인터페이스의 핵심은 결국 추상 메서드이다.  
따라서 일단은 부수적인 것들은 차치하고, 추상 메서드를 중심으로 인터페이스에 대해 알아보자  

#### 인터페이스는?  
구현된 것이 전혀 없는 설계도. 껍데기. (모든 멤버가 public)  

### 추상 클래스와 인터페이스의 차이는?  
추상 클래스는 일반 클래스인데 추상 메서드를 갖고 있는 것이다  
인터페이스는 추상 메서드 외에는 아무것도 가질 수 없다.  
(물론 멤버 변수를 갖고 있을 수 있도록 중간에 바뀌었다. 그치만 핵심은 아니다)  
  
> 상속은  
> 슈퍼클래스(부모)의 기능을 이용하거나 확장하기 위해서 사용되고, 다중 상속의 모호성 때문에 하나만 상속받을 수 있습니다.  
> 인터페이스는  
> 해당 인터페이스를 구현한 객체들에 대해서 동일한 동작을 약속하기 위해 존재합니다.  
  
또 다르게 설명하면  
상속 방식으로 전달되는 추상 클래스는  
계속해서 조상으로 타고 올라가서도 그 근간이 같은 경우에 사용한다.    
반면 인터페이스의 경우  
성질은 같지만 그 근간은 다른 경우에 사용한다.  
  
예를 들어  
잠수함과 거북이가 있다고 해보자.  
이 때  
거북이는 '생명체' 클래스가 부모이고    
잠수함은 '탈것' 클래스가 부모라고 해보자.  
  
근데 둘은 공통적으로  
'물에서움직이기' 메서드를 갖고 있어야 한다.  

이러면  
추상 클래스를 통한 상속은 각각 거북이는 '생명체'에서, 잠수함은 '탈것'에서 이어지는 게 맞다.  
그러나 '물에서움직이기'는 서로 동작 방식이 다를 수 있다.  
따라서 이러한 경우 인터페이스를 통해서 어떻게 구현해야하는지 설계를 강제할 수 있게 된다.  
상속으로 인한 문제(메서드 충돌)가 발생하지 않는다.  
아무튼 요약하면  
각각 클래스가 특징적으로 가지고 싶은 속성의 경우    
인터페이스로 설계도를 뿌려주는 편이 더 좋기 때문에 인터페이스가 있는 것이다.  

### 추상클래스 vs 인터페이스 예시
![image](https://user-images.githubusercontent.com/101965836/165011706-9b9642c7-28c5-4ce2-b0de-12ded8c5f2f6.png)  
  
  
### 작성법
```
interface 인터페이스이름 {
  public static final 타입 상수이름 = 값;   // final이니까 상수
  public abstract 메서드이름(매개변수목록);  // 추상메서드
}
```

### 인터페이스 유의사항
- 인터페이스의 조상은 인터페이스만 가능
- object가 최고 조상이 아님
- 다중 상속이 가능
- 추상 메서드는 충돌해도 문제 없음(구현부가 어차피 없으니까 충돌 할 게 없음)

### implements 
인터페이스는 상속의 extends처럼 implements를 쓴다.    
차이점은, implements를 쓰면 모두 오버라이딩 해줘야 한다는 차이가 있다.  

#### 일부만 구현하면?  
클래스 앞에 abstract 붙여야 함  

```
class 클래스이름 implements 인터페이스이름 { 
  ...
}
```
```
interface Fightable {
  void move(int x, int y); // 앞에 public abstract 생략된 것
  void attack(Unit u);
}

class Fighter implements Fightable {  
  public void move(int x, int y) { ... }
  public void attack(Unit u) { ... }
}
```
```
// 일부만 구현하는 경우. abstract 붙여야 함
abstract class Fighter implements Fightable {
  public void move(int x, int y){...}
}
```
   
### QNA
Q. 인터페이스란?  
A. 추상 메서드의 집합  
  
Q. 인터페이스의 구현이란?  
A. 인터페이스의 추상메서드 몸통{} 만들기(미완성 설계도 완성하기)  
추상 클래스는 상속(extends)을 통해서 구현하며, 인터페이스는 implements를 통해 구현한다.  
  
Q. 추상 클래스와 인터페이스의 공통점은?  
A. 추상 메서드를 공통적으로 갖는, 미완성 설계도 처럼 어떤 큰 틀을 정해주는 목적을 갖고 있다.  
  
Q. 추상 클래스와 인터페이스의 차이점은?  
A. 인터페이스는 인스턴스 변수를 가질 수 없다.  
정확히 말하면 인터페이스는 추상 메서드, 상수, static 메서드, 디폴트 메서드를 가질 수 있지만, 인스턴스 변수는 가질 수 없다.   
추상 클래스는, 어떤 집단에서 하위 개체들을 정의할 용도로 쓴다. 따라서 개체마다 값만 다르고 의미는 같은 공통 속성들을 변수에 담아서 쓰기위해 만들어진 기능이다. 그러므로 인스턴스 변수를 갖고 있다.    
그러나 인터페이스는, 같은 집단이 아니더라도 공통적으로 발견되는 기능들을 어떻게 구현해야 된다라는 것에 대한 가이드라인을 제시하기 위해 사용한다. 따라서 공통된 속성에 초점을 맞추지 않아서 인스턴스 변수를 갖지 않고, 공통된 기능을 어떻게 구현해야 된다라는 가이드라인에 초점을 맞춰서 탄생한 게 인터페이스이다.    
  
  
## 7-38 인터페이스를 이용한 다형성
앞서 추상 클래스 에서는 상속받은 것들을 다형성을 이용해 한꺼번에 배열에 넣고 다룰 수 있었다.  
이와 마찬가지로  
인터페이스로 구현된 클래스들도 한꺼번에 인터페이스 참조 변수에 넣고 다룰 수 있다. 또 인터페이스 참조형 배열에 넣고 묶어서 다룰 수 있다.  
물론 인터페이스에 적혀있는 메서드만 사용할 수 있다.  

### 매개변수 타입이 인터페이스???
인터페이스 타입의 매개변수가 갖는 의미는  
메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다는 뜻이다   
```
void attack(Fightable f) {
  ...
}
```
위 예제 코드를 통해 보면  
싸울 수 있는 객체들만 매개변수로 받겠다는 것이고,    
싸울 수 있어야지 attack을 할 수 있지 않겠는가?  
따라서 Fightable f로 매개변수를 받아서 구현하는 식이 합리적이라고 할 수 있다.  
안그러면 일일이 Fightable인 객체마다 오버로딩 해야 하니 얼마나 번거롭겠는가?  
  
  
### 리턴도 인터페이스 가능    
리턴타입이 인터페이스라는 것은    
메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다    
사실 별 거 아니고, 그냥 인터페이스 타입으로 구현해서 다른 클래스지만 같은 인터페이스 갖고 있으면 한방에 다룰 수 있도록 쓸라고 반환 타입도 인터페이스로 할 수 있도록 해놓은 것이기도 하다.  
물론 생성하고나서 반환하는 식으로 구현해서 반환하기도 가능하고.    
    
  
## 7-39 인터페이스의 장점
  
### 1. 두 대상 간의 '연결, 대호, 소통'을 돕는 '중간 역할'을 한다  
인터페이스가 뭔가?  
사용자가 기계를 잘 만질 수 있도록 조작 방식을 제공해주는 것 아닌가?  
마치 윈도우 GUI 같은 것 처럼 말이다.  
  
   
마찬가지로 프로그래밍 인터페이스도    
.move() .stop() 같이 중간 역할을 하면서    
제대로 잘 조작할 수 있도록 가이드라인을 제시해주는 것이다.    
  
또한 변경에 유리하다는 의미는   
껍데기는 .move() .stop()처럼 그대로 유지 해두고   
알맹이만 바꿀 때 용이하다.  


### 자세히 설명해보면, 선언과 구현을 분리하여 장점을 얻는다

#### 껍데기 + 알맹이
```
class B {
  public void method() {
    System.out.println("methodInB");
  }
}
```

#### 껍데기 / 알맹이 분리
```
Interface I {
  public void method();
}

class B implements I {
  public void method() {
    System.out.println("methodInB");
  }
}
```

예를 들어 만약에 아래와 같이 A가 B를 사용하고 있다고 해보자  
```
class A {
  public void methodA (B b){
    b.methodB();
  }
}
```
근데 B가 C로 바뀌면, A도 바뀌어야 한다  
이런식으로 연관-연관-연관 계속 이어지면 나중에는 하나 바꾸려면 싹 다 갈아엎어야 하는 상황이 올 수 있다.  
하지만 여기에 인터페이스를 활용한다면?  
```
class A {
  public void methodA (I i) {
    i.methodB();
  }
}
```
이렇게 해두면 B를 바꿔도, 어차피 I 타입으로 받아오기 때문에 문제 없다.    
이렇게 선언부와 구현부를 분리함으로써 이점을 가질 수 있다.    

### 2. 개발 시간을 단축할 수 있다.
![image](https://user-images.githubusercontent.com/101965836/165019112-610b0185-2ded-4527-b24a-c2b4e8adb7e6.png)  
  
왼쪽의 인터페이스를 사용하지 않는 경우   
A(User) -> B(Provider)    
A가 완성되어 있어야지 B가 코딩할 수 있다.   
    
오른쪽의 인터페이스를 사용하는 경우    
A(User) -> I -> B(Provider)   
I가 중간자 역할을 하기 때문에, I만 완성되면 A는 B가 완성되어 있지 않아도 코딩할 수 있게 된다.  
  
### 3. 표준화가 가능하다 
나중에 JDBC 라는 것을 배운다.  
옛날에는 Java APP을 개발할 때 DB에 데이터를 요청하고 Data를 갖고왔다.   
DataBase에는 종류가 다양한데 만약 Oracle을 쓰다가 MySql로 바꿔야 한다면?  
프로그램을 싹 다 갈아엎어야 할 수 있다.  
  
하지만 여기에 JDBC로 중간다리를 만들었다. 즉 일종의 표준인것이다.  
그러면 JavaApp 개발자는 JDBC 표준에 맞춰서 호출하면 되고  
DB는 JDBC 표준에 맞춰서 응답하면 되는 것이다.  
  
따라서 이렇게 표준화를 이용하면  
상황에 따라서 다른 것을 사용할 수 있다.  

### 4. 서로 관계없는 클래스들을 관계를 맺어줄 수 있다.
![image](https://user-images.githubusercontent.com/101965836/165019928-e8e42d7c-1ca3-428b-8849-32ad4279e075.png)   
위 예시를 보자.   
상속 계층도 그림 따라서 Unit 아래에 지상유닛 공중유닛 나뉘고 쭉쭉쭉 유닛별로 나뉜다    
근데 여기에 SCV의 repair를 구현하려면 어떻게 될까?   
만약 인터페이스를 쓰지 않았다면,   
Dropship도 repair 가능해야하고, Marine은 또 리페어가 불가능해야 하니까   
Unit에다가 abstract로 repair 메서드 만들고, marine은 repair 메서드 필요 없는데도 또 repair 메서드에다가 어떻게 구현해줘야 하고 복잡해진다.   
근데 인터페이스를 활용하면?   
Repairable이라고 인터페이스 정의하고 SCV Tank Dropship만 딱 인터페이스 먹여서   
그 부분 구현해주면 된다.   
상속 계층과 무관하게, 그리고 매우 간결하게 서로 클래스들 관계를 맺어줄 수 있게 된다.   
  
  
  
## 7-40,41 디폴트 메서드, static 메서드  
인터페이스의 디폴트, static 메서드  
원래 인터페이스에는 추상메서드만 있고 다른건 없었는데, JDK1.8부터 디폴트 메서드와 static 메서드가 추가됐다.  
  
### 만약 인터페이스에 새로운 추상 메서드가 추가되면 어떻게 될까?  
Interface i 에 추상 메서드 a() b() c() 가 있다고 해보자.  
근데 이 인터페이스를 100개의 클래스가 가져다 쓰고 있는데,  
어느날 보니까 인터페이스에 메서드 d()를 추가해야 한다면?  
100개의 클래스에서 다시 다 d()의 구현부를 작성해야 할 것이다.  

### 해결책 => default method()
인터페이스는 추상 메서드만 가질 수 있기 때문에
```
interface MyInterface {
  void method();
  void newMethod(); // 새로 추가된 추상 메서드 -> 인터페이스 받아 쓰는 클래스들은 다시 일일이 다 구현해야함
}
```
하지만 디폴트를 쓰면?  
```
interface MyInterface {
  void method();
  default void newMethod(); 
}
```

### 다시 문제 발생 : 기존의 메서드와 충돌 하면?  
1. 여러 인터페이스의 디폴트 메서드와 충돌  
-> 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 해야 한다.     
  
2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌  
-> 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.    
  
**그냥 간단하게 말하면 직접 오버라이딩 하면 해결된다.**  

### static 메서드  
default 메서드는 기본 동작 구현을 해두지만, 오버라이딩이 가능하다 라는 개념이라면  
static 메서드는 default처럼 기본 동작 구현을 해두면서, 오버라이딩이 불가능 하도록 막는 것이다.  

## 7-42~44 내부클래스의 종류, 특징, 선언

### 내부클래스란?
클래스 안의 클래스
```
class A {
  ...
}
class B {
  ...
}
```
```
class A {
  ...
  class B {
    ...
  }
  ...
}
```

### 내부 클래스의 장점
- 내부 클래스에서 외부 클래스의 멤버들에 쉽게 접근할 수 있음
객체 생성 없이도 간단하게 쓸 수 있음  

- 코드 복잡성을 줄일 수 있음(일종의 캡슐화)  
안에서만 쓰는 클래스라면 어차피 안에다가 놔두면 되니까.  
  
  
### 내부 클래스의 종류와 특징
내부 클래스의 종류와 유효범위(scope)는 변수와 동일  

### 익명 클래스
클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)  
GUI 이벤트 생성시에 쓴다고 하는데, 자주 쓰이지도 않고 지금 당장 깊게 공부할 내용도 아니니 넘어가자  

### 내부 클래스 선언
```
class Outer{
  class InstanceInner {}
  static class StaticInner {}
  
  void myMethod() {
    class LocalInner {}
  }
}
```


## 7-45~50 내부 클래스 제어자와 접근성
내부 클래스의 제어자는 변수에 사용 가능한 제어자와 동일    

## 예제
```java
class Ex7_12 { 
  class InstanceInner { 
    int iv = 100; 
    // static int cv = 100;            // 에러! static변수를 선언할 수 없다. 
    final static int CONST = 100;   // final static은 상수이므로 허용
  } 

  static class StaticInner { 
    int iv = 200; 
    static int cv = 200;    // static클래스만 static멤버를 정의할 수 있다. 
  } 

  void myMethod() { 
    class LocalInner { 
      int iv = 300; 
      //static int cv = 300;           // 에러! static변수를 선언할 수 없다. 
      final static int CONST = 300;    // final static은 상수이므로 허용 
    } 
  } 

  public static void main(String args[]) { 
    System.out.println(InstanceInner.CONST); 
    System.out.println(StaticInner.cv); 
  } 
}
```

#### final과 final static 차이는?  
final : 객체마다 다른 상수   
final static : 객체들 모두 다 같은 상수   
  
ex. 카드를 정의 할 때  
카드의 무늬와 숫자는 객체마다 다른데 중간에 바뀌면 안되므로 final  
카드의 가로 세로 길이는 객체들 모두 같은 값을 가져야 하므로 final static  
  
  
### 헷갈릴 수 있는 것들
```java
class Outer{
  ...
  void myMethod() {
    int lv = 0;
    final int LV = 0;
    
    class LocalInner {
      int liv = lv; // 에러?
    }
  } // myMethod() 끝
} // Outer 끝
```
위의 // 에러? 라고 적어둔 줄을 보자.  
메서드 안의 지역 변수는 메서드가 종료되면 사라진다. 근데 class는 쓰레드에서 동작하는 등의 경우 매서드보다 더 오래 남아있을 수 있다. (정확히는 지금 알 필요 없고 그럴 수 있구나 정도만 알아두자)    
어? 그러면 어떻게 되는걸까?  
  
결론은 원래는 에러가 났었으나, jdk1.8 부터 에러가 안난다.  
이는    
값이 바뀌지 않았다면 final로 인식하여서 상수처리해서 취급한다고 한다.  


### 이외에도 헷갈릴만한 경우는 7-46 ~ 7-50에 예제 1부터 예제 5 까지로 적어놨다
그냥 코딩하다가 헷갈릴때마다 이 부분 다시 들여다 보면 된다.  
  

## 7-51,52 익명 클래스
```
class Ex7_17 {
  Object iv = new Object(){ void method(){} };        // 익명 클래스
  static Object cv = new Object(){ void method(){} }; // 익명 클래스

  void myMethod() {
    Object lv = new Object(){ void method(){} };      // 익명 클래스
  }
}
```
이렇게 익명 클래스는 선언과 생성을 동시에 하면서 클래스 이름이 없는 것을 말한다.  
용도 이야기는 차치해두고, 그냥 일단 이런게 있구나 정도로만 알아두자  
  
여기서 익명 클래스는 클래스 이름 자체가 의미가 없기 때문에  
그냥 '조상클래스이름'이나 '구현인터페이스이름'을 따서 쓴다  
  
### 사용 예제
```
import java.awt.*;
import java.awt.event.*;

class Ex7_18 {
	public static void main(String[] args) {
		Button b = new Button("Start");
		b.addActionListener(new EventHandler());
	}
}

class EventHandler implements ActionListener {
	public void actionPerformed(ActionEvent e) {
		System.out.println("ActionEvent occurred!!!");
	}
}
```
자바 윈도우 프로그래밍(awt) 예제이다.  
여기서 EventHandler 라는 클래스를 따로 정의를 하고, 이를 생성해서 addActionListener에다가 넣어준다.  
하지만 매번 이런식으로 밖에다가 생성해주는 식은 번거로우므로  
아래와 같이 익명 클래스로 처리해버리곤 한다  
```
b.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent e) {
		System.out.println("ActionEvent occurred!!!");
	}
});
```
  
  ---
  
  <br><br><br><br><br><br><br><br><br><br>
  
  ---
  
# 8. 예외처리
## 8-1~3 프로그램 오류, 예외 클래스의 계층구조
### 에러의 종류
- 컴파일 에러(compile-time error) : 컴파일 할 때 발생
- 런타임 에러(runtime error) : 실행 할 때 발생
- 논리적 에러(logical error) : 작성 의도와 다르게 동작

### 컴파일러가 하는 일
1. 구문체크
2. 번역
3. 최적화  
4. 생략된 코드 추가

생략된 코드 추가는 예를 들면
```
public class myClass { ... }
```
이런 경우, 원래 extends Object 가 붙어야 하는데 안붙어도 컴파일러가 자동으로 추가해준다.  

### Java의 에러 vs 예외
에러(Error) : 수습 불가능한 심각한 오류  
ex. Out of Memory Error (OOME)  
예외(Exception) : 수습 가능한 다소 약한 오류  
  
에러는 어쩔 수 없지만, 예외는 처리하자.  
심각한 경우 아니라면 어지간해선 프로그램이 완전히 죽어버리지는 않도록 하자.  
  
  
### 예외처리의 정의와 목적
정의 : 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것   
목적 : 프로그램의 비정상적인 종료를 막는다. 계속 실행될 수 있도록 해주는 게 좋으므로   

### 예외 클래스 계층 구조
![image](https://user-images.githubusercontent.com/101965836/165217069-9b54484d-ace1-48b1-9e11-452603b3d704.png)  
  
### Exception 클래스 계층 구조
![image](https://user-images.githubusercontent.com/101965836/165217228-72054074-78d0-495d-80a1-cead53cc57fc.png)  
Exception 클래스들 : 사용자의 실수와 같은 외적 요인에 의해 발생하는 예외  
IOException : Input/Output에서 예외가 발생  
ClassNotFoundException : 클래스가 존재하지 않음  

### RuntimeException 클래스
프로그래머의 실수로 발생하는 예외들   
ArithmeticException : 산술 계산 예외  
ClassCastException : 형변환 에러    
NullPointerException : 널 포인터. 참조 변수가 가리키는 대상이 없을    
indexOutOfBoundsException : 배열 범위 벗어남   
  
프로그래머는 이러한 예외를 예상하고 견고하게 프로그램을 작성해야 한다  

### 정리
![image](https://user-images.githubusercontent.com/101965836/165217634-60fcf8b9-1e53-4ef7-a515-d9fd7d3e6fe3.png)  


## 8-4~6 예외 처리하기, try-catch문의 흐름   

```
try { 
	// 예외가 발생할 수 있는 문장들
} catch (Exception e1) {
	// Exception1이 발생했을 경우, 처리하는 문장
} catch (Exception e2) {
	...
} 
```
  
try-catch에서는 { } 를 생략할 수 없다.  

### try-catch 문의 흐름  
- try 내에서 예외가 발생한 경우   
1. 발생한 예외와 일치하는 catch블럭이 있는지 확인  
2. (1) 일치하는 catch블럭이 있으면, 그 블럭의 문장들 수행하고 try-catch 전체 블럭을 빠져나감  
2. (2) 일치하는 catch블럭이 없으면, 예외는 처리되지 못하고 비정상적으로 프로그램이 종료됨  

- try 내에서 예외가 발생하지 않은 경우    
1. catch 블럭을 거치지 않고 try-catch 전체 블럭을 빠져나감  

### Exception 클래스로 처리하는 catch는 마지막에!!
```
try {
	...
	System.out.println(0/0);
} catch (ArithmeticException ae) {
	...
} catch (Exception e){	// Exception 클래스로 catch하는 것은 제일 마지막에 와야한다
	System.out.println("Exception");
}
```
왜? exception은 모든 예외 클래스의 조상이다.   
catch문에서 에러가 발생하면, 적당한 catch문을 위에서 부터 차례대로 찾아나간다.   
만약 적당한 매개변수를 가진 catch가 있으면, **그 catch 블럭만 실행하고 전체 try-catch를 빠져나간다**   
따라서 catch (Exception e)가 제일 위 첫 부분에 있으면, 모든 예외가 첫 부분 Exception 클래스에 처리되고 끝나버리게 된다.  

## 8-7,8 printStackTrace(), 멀티 catch 블럭

### printStackTrace()와 getMessage()
#### pinrtStackTrace()
예외발생 당시의 호출스택에 있던 메서드의 정보와 예외 메시지를 화면에 출력한다  
#### getMessage() 
발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다  

### 예시
```
try {
	...
	System.out.println(0/0); // 예외 발생
	...
} catch (ArithmeticException ae) { 
	ae.printStackTrace();
	System.out.println(ae.getMessage());
} catch (Exception e) {
	...
}	
```

예외가 발생하면 해당하는 예외 클래스의 객체가 만들어지고 예외에 대한 정보가 그 객체에 들어간다    
그리고 그 객체는 catch문에 매개변수로 넘어오게 되고,  
catch문은 해당 객체를 받아서 .printStackTrace() 와 .getMessage() 메서드로 예외 정보를 얻을 수 있다.   

### 멀티 catch블럭
내용이 같은 catch블럭은 하나로 합쳐서 쓸 수 있다(jdk1.7부터)  
```
try { 
	... 
} catch (ExceptionA e) {
	e.printStackTrace();
} catch (ExceptionB e2) {
	e2.printStackTrace();
}
```
이렇게 쓸 필요 없이  
```
try { 
	... 
} catch (ExceptionA | ExceptionB e) {
	e.printStackTrace();
}
```
이렇게 멀티 catch 블럭으로 쓰면된다.  
  
#### 주의 할 점
catch 인자에다가 부모 자식 클래스를 동시에 쓰는건 안된다.  
사실 이건 당연한거다. 부모 자식 관계를 동시에 체크할 필요가 없는게, 어차피 부모만 적어도 instanceOf로 자식들도 해당되기 때문이다.    
그리고 또 당연한 말이지만, 공통된 메서드만 호출 가능하다.  

## 8-9,10 예외발생시키기  
1. 연산자 new를 이용해서, 발생시키려는 예외 클래스의 객체를 만든다.  
Exception e = new Exception("my exception");  
2. 키워드 throw를 이용해서 예외를 발생시킨다.  
throw e;  

### 예제
![image](https://user-images.githubusercontent.com/101965836/165222311-cd11a1b0-2afe-41fb-9e35-42570eba3fb0.png)  

### checked예외, unchecked예외
- checked예외 : 컴파일러가 예외 처리 여부를 체크(예외 처리 필수)
- unchecked예외 : 예외 처리가 선택적인 것  

checked는 Exception과 자손들  
unchecked는 RuntimeException과 자손들  


### checked는 처리 안하면 컴파일 에러가 난다
```
class testchecked {
	public static void main(String[] args) {
		throw new Exception();
	}
}
```
![image](https://user-images.githubusercontent.com/101965836/165222744-9eb8c5c2-e095-450d-b751-f84f1bbca680.png)  
checked 예외들은 필수로 try catch로 예외 처리 했어야 하는데, 안했으니까 컴파일 에러가 난다.  


### unchecked는 처리 안하면 런타임 에러가 난다
```
class testunchecked {
	public static void main(String[] args) {
		throw new RuntimeException();
	}
}
```
![image](https://user-images.githubusercontent.com/101965836/165222863-de2dee9b-0ee2-4a53-b9ea-12e9140d7304.png)    
  
### 지금까지 정리해보면
![image](https://user-images.githubusercontent.com/101965836/165222590-52f1787d-e29b-4f94-bd55-07f61a5d9349.png)
  
  
## 8-11~14 예외선언하기, finally 블럭
예외를 처리하는 방법에는 (1)try-catch문 (2)예외 선언하기  
예외 선언은 일종의 예외 떠넘기기이다  
자기를 호출한 사람에게 예외를 떠넘기는 방식이다.  

### 메서드에 예외 선언하기
```
void method() throws Exception1, Exception2, ... , ExceptionN {
	...
}
```
발생 가능한 예외들을 알려주는 것. 호출하는 쪽에다가 이런 예외가 발생할 수 있다고 알려주는 것.  
```
void method() throws Exception {
	...
}
```
Exception은 모든 예외의 최고 조상이다.  

### 오버라이딩때 규칙 다시 보자
1. 선언부일치
2. 접근제어자 더 좁게 불가
3. 조상보다 많은 예외 선언 불가(새로운 예외를 throws 할 수 없음)  

### 예외는 어디서 처리할래? 를 정해야 한다  
호출한 쪽에서 예외를 처리할건지  
호출 받은 메서드 안에서 예외를 처리할건지  
정해야 한다.  

### finally 블럭
예외 발생여부와 관계없이 수행되어야 하는 코드를 넣는다.  
try 블럭 안에 return문이 있어서 try 블럭을 벗어나도, finally 블럭이 실행된다.  
```
try {
} catch (Exception1 e1) {
} finally {
}
```

### 언제 finally를 써야하나?  
예를 들어서 임시 파일을 삭제해야 하는 경우를 들 수 있다.  
```
try {
	startInstall();
	copyFiles();
} catch (Exception e) {
	e.printStackTrace();
} finally {
	deleteTempFiles();
}
```  

## 8-15~17 사용자 정의 예외 만들기
우리가 직접 예외 클래스를 정의할 수 있다.  
조상은 Exception과 RuntimeException 중에서 선택  
Exception은 필수 처리 예외라서 반드시 try catch를 해줘야 하고,  
RuntimeException은 선택 처리니까  
잘 판단해서 적절한 조상을 택하면 되겠다  

### 예시
```
class MyException extends Exception {
  // 에러 코드 값을 저장하기 위한 필드 
  private final int ERR_CODE; // 생성자를 통해 에러 코드를 초기화함
  
  MyException(String msg, int errCode) { // 생성자
    super(msg);
    ERR_CODE = errCode;
  }
  
  MyException(String msg) { 	// 생성자
    this(msg,100);		// ERR_CODE는 100을 기본값으로 초기화 함
  }
  
  public int getErrCode() {	// 에러 코드를 얻을 수 있는 메서드도 추가
    return ERR_CODE;		// 이 메서드는 주로 getMessage(0와 함께 사용될 것
  }
}
```

꼭 에러 코드를 넣을 필요는 없고, 그냥 이렇게도 쓸 수 있다는 것.  

중요한건 
1. Exception과 RuntimeException 중 조상을 선택할것  
2. 문자열을 매개변수로 받는 생성자를 꼭 작성할 것
```
MyException(String msg) {
	super(msg);
}
```

### 예외 되던지기
exception re-throwing  
예외를 처리한 후에 다시 예외를 발생시키는 것  
호출한 메서드와 호출된 메서드 양쪽 모두에서 예외처리하는 것    

![image](https://user-images.githubusercontent.com/101965836/165228150-a5f8e81c-f941-4ab7-8fa2-bab43ead719e.png)  

보통은 한군데에서만 예외를 처리하는데  
이렇게 하면 양쪽에서 예외를 처리해야할 경우도 있다는 정도만 알아두자.  
정확히 어떨 때 양쪽에서 처리해야한다 라고 콕 찝어서 말하기는 어렵다고 한다.  
메서드에서 일부분 예외 처리하고, 호출 부분에서 일부분 예외 처리하고 하는 식으로 양쪽에서 해야 할 수도 있다.  
그럴 때 예외 되던지기를 사용할 수 있다.  

## 8-18 연결된 예외 (Chained Exception)  
한 예외가 다른 예외를 발생시킬 수 있다  
예외 A가 예외 B를 발생시키면 A는 B의 원인 예외(cause exception)  
  
예외A >--(발생)--> 예외B  
예외A <--(원인)--< 예외B  

### 관련 메서드 (예외 등록, 예외 얻기)
Throwable initCause(Throwable cause) 지정한 예외를 원인 예외로 등록  
Throwable getCause() 원인 예외를 반환  
  
### Throwable이란?
여기서 Throwable은 Exception과 Error를 모두 아우르는 최고 높은 조상 클래스다  
![image](https://user-images.githubusercontent.com/101965836/165228914-27948c34-b040-473c-8d75-f9dc60a212e2.png)  
 
### 연결된 예외 예시
```
void install() throws InstallException {
	try {
		startInstall();
		copyFiles();
	} catch (SpaceException e) {
		InstallException ie = new InstallException("설치중 예외발생");
		ie.initCause(e);
		throw ie;
	} catch (...) { 
		...
	}
}
```
설치중에 공간이 부족해서 SpaceException이 발생할 경우, 그냥 SpaceException이 발생했다고 던질 수 있다.  
하지만 그냥 쌩으로 SpaceException만 던지면,  
어디서 임시파일 때문에 예외가 발생했는지,  
아니면 다른 사소한 입출력 과정에서 발생했는지 선후관계를 명확히 알 수 없다.  
  
그러나  InstallException (+ SpaceException) 이런식으로 chained exception으로 에러 묶어서 throw 해주면  
"아 이게 Install에서 발생한 예외이고, Space 관련 예외구나" 라고 알 수 있게된다.  

### 연결된 예외를 쓰는 이유 
#### 1. 여러 예외를 하나로 묶어서 다루기 위해서  
![image](https://user-images.githubusercontent.com/101965836/165229781-95682ed8-4c78-496c-8bb0-a77439f14798.png)
이렇게 놓고 비교해보면, 왼쪽처럼 그냥 예외로 던지는 것 보다, 오른쪽처럼 어떤 맥락에서 예외가 발생했는지 묶어서 던지는 게 더 예외 파악이 쉬워짐을 알 수 있다.  
#### 2. checked예외를 unchecked예외로 변경하려 할 때  
```
static void startInstall() throws SpaceException, MemoryException {
	if(!enoughSpace())
		throw new SpaceException("설치할 공간이 부족합니다.");
		
	if(!enoughMemory())
		throw new MemoryException("메모리가 부족합니다.");
}
```
이렇게 해두면,   
SpaceException이랑 MemoryException은 checked 예외이기 때문에, 발생하면 필수 처리를 해버려야 한다.  
따라서 이를 RuntimeException으로 바꾸고 싶은 경우  
```
static void startInstall() throws SpaceException {
	if(!enoughSpace())
		throw new SpaceException("설치할 공간이 부족합니다.");
		
	if(!enoughMemory())
		throw new RuntimeException(new MemoryException("메모리가 부족합니다."));
}
```
이렇게 선언부 throws에서 빼고, 에러 던지는 throw 부분에서는   
RuntimeException(Throwable cause) 방식으로 생성해서 쓸 수 있다.  
저렇게 생성하면 원인 예외로 ( ) 안에 있는 에러가 등록되게 된다.  
물론 원인 예외에다가는 에러 메세지 String을 넣어줘야함  
  
  ---
  
  <br><br><br><br><br><br><br><br><br><br>
  
  ---
  
# 9. java.lang패키지와 유용한 클래스

## 9-1 Object 클래스
모든 클래스의 최고 조상이며, 11개의 메서드만 가지고 있다.  
이 중 쓰레드와 관련된 notify(), wait()는 나중에 쓰레드 단원에서 배운다.  

### 간략한 Object 클래스 메서드 소개
|메서드|설명|
|---|---|
|protected Object clone()|객체 자신의 복사본 반환|
|public boolean equals(Object obj)|참조하는 주소(객체)가 같은 object인지 알려줌|
|protected void finalize()|가비지 컬렉터에 의해 수집될때 자동으로 호출되어 코드를 수행|
|public Class getClass()|객체 자신의 클래스 정보를 담고있는 Class인스턴스 반환|
|public int hashCode()|객체 자신의 해시코드 반환|
|public String toString()|객체 자신의 정보를 문자열로 반환|  
  
|쓰레드 관련 메서드|설명|
|---|---|
|public void notify()|객체 자신을 사용하려고 기다리는 쓰레드 하나만 깨운다|
|public void notifyAll()|객체 자신을 사용하려고 기다리는 쓰레드 모두 깨운다|
|public void wait()|지정된 시간동안 notify()할 때 까지 기다리게 한다|


getClass에 대해 좀 더 설명해보자.   
먼저, class중에는 Class라는 (첫 글자가 대문자인) 클래스가 있다.  
이 클래스로 각 클래스에 대한 정보를 담을 수 있다. 예를 들어 인스턴스 변수가 몇 개 인가 등등을 담는다.    
getClass()메서드는 객체의 클래스 정보를 담고 있는 Class 인스턴스를 반환한다. 설계도 정보를 반환한다는 뜻이다.   
설계도 객체를 통해서 (1) 객체 생성 (2) 객체 정보 획득 을 할 수 있다.  
이러한 설계도를 가지고 객체 정보를 얻을 수 있도록 한 것을 ReflectionAPI라고 한다.    
  
또한 protected는 public으로 오버라이딩해서 쓰며, 다른 메서드들도 기본적으로는 오버라이딩해서 쓴다.  

## 9-2 equals(Object obj)  
객체 자신과 주어진 객체를 비교한다.  
이 때 안의 값을 비교하는 게 아니라 객체의 주소를 비교한다(참조변수 값 비교)  
```
public boolean equals(Object obj) {
	return (this==obj);
}
```
즉, 서로 같은 클래스고 같은 값을 갖더라도 다른 객체라면 false를 반환한다. 아래 코드를 참고하자
```
Value v1 = new Value(10);
Value v2 = new Value(20);

System.out.println(v1.equals(v2)); // false
```
v1과 v2는 주소가 다르기 때문에 false가 나온다.   


## 9-3 equals(Object obj)의 오버라이딩
인스턴스 변수의 값을 비교하도록 equals()를 오버라이딩해야 한다.  
  
### 안에 있는 값을 비교하도록 오버라이딩 해보자  
```
class Value {
	int value;
	
	Value(int value){
		this.value = value;
	}
	
	public boolean equals(Object obj) {
		// return this == obj;
		
		if(!(obj instanceof Value)) return false;
			
		Value v = (Value)obj;
		return this.value==v.value;
	}
}
```
  
## 9-4 hashCode()
객체의 해시코드를 반환하는 메서드  
해싱 알고리즘에 대해서 11장 컬렉션 프레임워크에서 다시 배운다.  
Object클래스의 hashCode()는 객체의 주소를 int로 변환해서 반환  

```
public class Object {
	...
	public native int hashCode();
```
native 메서드는 OS의 메서드를 그대로 사용함을 말한다.  

### equals()를 오버라이딩하면 hashCode()도 오버라이딩 해야한다.  
-> 본래 hashCode()는 주소값을 해시값으로 변환시키며, 각기 다른 객체인지 판단할 때 사용하는 매서드이다.  
솔직히 equals랑 hashCode랑 따로 놀아도 되지 않나? 그냥 hashCode는 서로 다른 객체인지 판단 할 때 쓰고, equals는 서로 같은 값을 갖는 객체인지 판단할 때 쓰면 되지 않나? 라는 생각이 든다.  
하지만 강의에서  
> equals()의 결과가 true인 두 객체의 해시코드는 같아야 하기 때문

이라고 하니까... 일단 그렇게 알아두자.  

이유를 좀 알아보니  
11장에 HashMap이라고 있는데 거기서 쓴다고 한다. 그 외에도 이런식으로 쓴다고 하니까 규칙처럼 알아두도록 하자.  

## 9-5,6 toString(), toString()의 오버라이딩
toString() : 객체를 문자열(String)으로 변환하기 위한 메서드  
```
public String toString() {
	return getClass().getName()+"@"+Integer.toHexString(hashCode());
}
```
  
### toString() 오버라이딩
마찬가지로 그냥 오버라이딩해서 적당히 toString으로 자기가 출력해내고 싶은 문자열 적어주면 된다
```
public String toString() {
	return "Number:"+Number;
}
```

## 9-7 String클래스
문자열을 다루기 위한 클래스  
String클래스 = 데이터(char[]) + 메서드(문자열 관련)   
    
C언어 같은 경우 객체지향이 아니기 때문에 클래스가 없고 String 없이 그냥 char[]로 문자 배열을 사용한다.  
  
```
public final class String implements java.io.Serializable, Comparable {
	private char[] value;
		...
}
```  
  
String 클래스는 내용을 변경할 수 없는 불변(immutable) 클래스이다  

### 덧셈 연산을 이용한 문자열 결합은 성능이 떨어짐
```
String a = "a";
String b = "b";
a = a + b;
```
왜 성능이 떨어지는지 알아보자.  
a(0x100) -> char\[] \[a]  
b(0x200) -> char\[] \[b]  
이렇게 a b 각각 객체들이 있는데 여기에 a = a + b 라고 하면  
기존 a 에다가 뒤에 b를 덧붙이는 형식이 아니라  
새로 a+b 값을 갖는 문자열 객체를 만들고  
char\[] \[a, b]  
이걸 a가 다시 가리키고록 변경하는 방식이다  
a(0x300) -> char\[] \[a,b]  
그래서 덧셈 연산자(+)를 이용해 문자열을 결합할 때마다 새로운 객체를 계속 생성하게 되므로 성능이 떨어진다.    

### StringBuffer
문자열의 결합이나 변경이 잦다면, 내용을 변경가능한 StringBuffer를 사용  

## 9-8 문자열의 비교  
```
String str1 = "abc"; 							// 문자열 리터럴
String str2 = "abc";
String str3 = new String("abc");	// 새로운 String 인스턴스 생성
String str4 = new String("abc");
```
![image](https://user-images.githubusercontent.com/101965836/165432890-e1d61099-6c4b-4677-a748-d18fe62751f7.png)    

근데 문자열은 어차피 내용 변경이 불가능 하니까   
특별한 경우 아니면 굳이 new로 만들어서 쓸 필요가 없다  
  
### 문자열의 비교
```
str1 == str2 ? true
str1.equals(str2) ? true
//----------------------
str3 == str4 ? false
str3.equals(str4) ? true
```
==를 사용하면 주소 비교를 하게 되고, equals를 하면 내용 비교를 하게 된다.  
new로 하면 주소 비교에서 false가 뜨기 때문에 혼란이 생길 수 있고 여러모로 귀찮으므로  
그냥 문자열 리터럴로 만들어 주는 게 좋다.  
  
	  
## 9-9 문자열 리터럴  
문자열 리터럴은 프로그램 실행시 자동으로 생성된다. (constant pool에 저장)   
그리고 계속 반복해서 말했듯, 문자열 내용이 같으면 같은 곳을 가리키게 된다  
s1 = "AAA";  
s2 = "AAA";  
s3 = "AAA";  
이렇게 되어 있다면 모두 같은 동일하게 (0x100)"AAA" 를 가리키게 된다.   

## 9-10 빈 문자열 ("")
내용이 없는 문자열. 크기가 0인 char형 배열을 저장하는 문자열  
String str = "";  
  
크기가 0인 배열을 생성하는 것은 어느 타입이나 가능하다  
```
char[] chArr = new char[0];
int[] iArr = {};
```

그럼 뭐때문에 이렇게 빈 배열을 쓰느냐?  
(1) "" + 5 -> "5"  
이런식으로 + 연산을 통해서 숫자를 문자열로 간편하게 바꿀 때 사용한다  
(2) 초기화 할 때 null보다 빈 배열 쓰는게 더 좋다   
null로 쓰면 해당 주소에 들어있는 값의 특성을 알 수 없는 등의 문제가 있을 수 있다.   
하지만 앞으로 어떤 형식의 데이터가 들어올꺼다 라고 명시해줄 수 있다는 점에서 의미가 있다.   
  
	
## 9-11 String 클래스 생성자와 메서드  
![image](https://user-images.githubusercontent.com/101965836/165434770-79e63b07-7eaa-4fbb-ae06-89a6d92227fc.png)    
  
![image](https://user-images.githubusercontent.com/101965836/165434757-e343757a-a3c1-47ff-80a8-52c899f925fd.png)    

**contains 메서드의 매개변수 타입 CharSequence의 정체**  
![image](https://user-images.githubusercontent.com/101965836/165434947-5b4d1d72-ba4e-401a-a019-20f815c732c6.png)    
  
![image](https://user-images.githubusercontent.com/101965836/165435122-a84c2e2d-6d97-49a3-a07b-8e9858c09b43.png)  
  
![image](https://user-images.githubusercontent.com/101965836/165435309-2d83f363-7c5c-45f9-907f-c1bc44b32831.png)  
  
**regex는 정규표현식** 을 말한다   
  
	
![image](https://user-images.githubusercontent.com/101965836/165435701-eb337fc3-74bd-44ff-a03c-f83b3ca261e3.png)  

	
## 9-12 join()과 StringJoiner  
join은 여러 문자열 사이에 구분자를 넣어서 결합한다  

```
String animals = "dog,cat,bear";
String[] arr = animalssplit(",");		// 문자열을 ','를 구분자로 나눠서 배열에 저장
String str = String.join("-", arr);	// 배열의 문자열을 '-'로 구분해서 결합
System.out.println(str);						// dog-cat-bear
```

## 9-13,14 문자열과 기본형 간의 변환
### 숫자를 문자열로 바꾸는 방법
```
int i = 100;
String str1 = i + "";							// 방법1. 편리함
String str2 = String.valueOf(i);	// 방법2. 속도가 빠름
```
각각 편리하다 vs 속도가 빠르다 라는 장점을 따로 갖고 있으니 상황에 따라서 적절히 사용

### 문자열을 숫자로 바꾸는 방법
```
int i = Integer.parseInt("100");			// 옛날 방법
int i2 = Integer.valueOf("100");			// 새로운 방법
Integer i2 = Integer.valueOf("100");	// 원래는 반환 타입이 Integer
```
문자열을 기본형으로 바꾸는 방법에는 이외에도  
Boolean.parseBoolean(String s)  
Byte.parseByte(String s)  
Float.parseFloat(String s)  
등등 있지만  
그냥 전부 .valueOf()를 써도 된다.  
거의 같지만 단 하나 반환 타입이 다르다는 정도의 차이만 있다.  
  
	
### 오토박싱
앞서 말했듯 Integer 형식으로 반환한다는 것 처럼  
Byte Float 등등 참조 형식으로 받아야하는데  
보다시피 int형으로 그냥 적어도 값을 받을 수 있다.  
이는 오토 박싱이라는 것 덕분인데, 나중에 배운다.  


## 9-15~18 StringBuffer 클래스
문자열을 저장하기 위한 클래스인데, 앞서 말했듯 String을 다뤄야 하지만 내용을 변경해야 할 때 사용한다.  
String과 달리 StringBuffer는 mutable 하다.  
![image](https://user-images.githubusercontent.com/101965836/165439536-808ecf82-4227-4ca5-b80c-9d3b6207ecc5.png)  
이렇게 뒤에 붙여주는 식으로 내용을 추가할 수 있다.  

### 배열의 길이는 변경 불가
배열의 길이는 변경이 불가능하다, 공간이 부족하면 새로운 배열을 생성해야 한다.  
(1) 새로운 길이 배열 생성 (2) 내용 복사 (3) 참조 변경  
이런 과정을 거쳐야 하기 때문에 어지간하면 처음에 배열 생성 할 때부터 충분한 크기로 생성하는 것이 좋다
  
### StringBuffer에서 length를 지정해주는 생성자
```
// 생성자 1. length 지정
public StringBuffer(int length) {
	value = new char[length];
	shared = false;
}

// 생성자 2. 기본 생성자. 16이 크게 의미있는 숫자는 아님
public StringBuffer() {
	this(16);
}

// 생성자 3. string이 주어질 경우, 지정 문자열 길이보다 16만큼 더 크게 배열 생성
public StringBuffer(String str) {
	this(str.length() + 16);
	append(str);
}
```
### StringBuffer의 변경 
append() : 끝에 문자열 추가    
delete() : 삭제  
insert() : 삽입  
  
append는 지정된 내용을 buffer에 추가한 후, StringBuffer의 참조를 반환한다.  
이게 무슨 말이냐 하면, 아래의 코드를 보자  
```
StringBuffer sb = new StringBuffer("abc");
sb.append("123");
sb.append("ZZ");
```
이런 식으로 코드를 짜도 되지만 아래와 같이 할 수도 있다.  
```
StringBuffer sb = new StringBuffer("abc");
sb.append("123").append("ZZ");
```
성능상 차이는 없지만 코드가 더 간결해 진다는 첨이 차이가 있다.  
이런걸 **메서드 체이닝** 이라고 한다

### StringBuffer의 비교  
**StringBuffer는 equals가 오버라이딩 되어있지 않다.**  
기본 equals처럼 주소를 비교한다.  
```
StringBuffer sb = new StringBuffer("abc");
StringBuffer sb2 = new StringBuffer("abc");

System.out.println(sb==sb2);				// false
System.out.println(sb.equals(sb2));	// false
```

따라서 **String으로 변환 후에 equals()로 비교해야한다**  
```
String s = sb.toString();
String s2 = sb2.toString();

System.out.println(s.equals(s2));	// true
```

## 9-19,20 StringBuffer 클래스의 생성자와 메서드  
![image](https://user-images.githubusercontent.com/101965836/165441845-f29b6b8d-7132-4cdc-bb01-44b0d8fb0f56.png)  
여기서 append 부분 예제 코드 결과는 아래와 같다  
![image](https://user-images.githubusercontent.com/101965836/165442539-20676b45-717f-401d-af61-f46099fe3b69.png)  
sb = \[ a b c t r u e d 1 0 . 0 A B C 1 2 3 ]
   
	 
![image](https://user-images.githubusercontent.com/101965836/165442626-029d1f01-f213-4579-8606-6061a9095ef7.png)   
  
![image](https://user-images.githubusercontent.com/101965836/165442971-fe22c439-ecb1-48f1-9fb6-93c8474fa8fd.png)   
  
![image](https://user-images.githubusercontent.com/101965836/165443178-3f2fd1b4-6e8b-4444-904d-73ee2e3fe558.png)  

	
## 9-21~24 StringBuilder, Math 클래스

### StringBuilder
StringBuffer와 거의 비슷하지만, 동기화와 관련된 부분이 다르다  
StringBuffer는 동기화 되어있다. 멀티 쓰레드에 안전하다  
StringBuilder는 동기화 되어있지 않다. 멀티 쓰레드에 위험하다  
따라서 동기화가 불필요한, 멀티 쓰레드를 쓰지 않는 경우에는 StringBuffer를 쓰면 불필요하게 동기화 작업도 일어나므로 StringBuilder를 쓰면 성능 향상 이뤄진다   
멀티 쓰레드는 13장에서 배운다  

### Math 클래스
수학관련 static 메서드의 집합    
관련 상수로는 e, pi 등이 있다    

### round()
round는 무조건 소수점 첫째자리에서 반올림 한다.  
따라서 소수점 아래 n 번째 자리에서 반올림 하려면 아래와 같은 과정을 거쳐야 한다  
```
// 소수점 아래 세 번째 자리
// 1. 원래 값에 100을 곱한다 (세번째 -> 세자리 수)
90.7552 * 100 -> 9075.52
// 2. 위의 결과에 Math.round()를 사용한다
Math.round(9075.52) -> 9076
// 3. 위의 결과를 다시 100.0으로 나눈다.
9076 / 100.0 	-> 90.76  
9076 / 100 		-> 90
```

### Math 클래스의 메서드  
![image](https://user-images.githubusercontent.com/101965836/165445072-6d8bd093-e0df-4a79-bbfa-c3ff5ad44d8b.png)   
  
![image](https://user-images.githubusercontent.com/101965836/165445163-db1b3ee0-599b-442a-9bb3-e3a4a4ddcbe2.png)  

### 반올림에는 종류가 있다 
(1) HALF_UP  
(2) HALF_DOWN  
(3) EVEN  
여기서 EVEN이 짝수 반올림이고 Math 클래스에는 rint 메서드를 이용해 even 반올림을 한다  
  
### rint는 짝수 반올림을 뜻한다  
사실 rint는 잘 쓰일 일이 없는데, 그냥 이런 게 있으니 간단히 알아두고 가자    
![image](https://user-images.githubusercontent.com/101965836/165445658-72d7b43a-3765-4eec-bb44-954d9040816f.png)   
![image](https://user-images.githubusercontent.com/101965836/165445785-75b02033-b694-4df1-8a71-0a469a8885c2.png)  
  
#### rint를 쓰는 이유는 합의 오차를 줄이기 위해서 이다   
밑에 60.0 65.0 60.0을 보면   
원래 합이 60인데 그냥 .5에 무조건 올림을 해버리면 합이 65가 되어버리는, 즉 오차가 발생한다   
하지만 rint를 쓴 합은 60이므로 그냥 .5에서 반올림 하는 것 보다 오차가 더 적다는 것을 알 수 있다.   

## 9-25,26 래퍼(wrapper)클래스  
8개의 기본형을 객체로 다뤄야할 때 사용하는 클래스  
```
public final class Integer extends Number implements Comparable {
	...
	private int value;
	...
}
```
int의 경우 위와 같이 Integer가 있으며, 안에 private 멤버 변수로 value를 저장한다.    
기본형을 객체로 다뤄야 할 때가 있는데 이때 쓰는게 wrapper 클래스다   
8개의 기본형에서 첫 글자를 대문자로 하면 wrapper 클래스가 된다.  

![image](https://user-images.githubusercontent.com/101965836/165455209-c50c698a-14b1-419a-8eb1-053d4c078eb9.png)  
여기서 char과 int는 Char Int가 아니라 Character Integer로 풀네임으로 쓴다.  
  
객체지향 언어의 철학이 좀 담겨있기도 하다.  
객체지향 언어에서는 모든것이 객체여야 하는데, 이렇게 기본형도 객체로 다룰 수 있다는 것을 알아두자.  
한편 그러면 기본형도 없이 다 객체로 만들어 두면 되지 않느냐 할 수 있는데  
이는 성능 문제 때문에 기본형도 같이 두고 있는 것이다.   

## 9-27 Number 클래스  
모든 숫자 래퍼 클래스의 조상이다  
![image](https://user-images.githubusercontent.com/101965836/165455812-3c135e02-43ce-4b6e-8d24-624c9b650a32.png)  
```  
public abstract class Number implements java.io.Serializable {
	public abstract int 		intValue();
	public abstract long		longValue();
	public abstract float 	floatValue();
	public abstract double	doubleValue();
	
	public byte byteValue() {
		return (byte)intValue();
	}
	
	public short shortValue() {
		return (short)intValue();
	}
}
```
추상 클래스이며  
래퍼 객체의 값을 기본형으로 반환해주는 매서드를 갖고 있다.  
일단은 이런 매서드를 갖고 있다는 정도만 알아두고 다음 챕터에서 자세히 보자  

## 9-28 문자열을 숫자로 변환하기  
문자열을 숫자로 변환하는 다양한 방법  
```
int 		i 	= new Integer("100").intValue();
int 		i2	= Integer.parseInt("100");
Integer i3 	= Integer.valueOf("100");
```
![image](https://user-images.githubusercontent.com/101965836/165457864-6937ffe0-8ed1-4de9-9b9b-d9024e0e2493.png)  
  
문자열을 기본형으로 바꿀지 래퍼 클래스로 바꿀지에 따라서 parse와 valueOf로 나뉘긴 하지만  
그냥 사실 valueOf로 써도 둘 다 된다.  
또 문자열 -> 래퍼 클래스 변환에는 래퍼 클래스 생성자를 이용해서 Byte b = new Byte("10"); 이런 식으로 해도 된다.    

### n진법의 문자열을 숫자로 변환하는 방법  
```
int i_bin = Integer.parseInt("100",2);  // 2진수
int i_hex = Integer.parseInt("100",16);	// 16진수
```

## 9-30 오토박싱 & 언박싱
int -> Integer로 자동으로 바꿔주는 것을 **오토박싱** 이라고 한다
int <- Integer로 바꾸는 것은 **언박싱** 이라고 한다  
그냥 Wrapping 한 거를 개봉해주거나, int를 다시 wrapping 하거나 하기 때문에 오토박싱 언박싱이라고 하는 것이다  
### JDK1.5 이전에는 기본형과 참조형간의 연산이 불가능했다  
```
int i = 5;
Integer iObj = new Integer(7);

int sum = i + iObj;  // 기본형과 참조형간의 덧셈. JDK1.5 전에는 불가능 했다  
```
JDK 1.5부터는 기본형과 참조형 연산은 컴파일러가 자동으로 int sum = i + iObj.intValue();로 바꿔서 컴파일한다.  

### 추가 예시
```
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(10);

int value = list.get(0);
```


\<Integer>는 지네릭스(제네릭) 인데 12장 가서 배운다   
위 코드에서 list.add(10); 는 자동으로 오토박싱을 통해 list.add(new Integer(10)); 으로 변경된다  
마찬가지로 아래에서 int value = list.get(0);도 new Integer(10)을 자동으로 언박싱을 통해 intValue() 값으로 바꿔서 기본형 int 변수인 value에 넣어준다.  
	
