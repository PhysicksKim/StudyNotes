[자바의정석 기초편 강의로 이동](https://www.youtube.com/playlist?list=PLW2UjW795-f6xWA2_MUhEVgPauhGl3xIp)  

# 6. 객체지향 프로그래밍 I

## 6-2 클래스와 객체
Q. 클래스가 왜 필요함?    
A. 객체를 생성하기 위해서  
  
Q. 객체가 왜 필요한가?  
A. 객체를 사용하기 위해서    
  
Q. 객체를 사용한다는 게 무슨뜻?  
A. 객체가 가진 속성(프로퍼티;변수)과 기능(매서드;함수)을 사용하려고  

Q. 왜 클래스를 만들어서까지 사용해야함?  
A. 비슷한 속성과 기능을 가졌지만 설정 값 같은 것들만 다른 녀석들을 여럿 찍어내서 사용하려고  

## 6-3 객체의 구성요소 - 속성과 기능
어떤 사물이 있으면 그 사물의 속성과 기능이 있다.  

Tv  
- 속성 : 크기 길이 높이 색상 볼륨 채널 등
- 기능 : 켜기 끄기 볼륨조절 채널변경 등 

속성(property) - 멤버변수(variable)  
기능(function) - 메서드(method)   
  
## 6-4 객체와 인스턴스   
#### 인스턴스   
어떤 클래스로부터 만들어진 객체  
#### 인스턴스화    
클래스로부터 객체를 만드는 과정을 인스턴스화(instantiate)라고 한다.   

객체와 인스턴스는 거의 같은 말.   
서로 차이는.  
```
책상은 객체다  
책상은 책상 클래스의 인스턴스다
```
인스턴스는 클래스로부터 만들어졌음을 강조하는 의미가 담겨있다.  
두 용어를 엄밀히 구분할 필요까지는 없지만, 문맥에 따라 구별하는게 좋다.   

## 6-5 하나의 소스 파일에 여러 클래스 작성 
파일 이름과 public, 대소문자구분 정도만 유의하면 된다.

1. public class 가 있다면, 해당 클래스와 파일 이름이 일치해야 한다.   
2. public class 가 없다면, 파일 이름은 어떤 클래스의 이름이건 가능하다.   
3. public class는 하나의 파일에 하나만 존재 가능하다.   
4. 대소문자 일치해야한다.   
  
## 6-6 객체의 생성과 사용

### 1. 객체의 생성
```
클래스명 변수명;
변수명 = new 클래스명();
```
```
Tv t; // Tv 클래스 타입의 참소변수 t를 선언
t = new Tv();  // Tv 인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```
이걸 한줄로 쓰면
```
Tv t = new Tv();
```
### 2. 객체의 사용
```
t.channel = 7;
t.channeldown();
System.out.println("현재 채널은 " + t.channel + " 입니다.");
```

## 6-7 생성과 사용 예제 - (실제로 메모리 상에서 어떻게 생겼는지)

```
Tv t = new Tv();
```
Tv t로 생성된 t는 참조 변수가 생성됨. 그 다음 new에 의해서 Tv클래스 설계도에 따라서 Tv형식 인스턴스가 생성됨. 그리고 대입연산자 =에 의해서 t가 새로 생성된 Tv()형식 인스턴스를 가리키게됨.  
  
  
생성된 인스턴스는 가비지 컬랙터가 알아서 관리(필요 없어지면 삭제) 해줌. 이 점에서 C++보다 편리함.      

## 6-8 객체 배열
객체 배열 생성
```
Tv tv1, tv2, tv3;
Tv tvArr = new Tv[3];
tvArr[0] = tv1;
tvArr[1] = tv2;
tvArr[2] = tv3;
```
배열 초기화 아래와 같이도 가능
```
Tv tvArr = {new Tv(), new Tv(), new Tv()}; 
```

## 6-9 클래스의 정의(1)
클래스는 아래의 3 가지 용도로 쓰인다  
1. 설계도
2. 데이터와 함수의 결합
3. 사용자 정의 타입
  
=> 클래스 == 데이터 + 함수  

처음에 데이터를 저장하는 방식은 **변수** 만 있었다.  
그런데 같은 종류를 묶어서 쓰고 싶어서 **배열** 이 나왔다.  
근데 서로 다른 타입의 데이터들도 하나로 묶고 싶어서 **구조체** 가 나왔다.  
   
여기서 더 나아가서  
관련있는 **데이터들** 뿐만 아니라 **함수** 도 같이 묶고 싶어졌다. 그래서 
#### 클래스 
가 나왔다

## 6-10 클래스의 정의(2)
앞서 클래스 용도에서 **사용자 정의 타입** 으로도 쓰인다고 했다.  
즉 원하는 타입을 만들 수 있다.  
  
  
예를 들어 **시간** 데이터들을 처리해야 한다고 해보자  
```
int hour1, hour2, hour3;
int minute1, minute2, minute3;
int second1, second2, second3;
```
이렇게 일일이 다 따로따로 나뉘어 있으면 너무 귀찮게 된다.
따라서 아래와 같이 사용자 정의 타입으로 Time 클래스를 정의할 수 있다.
```
Time t = new Time();
Time[] timeArr = {new Time(), new Time(), new Time()};
```
이렇게 아주 간결하게 만들어 질 수 있다.  

## 6-11 선언 위치에 따른 변수의 종류
<strong>어디에서 선언</strong>됐는가에 따라서 <strong>3가지</strong>로 나뉜다.  
영역은 **1.클래스영역** **2.메서드영역** 으로 나뉜다. 
  
```
class Variables
{
  int iv;         // (1) 인스턴스 변수 instance variable
  static int cv;  // (2) 클래스 변수(static 변수, 공유 변수)
  
  void method()
  {
    int lv = 0;   // (3) 지역 변수 local bariable
  }
}
```

여기서 상식적으로 일단 lv는 메서드가 실행 될 때 생성되고, 메서드 안에서 선언 될 것이다.   
  
  
그러면 클래스 영역에 있는 in와 cv는 어떻게 될까?  
먼저 iv는 **인스턴스가 생성** 될 때 생성된다. 각 인스턴스가 개별적으로 iv값을 갖게된다. 예를 들어서 tv1.channel == 3이고 tv2.channel == 4 일 수 있다.  
반면 cv는 **클래스가 갖는 값** 이므로 **클래스가 메모리에 올라갈 때** (달리 말하면, 클래스가 정의될 때) 생성된다.   

## 6-12 클래스 변수와 인스턴스 변수

**선언 위치** 에 따라서 변수가 달라진다 했다. 
1. 클래스 영역
2. 메서드 영역 
  
그럼 클래스 변수와 인스턴스 변수가 어떻게 다른지 알아보자  

![image](https://user-images.githubusercontent.com/101965836/164894339-97d78f28-d5fe-45a2-8175-aa6ddcc23b3e.png)  
![image](https://user-images.githubusercontent.com/101965836/164894356-f36eb891-b90b-408c-9655-df4cea072b71.png)  
카드의 높이와 폭은 공통적으로 같아야 한다. 따라서 클래스 변수(static)로 선언한다.     
카드의 무늬나 숫자는 카드마다 달라야 한다. 따라서 인스턴스 변수로 선언한다.  

```
Card c = new Card();
c.kind = "HEART";
c.number = 5;

// c.width = 200; 가능은 하나 권장하지 않는 방법
// c.height = 300;

Card.width = 200;
Card.height = 300;
```


## 6-14~19 메서드란? 메서드 선언 구현 호출 실행 흐름
기본적인 메서드 내용이라 생략

## 6-20 return문
반환 타입이 void이면 return 생략 가능  
void가 아닌 경우 반드시 return문 필요  
```
int max(int a, int b) {
  if(a > b)
    return a;
}
```
이런 경우 if가 false일 때 return문이 없으므로 에러가 난다. 따라서 분기가 나뉘면 모든 경우에 return이 있도록 해야한다.  

## 6-21 반환값
반환 형이 일치해야한다. 또는 자동 형변환이 가능해야한다.  

## 6-22 호출 스택(call stack)
  ![image](https://user-images.githubusercontent.com/101965836/164895231-a6af2c10-7577-4bf2-9a88-937906ff8705.png)  
메서드가 호출 될 때마다, 콜 스택에 쌓이게 된다. 콜 스택에서는 한 번에 하나의 메서드만 실행되며, 실행이 끝난 메서드는 사라지게 된다.   
  
  
## 6-23 기본형 매개변수
메소드의 매개변수 타입이 기본형이라는 뜻.  
- 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.  (Read)
(int 같은 것들)
- 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.  (Read & Write)
(배열 같은 것들)


## 6-24 참조형 매개변수
![image](https://user-images.githubusercontent.com/101965836/164895783-10f16311-5e1f-4dcc-884a-1bab681142a9.png)

### 참조형 반환타입
![image](https://user-images.githubusercontent.com/101965836/164895802-b02ee9fc-3e32-4cf1-9bb3-46bbefe44967.png)  

## 6-26 ~ 29 static 메서드 & 인스턴스 메서드

|인스턴스 메서드 | static 메서드 |
|--------------|---------------|
|인스턴스 변수 사용 가능|인스턴스 변수 사용 불가|
|참조변수.메서드이름()|클래스이름.메서드이름()|

static 메서드는 instance variable을 사용하지 않을 때 쓴다. 딱 이 차이밖에 없다. 메서드 안에서 iv를 써야하면 인스턴스 메서드로 만들어야 하고, iv를 안 쓰면 static으로 만들어도 된다.  

### static 메서드는 인스턴스 변수(iv)를 사용할 수 없다
왜?  
static 메서드는 객체가 생성되지 않았을 때도 사용이 가능하다 ex. Math.random()  
근데 만약, 객체를 생성하지 않은 채로 static 메서드에서 인스턴스 변수를 사용한다면?  
인스턴스 변수가 아직 초기화 되지 않았는데, 인스턴스 변수를 갖고와야 하기 때문에 에러가 난다.  
따라서 인스턴스 변수는 static 메서드에서 사용될 수 없다.  
매개변수로 값을 받아와서 사용하거나 static 변수를 사용하는 메서드로만 만들어야 한다.   

### 메서드간 호출과 참조
인스턴스 메서드에서는 다른 인스턴스 메서드나 static 메서드를 호출 할 수 있다.  
다른 인스턴스 메서드는 객체를 생성할 때 같이 생성 됐기 때문이다. static 메서드는 어차피 항상 호출 가능한 메서드이므로 문제없다.  
   
반면 static 메서드는 인스턴스 메서드를 호출할 수 없다. 당연히 인스턴스가 선언되지 않은 경우에 에러가 나기 때문이다.  

### 정리
1. static 메서드에서 static 메서드 호출 => O
2. static 메서드에서 인스턴스 변수 사용 => X
3. static 메서드에서 인스턴스 메서드 호출 => X


## 6-30,31 메서드 오버로딩(overloading)
같은 이름의 메서드를 여러 개 정의하는 것  
![image](https://user-images.githubusercontent.com/101965836/164896354-a060e56c-53a9-4e33-9660-2a292949fa1e.png)  

### 오버로딩 성립 조건
1. 메서드 이름이 같아야 함
2. 매개변수 개수 또는 타입이 달라야 함

**반환 타입은 상관없음**  
예를 들어, 
```
int add(int a, int b) { return a+b; }
long add(int a, int b) { return (long)(a+b); }
```
이 경우 반환 타입은 상관 없으므로 오버로딩이 정의되지 않는다.  
왜? 호출 될 때 myClass.add(10,20); 으로 호출 될 텐데, 언제 int 반환 타입으로 쓸지 long 반환 타입으로 쓸 지 모호하기 때문이다.  

## 6-32~35 생성자, 기본 생성자
### 생성자
생성자는 이름이 클래스 이름과 같아야 한다  
생성자도 오버로딩 가능  
```
class Card {
  Card() {
  
  }
  Card(String kind, int number){
  
  }
}
```


### 기본 생성자 (= 매개변수가 없는 생성자)
```
Card c = new Card()
```

생성자가 하나도 없을 때만 컴파일러가 기본 생성자를 자동으로 추가한다.  
반대로 생성자가 한 개라도 있을 경우, 기본 생성자 Card() 같은 식으로 만들어 놓지 않고서 기본 생성자 처럼 호출하면 에러가 난다  
```
// 에러나는 경우
class Card {
  String kind;
  Card(String k){
    kind = k;
  }
}
...
  
  // Card c = new Card(); //에러
  
```

### 매개변수가 있는 생성자

## 6-36,37 생성자 this() 참조변수 this
### 생성자 this()
생성자에서 다른 생성자 호출할 때 사용한다
![image](https://user-images.githubusercontent.com/101965836/164897622-1ebbffee-9ebb-450b-afa2-a16ed05ad743.png)  

**반드시! 생성자 호출시 첫 줄에서만 사용가능**

```
Car(String color) {
  door = 5; // (1) 첫 줄에 this()를 쓰지 않아서 에러!
  Car(color, "auto", 4); // (2) this()라고 쓰지 않고 클래스이름()으로 써서 에러!
}
```

### 참조변수 this
생성자 this()랑은 관련 없음  
  
  
- 인스턴스 자신을 가리키는 참조변수
- 인스턴스 메서드에서 사용 가능 + 생성자에서도 사용 가능
- 지역변수(lv)와 인스턴스 변수(iv)를 구별할 때 사용  

## 6-38~41 변수 초기화, 멤버변수 초기화
### 1. 명시적 초기화 (=)
```
class Car {
  int door = 4;             // 기본형 변수의 초기화 (primitive type)  
  Engine e = new Engine();  // 참조형 변수의 초기화 (reference type)  
  ...
}
```
참조형 변수는 기본은 null 값을 가지므로, 객체 주소 값을 갖도록 초기화 해줘야 한다.   
Engine e; 라고만 해버리면 null 값을 갖게 된다.  

### 2. 초기화 블럭
복잡한 초기화에서 사용한다. 괄호 안에 여러 문장을 넣을 수 있다.  
- 인스턴스 초기화 블럭 : { }  
- 클래스 초기화 블럭 : static { }  

### 3. 생성자  
iv 초기화에 사용. 복잡한 초기화에 사용.  

  
정리하면  
1. 자동초기화
2. 간단초기화
3. 복잡초기화  

### 멤버변수의 초기화
클래스 변수 초기화 시점 : 클래스가 처음 로딩될 때 단 한번(메모리에 올라갈 때)  
인스턴스 변수 초기화 시점 : 인스턴스가 생성될 때 마다
  
  ---
  
# 7. 객체지향 프로그래밍 II

## 7-1,2 상속(Inheritance)
기존 클래스로 새로운 클래스를 만드는 것    
  
두 클래스는 부모와 자식 관계를 갖는다.  

```
class Parent {}
class Child extends Parent {
  // ...
}
```

- 자손은 조상의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)   
- 자손의 멤버 수는 조상보다 적을 수 없다.  

![image](https://user-images.githubusercontent.com/101965836/164959195-4797ad22-645b-4589-b89d-1513e73b9764.png)  
  
- 자손의 변경은 조상에 영향을 미치지 않는다.  
  
![image](https://user-images.githubusercontent.com/101965836/164959249-06a6472e-ef06-4623-95c3-0ec6bf0833ff.png)
  
  
### 그냥 부모 멤버들을 다 별개로 상속 받는다
![image](https://user-images.githubusercontent.com/101965836/164959389-00083428-0b39-4961-a86f-e992e921b6c3.png)  
(1)방식이든지 (2)방식이든지 둘 다 똑같이 자신만의 x,y,z 멤버를 갖는다.  
단 상속받는경우 부모가 변경되면 자식도 변경된다.  

## 7-3,4 포함관계
### 포함(composite)이란?
클래스 안에 멤버로다가 다른 클래스를 선언해서 쓰는 것.  
```
class Point {
  int x; 
  int y;
}
class Circle {
  Point c = new Point();
  int r;
}
```
Point 클래스를 사용해 참조변수 c를 생성했다.  
  
### 클래스간 관계 결정하기
상속관계 : "~은 ~이다" (is - a)  
포함관계 : "~은 ~을 가지고 있다" (has - a)  
  
## 7-5,6 단일상속, Object클래스
### Java는 단일상속만 허용
(c++은 다중상속 허용)  
```
class TvDVD extends Tv, DVD { } // 에러
```
Tv와 DVD 둘 다 상속하면 편할 수 있다. 하지만 기존 C++에서 다중 상속이 갖는 문제점 때문에 프로그래머들이 JAVA에서는 단일상속만 가능하도록 했다.  

예를 들어, Tv와 DVD 둘 다에서 void power() 라는 메서드가 있으면 충돌이 발생하게 된다.  
이러한 상속 구조가 복잡해지면 충돌문제를 해결하기 어려워진다.  
인터페이스를 이용하면 충돌문제를 해결하면서 다중상속과 같이 작성할 수 있다.  
비중이 높은 클래스 하나만 상속받고, 나머지는 포함관계로 한다.   
![image](https://user-images.githubusercontent.com/101965836/164959851-c305365a-a18c-4b71-99b9-bc855145eeda.png)  

### Object클래스
모든 클래스의 조상  
부모가 없는 클래스는 자동적으로 Object 클래스의 상속을 받게된다.  
```
class Tv {  // class Tv extends Object 와 같음
  // ...
}
```
Object 클래스에 정의된 11개의 메서드를 상속받는다.  
11개가 뭔지 다 알 필요는 없고, 대표적으로 toString() equals(Object obj) hashCode() 정도 알아두면 되며, 9장에서 배운다.  
  
  
## 7-7~9 오버라이딩
### 메서드 오버라이딩(overriding)
override 덮어쓰다  
  
상속받은 조상 메서드를 덮어쓰는 것   
선언부는 변경할 수 없고, 구현부만 변경 가능하다.  
구현부는 {}안에 있는 내용을 말한다.  
매개변수를 바꿔서 또 쓰는건, 오버라이딩이 아니라 오버로딩이다.  
```
class Point {
  int x;
  int y;
  String getLocation() {
    return "x :" + x + ", y :"+ y;
  }
}

class Point3D extends Point {
  int z;
  
  String getLocation() {
    return "x :" + x + ", y :" + y + ", z :" + z;
  }
}
```
이렇게 하면 Point.getLocation() 이랑 Point3D.getLocation()이랑 동일한 의도로 동작하기 때문에 직관적인 코드가 된다.  

### 오버라이딩 조건
#### 1. 선언부가 조상 클래스의 메서드와 일치해야 한다.  
![image](https://user-images.githubusercontent.com/101965836/164960145-f2a87ac2-f51d-44ea-a567-ed9648ec956d.png)  
선언부 일치! 선언부 = (1) 반환 타입 (2) 메서드 이름 (3) 매개변수 목록    
#### 2. 접근 제어자를 조상 메서드보다 좁은 범위로 변경할 수 없다.
접근 제어자 = public protected (default) private
#### 3. 예외는 조상 메서드보다 많이 선언할 수 없다.  
![image](https://user-images.githubusercontent.com/101965836/164960200-97c6ecd2-7b87-4a19-8a84-7ca0f31690f5.png)  
예외는 지금 이해는 안되겠지만, 8장가서 배우게 된다.  

### 오버로딩 vs 오버라이딩
오버로딩(overloading) 이름만 같을 뿐 새로운 메서드를 정의하는 것(new) 상속이랑 전혀 관련없음  
오버라이딩(overriding) 상속받은 메서드의 내용을 변경하는 것(change, modify) 상속과 관계있음  

## 7-10,11 참조변수 super
this와 거의 같다  
객체 자신을 가리키는 참조변수, 인스턴스 메서드(생성자) 내에만 존재 (static에서 사용 불가)  
this는 lv와 iv 구별에 사용하고  
super는 조상멤버와 자신멤버를 구별할 때 사용한다.  
  
예를 들어 이름이 같은 멤버 변수를 가지는 경우, 조상의 멤버 변수를 선택 할 때 사용된다.   

### 예시
(1) 조상 자식 둘 다 x라는 이름의 변수가 있는 경우
```Java
class Ex7_3 {
  public static void main(String args[]){
    Child c = new Child();
    c.method();
  }
}

class Parent { int x = 10; }

class Child extends Parent {
  int x = 20;
  
  void method() {
    System.out.println("x=" + x);             // x=20
    System.out.println("this.x=" + this.x);   // this.x=20
    System.out.println("super.x=" + super.x); // super.x=10
  }
}
```
(2) 조상 자식 둘 다 x라는 이름의 변수가 있는 경우
```Java
class Ex7_3 {
  public static void main(String args[]){
    Child2 c = new Child2();
    c.method();
  }
}

class Parent2 { int x = 10; }

class Child2 extends Parent2 {
  
  void method() {
    System.out.println("x=" + x);             // x=10
    System.out.println("this.x=" + this.x);   // this.x=10
    System.out.println("super.x=" + super.x); // super.x=10
  }
}
```  
### super() - 조상의 생성자 
super랑은 전혀 관련 없다.  
조상의 생성자를 호출할 때 사용한다.  
**super()는 왜 있는거임?**  
-> 생성자와 초기화블럭은 상속이 안되기 때문에 필요하다.   
  
```Java
class Point {
  int x, y;
  
  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}

class Point3D extends Point {
  int z;

  Point3D(int x, int y, int z) {
    super(x, y);
    this.z = z;
  }
}
```  
조상의 멤버를 직접 this.x = x; 같은 식으로 초기화해버리면 안좋다.  
왜? 조상 멤버의 초기화는 조상 생성자가 해야지 코드가 안꼬인다.  
  
## 중요  
### super() 사용시 유의사항
생성자의 첫 줄에 반드시 생성자를 호출해야 한다.  
그렇게 안하면? 컴파일러가 생성자의 첫 줄에 super();를 삽입한다.  
![image](https://user-images.githubusercontent.com/101965836/164960773-10138c32-021a-4fff-ade5-9f1e7d62940d.png)  

### 예시 
![image](https://user-images.githubusercontent.com/101965836/164960825-b35feb22-ef06-47a6-9192-353aea20dfcf.png)  

에러가 왜 났을 까?  
모든 생성자는 첫 줄에 다른 생성자를 호출해야 한다.  
그렇지 않으면? super(); 를 넣어주게 된다.  
  
Point 클래스의 생성자는 super();가 자동으로 들어가고, super의 정체는 Object(); 이다.  
왜냐하면 따로 상속하는 클래스가 없으면 Object를 자동으로 상속하기 때문이다.  
  
  
근데 Point3D의 생성자에서도 첫줄에 따로 생성자를 호출하지 않는다.  
따라서 super();가 자동으로 들어가게 된다.  
근데 Point3D의 조상은 Point클래스인데, Point클래스에는 super(); // = Point(); 라는 생성자가 없다.  
따라서 에러가 발생하게 된다.  

### 해결방안
1. Point() 생성자를 추가한다
2. super(x,y)를 추가한다.  

근데 기본 생성자 ()를 추가해주는 편이 어지간하면 좋다.  

## 7-12~14 패키지, 클래스 패스  
### 패키지란?  
- 서로 관련된 클래스의 묶음

### 패키지는 어떤 구조로 저장되어있나?
- 클래스는 .class 파일에 저장됨
- 패키지는 폴더에 저장됨
- 하위 패키지는 하위 폴더에 저장됨  

### 클래스의 진짜 이름
- 진짜 이름은 사실 패키지를 포함한다 (ex. java.lang.String)

### rt.jar 파일
- 클래스들을 압축한 파일 (JDK 설치경로의 \jre\lib에 위치)
- Java9부터 없어짐 (9부터 module 개념이 들어가는데, rt.jar이 너무 커서 module로 나뉘게 된다)  

### 패키지 선언
- package (패키지 이름); 으로 선언
```
package mypackage;
```
- 소스파일의 첫 문장에서 선언 해줌
- 단 한번만 선언 
- 그 소스파일 안의 클래스들은, 해당 패키지 아래에 속하게 된다
- 패키지 선언이 없으면, 이름 없는 패키지에 속하게 된다. (default package)   
![image](https://user-images.githubusercontent.com/101965836/164964687-bfb4d3ac-83d3-4547-a4ec-29fed1722faf.png)  
  
### 클래스 패스
클래스 파일의 위치를 알려주는 경로   
OS의 환경 변수에다가 classpath를 추가해주면 일일이 클래스 패스를 입력하지 않아도 자동으로 환경 변수 안에있는 path에서 해당 클래스 이름을 인식하게 된다.    

## 7-15,16 import문 static import문
### import문 예시
```
import 패키지명.클래스명;
import 패키지명.*; // 모든 클래스
```

### import문
- 클래스를 사용할 때 패키지이름을 생략할 수 있다.    
- 컴파일러에게 클래스가 속한 패키지를 알려준다.    
- 단축키 \[ **ctrl + shift + O** ] 를 누르면 자동으로 import 문이 만들어 진다.  

### 예시
```
java.util.Date today = new java.util.Date();
```
이런 식으로 일일이 다 칠 필요없이
```
import java.util.Date;

class ImportTest {
  Date today = new Date();
}
```
이렇게 import를 넣어서 간단하게 줄일 수 있다.  

### java.lang 패키지는 생략가능
String 같은 패키지들은 생략가능  

### import문은 패키지문과 클래스선언 사이에 위치
```
package mypackage;

import java.util.*;

public class PackageTest {
  ...
}
```

### import 많이 써도 성능에 영향 없음
어차피 컴파일러에게 import할 위치를 알려주는 작업이므로 성능과 무관하다. 그냥 컴파일 할때만 더 오래걸릴 뿐, 런타임에서는 상관없다.  

### static import문
![image](https://user-images.githubusercontent.com/101965836/164966587-846c9bee-1a16-49a0-ace2-a526ecff95d7.png)  


## 7-17~20 제어자 static final abstract

### 제어자 (modifier)
- 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여  

접근제어자 : public, protected, (default), private  
그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp  
  
- 접근 제어자는 하나만 쓸 수 있다  
- 그 외 제어자들은 여러 제어자를 같이 쓸 수 있다  
- 제어자의 순서는 상관없지만, 관례적으로 접근 제어자를 제일 앞에 쓴다  

### static 
- 클래스의, 공통적인 이라는 뜻
- 클래스 외에도, 클래스 변수, 클래스 초기화 블럭, 클래스 메서드에도 사용된다.  

### final
- 마지막의, 변경될 수 없는 이라는 뜻
  
final의 대상 : 클래스, 메서드, 멤버변수, 지역변수  

```
final class FinalTest {       // 조상이 될 수 없는 클래스
  final int MAX_SIZE = 10;    // 값을 변경할 수 없는 멤버변수(상수)
  
  final void getMaxSize() {   // 오버라이딩 할 수 없는 메서드(변경불가)
    final int LV = MAX_SIZE;  // 값을 변경할 수 없는 지역변수(상수)
    return MAX_SIZE;
  }
}
```
final 클래스는 예를 들어 String이나 Math 등이 있다.  
  
  
### abstract
- 추상의, 미완성의  
abstract의 대상 : 클래스, 메서드  
```
abstract class AbstractTest { // 추상 클래스 (추상 메서드를 포함한 클래스)
  abstract void move();       // 추상 메서드 (구현부가 없음)
}
```
추상(미완성) 클래스란 추상 메서드를 갖고 있는 클래스를 말한다  
추상 메서드란 아직 구현부를 완성하지 않은 메서드를 말한다  
따라서 추상 클래스는 인스턴스를 생성할 수 없다  
```
AbstractTest a = new AbstractTest(); // 에러. 
```
#### 그러면 추상 클래스는 언제 쓰냐?
추상클래스를 상속받아서 완전한 클래스를 만든후에 객체 생성이 가능하다  
이 내용은 나중에 또 다시 설명한다  

## 7-21 접근제어자
(access modifier)
|접근제어자|설명|
|---|---|
|private| 같은 클래스 내에서만 접근 가능 |
|(default)| 같은 패키지 내에서만 접근 가능|
|protected| 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근 가능 |
|public| 접근 제한 없음 |
  
![image](https://user-images.githubusercontent.com/101965836/164968070-77d46b12-dbee-4e5d-898e-02b6c843b511.png)   
![image](https://user-images.githubusercontent.com/101965836/164968681-2a1527c0-7edf-453a-870f-28133249a9f5.png)    
  

## 7-22 캡슐화
접근 제어자를 사용하는 이유 : 데이터를 외부로부터 보호하기 위해서 => 이걸 **캡슐화** 라고 한다

## 7-23 다형성(Polymorphism) 
- 여러 가지 형태를 가질 수 있는 능력

#### 다형성이 제일 중요하다
#### 다형성 이해 못하면 뒤에 내용 전부 이해 못함  

### 다형성이 뭔데?
조상 타입 참조 변수로 자식 타입 객체를 다루는 것  


```
class Tv { ... }                  // 부모

class SmartTv extends Tv { ... }  // 자손
```
```
Tv      t = new SmartTv();  // 가능
SmartTv s = new Tv();       // 불가능
```

### 자식 타입 참조가 부모 타입 객체를 가리킬 수 없는 이유 
아래의 논리 순서대로 차근히 생각해보자
1. 부모 타입 클래스보다 자식 타입 클래스에 멤버변수나 메서드가 더 많다 (상속 후 추가로 만들 수 있기 때문)  
2. 참조 변수는 정의되지 않은 것을 가리킬 수 없다
3. 앞서 **1.** 에 따라서 자식 참조 타입은 부모 참조 타입보다 더 많은 것을 가리킨다.
4. 위의 **2.** 와 **3.** 에 따라서, 더 많은것을 가리키는 자식 참조 타입은, 부모 타입 객체를 참조할 수 없다. (왜? 부모 타입에 멤버들이 더 적으니까)  
  
  
### Q&A
#### Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치해야 하나요?
A. No. 일치하는 것이 보통이지만 일치 하지 않을 수도 있습니다.  
#### Q. 참조변수가 조상타입일 때와 자손타입일 때의 차이?
A. 참조변수로 사용할 수 있는 멤버의 갯수가 달라집니다
#### Q. 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 있나요?
A. 아니요. 허용되지 않습니다.  

## 7-24,25 참조변수의 형변환(1)  
사용할 수 있는 멤버 수를 조절하는 것  
  
### 기본형의 형변환과 차이점
기본형의 형변환은? float -> int 같은 경우 **값이 바뀐다**  
그러나  
참조 변수의 형변환은? 값은 안 바뀌고, **멤버의 갯수만** 바뀐다  

### 조상 자손 관계의 참조 변수는 서로 형변환 가능
```
class Car { }
class FireEngine extends Car { }

...

FireEngine f = new FireEngine();
Car c = (Car)f;                 // OK. 부모 참조 <- 자식 참조 변환 (변환형 생략가능)
FireEngine f2 = (FireEngine)c;  // OK. 자식 참조 <- 부모 참조 변환 (변환형 생략불가)
```
### 근데. 이거 대체 왜 있는거임?
**사용할 수 있는 멤버 수를 조절** 하기 위해서   

### 그러면. 자식 타입 참조가 부모 객체를 가리켜도 됨?
=> FireEngine f = new FireEngine(); 말고  
Car c = new Car();로 만들어도됨?  

#### 컴파일은 되지만, 런타임에서 에러가 난다.  
```
Car c = new Car();
FireEngine fe = c; // 여기서 에러 발생. java.lang.ClassCastException

fe.water();
```
![image](https://user-images.githubusercontent.com/101965836/164976906-7bca38d2-92b6-437a-b497-df231dd67601.png)  
  
## 7-26 instanceof 연산자
- 참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환    
  
앞서 봤듯, 형변환이 가능한지 확인하지 않고 형변환 해버리면 에러가 난다.   
  
또한 Object -> Car -> FireEngine 순으로 상속되어 있으니  
  
```jsva
FireEngine fe = new FireEngine();
System.out.println(fe instanceof Object);     // true
System.out.println(fe instanceof Car);        // true
System.out.println(fe instanceof FireEngine); // true
```

### 그래서 instanceof의 핵심은?
1. 형변환이 가능한지 확인 하고 형변환 해야한다.  
2. instanceof는 조상과 자기 자신에 대해서 true를 반환한다  

## 7-27,28 다형성 장점 1 - 매개변수 다형성
이제 본격적으로 왜 다형성을 사용하는지 알게된다  

#### 매개변수 다형성의 장점
1. 다형적 매개변수
2. 하나의 배열로 여러 종류 객체 다루기
가 가능하다.

### 다형성에 대해서 다시 정리
1. Tv t = new SmartTv();  ( 조상 참조 = 자손 객체 )
2. 참조 변수의 형변환 : 한마디로 리모콘 바꾸기. 왜 리모콘 바꿈? 사용가능한 멤버 갯수 조절을 위해서.  
3. instanceoff 연산자 : 왜 씀? 형변환 가능 여부 확인.  

### 그러면 매개변수 다형성은 뭔가? 
Product라는 물건 타입에 대한 부모 클래스가 있고,  
자식으로는 Tv Computer Audio 라는 상품들이 있다고 해보자.  
  
이때 구매하는 사람을 정의하는 Buyer라는 클래스가 있고, Buyer가 buy()라는 메서드를 갖고 있다고 해보자.    
그러면 Buyer는 buy(Tv tv){ } buy(Computer com){ } buy(Audio audio){ }  이렇게 일일이 오버로딩 해야할까?   
아니다. 이 때 다형성을 활용하면, 부모 형식인 Product를 이용해서 buy(Product p){ }로 다 해결할 수 있다.    
  
이게 바로 다형적 매개변수의 장점이다.  
  
  
## 7-29,30 다형성 장점 2 - 여러 종류 객체를 배열로 다루기
다형성을 활용해서 하나의 배열에 여러 종류의 객체를 넣어서 다룰 수 있다.  

```
Product p1 = new Tv();
Product p1 = new Computer();
Product p1 = new Audio();
```
```
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

---

여기까지 정리가 되어 있어야지 뒷 부분을 제대로 이해할 수 있다

---

## 7-31,32 추상 클래스, 추상 메서드
미완성 설계도를 '추상' 이라고 말한다  

### 추상 메서드
몸통(구현부)이 없는 메서드.  

### 추상 클래스
미완성 메서드를 갖고 있는 클래스를 추상 클래스라고 한다.  
그냥 딱, 추상 메서드 갖고 있으면 

```
abstract class Player {         // 추상 클래스
  abstract void play(int pos);  // 추상 메서드
  abstract void stop();         // 추상 메서드
}
```

### 그럼 이걸 어디에 씀?  
다른 클래스 작성에 도움을 주기 위한 것.  
상속을 통해서 추상 메서드를 완성하기 위한 것이다.  
```
class AudioPlayer extends Player {
  void play(int pos) { /* 내용 생략 */ }  
  void stop() { /* 내용 생략 */ }       
}
```
이렇게 추상클래스를 상속받아서 추상 메서드의 구현부를 만들어 주면 이제 제대로 사용할 수 있게 된다.  

### 추상 클래스는 인스턴스 생성 불가
어찌보면 당연하다. 당연히 미완성이니까 쓸 수 없으므로, 인스턴스 생성도 불가능하다
```
Player p = new Player(); // 에러. 추상 클래스는 인스턴스 생성 불가
```
```
AudioPlayer ap = new AudioPlayer(); // OK
Player ap = new AudioPlayer();      // OK. 이부분이 백미. 추상 클래스 참조 타입으로 선언하고, 실제로 구현된 객체를 생성해서 참조 가능하다.
```

### 추상 메서드는 언제 씀?
꼭 필요하지만, 자손마다 다르게 구현될 것으로 예상되는 경우  
  
> 야 Player라면 play()랑 stop()은 있어야 될 거 아니야?!  
> 그니까 너희들 Player 상속하면 꼭 니들 상황에 맞게   
> play()랑 stop() 알아서 구현해서 써라  
  
이렇게 강제해서 쓴다는 의미가 있다.  
  
  
## 7-33,34 추상 클래스의 작성
결국 추상 클래스는  
" **코드가 복잡해지면** 상속 할 때 어떤 메서드는 별도로 꼭 만들어 줘야한다 " 라는 부분이다.  
![image](https://user-images.githubusercontent.com/101965836/165008722-a429286f-dadc-4903-8df0-5d52bd88d2b0.png)  
마린, 탱크, 드랍쉽 전부 공통적으로 위치(x,y), 이동 명령, 정지 명령을 갖고 있다. 따라서 이 공통된 부분을 뽑아서 부모 클래스를 만들 수 있다.  
![image](https://user-images.githubusercontent.com/101965836/165008804-d537c23a-07b1-4f70-8b30-42727c950df4.png)  
근데 이제 보면  
위치와 정지 명령은 동일하게 만들 수 있겠지만,  
움직이는 명령은 다를 수 있다.  
예를 들어 마린과 탱크는 지상유닛이지만, 드랍쉽은 공중유닛이므로 move() 메서드가 다르게 구현 되어야 한다.  
따라서 이런 경우, **"Unit 클래스를 상속받아서 만들 때 꼭 move()는 따로 구현하세요"** 라고 강제하는 효과를 갖도록 하기 위해서  
추상 클래스, 추상 메서드를 사용한다.  

### 다형성 까지 활용
이렇게 해놓으면  
![image](https://user-images.githubusercontent.com/101965836/165008983-2b2199d6-e729-4880-939d-08119b103110.png)  
  
Unit 으로 참조 타입 만들어서 각종 유닛들을 배열에 담을 수 있고,  
또 Unit에 move()가 있으므로 마치 리모콘의 버튼이 있는 형태가 되며,  
실제로 유닛별로 .move()로 실행해도 각 객체에서 상속 후 구현된 move()가 실행된다.  
  
이를 통해서 다양한 객체를 엄청나게 편리하게 다룰 수 있는 장점을 갖게된다.   

#### 홀리몰리 😲


### 그래서 추상화는...  
1. 추상화 코드는 온전히 구현된 코드보다 변경에 유리하다  
2. 추상화와 다형성을 합쳐서 활용하면 위 예시처럼 편하게 다양한 객체를 다룰 수 있다   
  
  
## 7-35~37 인터페이스의 선언, 상속, 구현
인터페이스는? **추상 메서드의 집합**    
추상 메서드 외에도 사실 static 메서드, 상수, 디폴트 메서드 등이 인터페이스 요소에 포함된다.  
하지만 인터페이스의 핵심은 결국 추상 메서드이다.  
따라서 일단은 부수적인 것들은 차치하고, 추상 메서드를 중심으로 인터페이스에 대해 알아보자  

#### 인터페이스는?  
구현된 것이 전혀 없는 설계도. 껍데기. (모든 멤버가 public)  

### 추상 클래스와 인터페이스의 차이는?  
추상 클래스는 일반 클래스인데 추상 메서드를 갖고 있는 것이다  
인터페이스는 추상 메서드 외에는 아무것도 가질 수 없다.  
(물론 멤버 변수를 갖고 있을 수 있도록 중간에 바뀌었다. 그치만 핵심은 아니다)  
  
> 상속은  
> 슈퍼클래스(부모)의 기능을 이용하거나 확장하기 위해서 사용되고, 다중 상속의 모호성 때문에 하나만 상속받을 수 있습니다.  
> 인터페이스는  
> 해당 인터페이스를 구현한 객체들에 대해서 동일한 동작을 약속하기 위해 존재합니다.  
  
또 다르게 설명하면  
상속 방식으로 전달되는 추상 클래스는  
계속해서 조상으로 타고 올라가서도 그 근간이 같은 경우에 사용한다.    
반면 인터페이스의 경우  
성질은 같지만 그 근간은 다른 경우에 사용한다.  
  
예를 들어  
잠수함과 거북이가 있다고 해보자.  
이 때  
거북이는 '생명체' 클래스가 부모이고    
잠수함은 '탈것' 클래스가 부모라고 해보자.  
  
근데 둘은 공통적으로  
'물에서움직이기' 메서드를 갖고 있어야 한다.  

이러면  
추상 클래스를 통한 상속은 각각 거북이는 '생명체'에서, 잠수함은 '탈것'에서 이어지는 게 맞다.  
그러나 '물에서움직이기'는 서로 동작 방식이 다를 수 있다.  
따라서 이러한 경우 인터페이스를 통해서 어떻게 구현해야하는지 설계를 강제할 수 있게 된다.  
상속으로 인한 문제(메서드 충돌)가 발생하지 않는다.  
아무튼 요약하면  
각각 클래스가 특징적으로 가지고 싶은 속성의 경우    
인터페이스로 설계도를 뿌려주는 편이 더 좋기 때문에 인터페이스가 있는 것이다.  

### 추상클래스 vs 인터페이스 예시
![image](https://user-images.githubusercontent.com/101965836/165011706-9b9642c7-28c5-4ce2-b0de-12ded8c5f2f6.png)  
  
  
### 작성법
```
interface 인터페이스이름 {
  public static final 타입 상수이름 = 값;   // final이니까 상수
  public abstract 메서드이름(매개변수목록);  // 추상메서드
}
```

### 인터페이스 유의사항
- 인터페이스의 조상은 인터페이스만 가능
- object가 최고 조상이 아님
- 다중 상속이 가능
- 추상 메서드는 충돌해도 문제 없음(구현부가 어차피 없으니까 충돌 할 게 없음)

### implements 
인터페이스는 상속의 extends처럼 implements를 쓴다.    
차이점은, implements를 쓰면 모두 오버라이딩 해줘야 한다는 차이가 있다.  

#### 일부만 구현하면?  
클래스 앞에 abstract 붙여야 함  

```
class 클래스이름 implements 인터페이스이름 { 
  ...
}
```
```
interface Fightable {
  void move(int x, int y); // 앞에 public abstract 생략된 것
  void attack(Unit u);
}

class Fighter implements Fightable {  
  public void move(int x, int y) { ... }
  public void attack(Unit u) { ... }
}
```
```
// 일부만 구현하는 경우. abstract 붙여야 함
abstract class Fighter implements Fightable {
  public void move(int x, int y){...}
}
```
   
### QNA
Q. 인터페이스란?  
A. 추상 메서드의 집합  
  
Q. 인터페이스의 구현이란?  
A. 인터페이스의 추상메서드 몸통{} 만들기(미완성 설계도 완성하기)  
추상 클래스는 상속(extends)을 통해서 구현하며, 인터페이스는 implements를 통해 구현한다.  
  
Q. 추상 클래스와 인터페이스의 공통점은?  
A. 추상 메서드를 공통적으로 갖는, 미완성 설계도 처럼 어떤 큰 틀을 정해주는 목적을 갖고 있다.  
  
Q. 추상 클래스와 인터페이스의 차이점은?  
A. 인터페이스는 인스턴스 변수를 가질 수 없다.  
정확히 말하면 인터페이스는 추상 메서드, 상수, static 메서드, 디폴트 메서드를 가질 수 있지만, 인스턴스 변수는 가질 수 없다.   
추상 클래스는, 어떤 집단에서 하위 개체들을 정의할 용도로 쓴다. 따라서 개체마다 값만 다르고 의미는 같은 공통 속성들을 변수에 담아서 쓰기위해 만들어진 기능이다. 그러므로 인스턴스 변수를 갖고 있다.    
그러나 인터페이스는, 같은 집단이 아니더라도 공통적으로 발견되는 기능들을 어떻게 구현해야 된다라는 것에 대한 가이드라인을 제시하기 위해 사용한다. 따라서 공통된 속성에 초점을 맞추지 않아서 인스턴스 변수를 갖지 않고, 공통된 기능을 어떻게 구현해야 된다라는 가이드라인에 초점을 맞춰서 탄생한 게 인터페이스이다.    
