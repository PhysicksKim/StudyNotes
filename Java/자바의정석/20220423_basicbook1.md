[자바의정석 기초편 강의로 이동](https://www.youtube.com/playlist?list=PLW2UjW795-f6xWA2_MUhEVgPauhGl3xIp)  

# 6. 객체지향 프로그래밍 I

## 6-2 클래스와 객체
Q. 클래스가 왜 필요함?    
A. 객체를 생성하기 위해서  
  
Q. 객체가 왜 필요한가?  
A. 객체를 사용하기 위해서    
  
Q. 객체를 사용한다는 게 무슨뜻?  
A. 객체가 가진 속성(프로퍼티;변수)과 기능(매서드;함수)을 사용하려고  

Q. 왜 클래스를 만들어서까지 사용해야함?  
A. 비슷한 속성과 기능을 가졌지만 설정 값 같은 것들만 다른 녀석들을 여럿 찍어내서 사용하려고  

## 6-3 객체의 구성요소 - 속성과 기능
어떤 사물이 있으면 그 사물의 속성과 기능이 있다.  

Tv  
- 속성 : 크기 길이 높이 색상 볼륨 채널 등
- 기능 : 켜기 끄기 볼륨조절 채널변경 등 

속성(property) - 멤버변수(variable)  
기능(function) - 메서드(method)   
  
## 6-4 객체와 인스턴스   
#### 인스턴스   
어떤 클래스로부터 만들어진 객체  
#### 인스턴스화    
클래스로부터 객체를 만드는 과정을 인스턴스화(instantiate)라고 한다.   

객체와 인스턴스는 거의 같은 말.   
서로 차이는.  
```
책상은 객체다  
책상은 책상 클래스의 인스턴스다
```
인스턴스는 클래스로부터 만들어졌음을 강조하는 의미가 담겨있다.  
두 용어를 엄밀히 구분할 필요까지는 없지만, 문맥에 따라 구별하는게 좋다.   

## 6-5 하나의 소스 파일에 여러 클래스 작성 
파일 이름과 public, 대소문자구분 정도만 유의하면 된다.

1. public class 가 있다면, 해당 클래스와 파일 이름이 일치해야 한다.   
2. public class 가 없다면, 파일 이름은 어떤 클래스의 이름이건 가능하다.   
3. public class는 하나의 파일에 하나만 존재 가능하다.   
4. 대소문자 일치해야한다.   
  
## 6-6 객체의 생성과 사용

### 1. 객체의 생성
```
클래스명 변수명;
변수명 = new 클래스명();
```
```
Tv t; // Tv 클래스 타입의 참소변수 t를 선언
t = new Tv();  // Tv 인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```
이걸 한줄로 쓰면
```
Tv t = new Tv();
```
### 2. 객체의 사용
```
t.channel = 7;
t.channeldown();
System.out.println("현재 채널은 " + t.channel + " 입니다.");
```

## 6-7 생성과 사용 예제 - (실제로 메모리 상에서 어떻게 생겼는지)

```
Tv t = new Tv();
```
Tv t로 생성된 t는 참조 변수가 생성됨. 그 다음 new에 의해서 Tv클래스 설계도에 따라서 Tv형식 인스턴스가 생성됨. 그리고 대입연산자 =에 의해서 t가 새로 생성된 Tv()형식 인스턴스를 가리키게됨.  
  
  
생성된 인스턴스는 가비지 컬랙터가 알아서 관리(필요 없어지면 삭제) 해줌. 이 점에서 C++보다 편리함.      

## 6-8 객체 배열
객체 배열 생성
```
Tv tv1, tv2, tv3;
Tv tvArr = new Tv[3];
tvArr[0] = tv1;
tvArr[1] = tv2;
tvArr[2] = tv3;
```
배열 초기화 아래와 같이도 가능
```
Tv tvArr = {new Tv(), new Tv(), new Tv()}; 
```

## 6-9 클래스의 정의(1)
클래스는 아래의 3 가지 용도로 쓰인다  
1. 설계도
2. 데이터와 함수의 결합
3. 사용자 정의 타입
  
=> 클래스 == 데이터 + 함수  

처음에 데이터를 저장하는 방식은 **변수** 만 있었다.  
그런데 같은 종류를 묶어서 쓰고 싶어서 **배열** 이 나왔다.  
근데 서로 다른 타입의 데이터들도 하나로 묶고 싶어서 **구조체** 가 나왔다.  
   
여기서 더 나아가서  
관련있는 **데이터들** 뿐만 아니라 **함수** 도 같이 묶고 싶어졌다. 그래서 
#### 클래스 
가 나왔다

## 6-10 클래스의 정의(2)
앞서 클래스 용도에서 **사용자 정의 타입** 으로도 쓰인다고 했다.  
즉 원하는 타입을 만들 수 있다.  
  
  
예를 들어 **시간** 데이터들을 처리해야 한다고 해보자  
```
int hour1, hour2, hour3;
int minute1, minute2, minute3;
int second1, second2, second3;
```
이렇게 일일이 다 따로따로 나뉘어 있으면 너무 귀찮게 된다.
따라서 아래와 같이 사용자 정의 타입으로 Time 클래스를 정의할 수 있다.
```
Time t = new Time();
Time[] timeArr = {new Time(), new Time(), new Time()};
```
이렇게 아주 간결하게 만들어 질 수 있다.  

## 6-11 선언 위치에 따른 변수의 종류
<strong>어디에서 선언</strong>됐는가에 따라서 <strong>3가지</strong>로 나뉜다.  
영역은 **1.클래스영역** **2.메서드영역** 으로 나뉜다. 
  
```
class Variables
{
  int iv;         // (1) 인스턴스 변수 instance variable
  static int cv;  // (2) 클래스 변수(static 변수, 공유 변수)
  
  void method()
  {
    int lv = 0;   // (3) 지역 변수 local bariable
  }
}
```

여기서 상식적으로 일단 lv는 메서드가 실행 될 때 생성되고, 메서드 안에서 선언 될 것이다.   
  
  
그러면 클래스 영역에 있는 in와 cv는 어떻게 될까?  
먼저 iv는 **인스턴스가 생성** 될 때 생성된다. 각 인스턴스가 개별적으로 iv값을 갖게된다. 예를 들어서 tv1.channel == 3이고 tv2.channel == 4 일 수 있다.  
반면 cv는 **클래스가 갖는 값** 이므로 **클래스가 메모리에 올라갈 때** (달리 말하면, 클래스가 정의될 때) 생성된다.   

## 6-12 클래스 변수와 인스턴스 변수

**선언 위치** 에 따라서 변수가 달라진다 했다. 
1. 클래스 영역
2. 메서드 영역 
  
그럼 클래스 변수와 인스턴스 변수가 어떻게 다른지 알아보자  

![image](https://user-images.githubusercontent.com/101965836/164894339-97d78f28-d5fe-45a2-8175-aa6ddcc23b3e.png)  
![image](https://user-images.githubusercontent.com/101965836/164894356-f36eb891-b90b-408c-9655-df4cea072b71.png)  
카드의 높이와 폭은 공통적으로 같아야 한다. 따라서 클래스 변수(static)로 선언한다.     
카드의 무늬나 숫자는 카드마다 달라야 한다. 따라서 인스턴스 변수로 선언한다.  

```
Card c = new Card();
c.kind = "HEART";
c.number = 5;

// c.width = 200; 가능은 하나 권장하지 않는 방법
// c.height = 300;

Card.width = 200;
Card.height = 300;
```


## 6-14~19 메서드란? 메서드 선언 구현 호출 실행 흐름
기본적인 메서드 내용이라 생략

## 6-20 return문
반환 타입이 void이면 return 생략 가능  
void가 아닌 경우 반드시 return문 필요  
```
int max(int a, int b) {
  if(a > b)
    return a;
}
```
이런 경우 if가 false일 때 return문이 없으므로 에러가 난다. 따라서 분기가 나뉘면 모든 경우에 return이 있도록 해야한다.  

## 6-21 반환값
반환 형이 일치해야한다. 또는 자동 형변환이 가능해야한다.  

## 6-22 호출 스택(call stack)
  ![image](https://user-images.githubusercontent.com/101965836/164895231-a6af2c10-7577-4bf2-9a88-937906ff8705.png)  
메서드가 호출 될 때마다, 콜 스택에 쌓이게 된다. 콜 스택에서는 한 번에 하나의 메서드만 실행되며, 실행이 끝난 메서드는 사라지게 된다.   
  
  
## 6-23 기본형 매개변수
메소드의 매개변수 타입이 기본형이라는 뜻.  
- 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.  (Read)
(int 같은 것들)
- 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.  (Read & Write)
(배열 같은 것들)


## 6-24 참조형 매개변수
![image](https://user-images.githubusercontent.com/101965836/164895783-10f16311-5e1f-4dcc-884a-1bab681142a9.png)

### 참조형 반환타입
![image](https://user-images.githubusercontent.com/101965836/164895802-b02ee9fc-3e32-4cf1-9bb3-46bbefe44967.png)  

## 6-26 ~ 29 static 메서드 & 인스턴스 메서드

|인스턴스 메서드 | static 메서드 |
|--------------|---------------|
|인스턴스 변수 사용 가능|인스턴스 변수 사용 불가|
|참조변수.메서드이름()|클래스이름.메서드이름()|

static 메서드는 instance variable을 사용하지 않을 때 쓴다. 딱 이 차이밖에 없다. 메서드 안에서 iv를 써야하면 인스턴스 메서드로 만들어야 하고, iv를 안 쓰면 static으로 만들어도 된다.  

### static 메서드는 인스턴스 변수(iv)를 사용할 수 없다
왜?  
static 메서드는 객체가 생성되지 않았을 때도 사용이 가능하다 ex. Math.random()  
근데 만약, 객체를 생성하지 않은 채로 static 메서드에서 인스턴스 변수를 사용한다면?  
인스턴스 변수가 아직 초기화 되지 않았는데, 인스턴스 변수를 갖고와야 하기 때문에 에러가 난다.  
따라서 인스턴스 변수는 static 메서드에서 사용될 수 없다.  
매개변수로 값을 받아와서 사용하거나 static 변수를 사용하는 메서드로만 만들어야 한다.   

### 메서드간 호출과 참조
인스턴스 메서드에서는 다른 인스턴스 메서드나 static 메서드를 호출 할 수 있다.  
다른 인스턴스 메서드는 객체를 생성할 때 같이 생성 됐기 때문이다. static 메서드는 어차피 항상 호출 가능한 메서드이므로 문제없다.  
   
반면 static 메서드는 인스턴스 메서드를 호출할 수 없다. 당연히 인스턴스가 선언되지 않은 경우에 에러가 나기 때문이다.  

### 정리
1. static 메서드에서 static 메서드 호출 => O
2. static 메서드에서 인스턴스 변수 사용 => X
3. static 메서드에서 인스턴스 메서드 호출 => X


## 6-30,31 메서드 오버로딩(overloading)
같은 이름의 메서드를 여러 개 정의하는 것  
![image](https://user-images.githubusercontent.com/101965836/164896354-a060e56c-53a9-4e33-9660-2a292949fa1e.png)  

### 오버로딩 성립 조건
1. 메서드 이름이 같아야 함
2. 매개변수 개수 또는 타입이 달라야 함

**반환 타입은 상관없음**  
예를 들어, 
```
int add(int a, int b) { return a+b; }
long add(int a, int b) { return (long)(a+b); }
```
이 경우 반환 타입은 상관 없으므로 오버로딩이 정의되지 않는다.  
왜? 호출 될 때 myClass.add(10,20); 으로 호출 될 텐데, 언제 int 반환 타입으로 쓸지 long 반환 타입으로 쓸 지 모호하기 때문이다.  

## 6-32~35 생성자, 기본 생성자
### 생성자
생성자는 이름이 클래스 이름과 같아야 한다  
생성자도 오버로딩 가능  
```
class Card {
  Card() {
  
  }
  Card(String kind, int number){
  
  }
}
```


### 기본 생성자 (= 매개변수가 없는 생성자)
```
Card c = new Card()
```

생성자가 하나도 없을 때만 컴파일러가 기본 생성자를 자동으로 추가한다.  
반대로 생성자가 한 개라도 있을 경우, 기본 생성자 Card() 같은 식으로 만들어 놓지 않고서 기본 생성자 처럼 호출하면 에러가 난다  
```
// 에러나는 경우
class Card {
  String kind;
  Card(String k){
    kind = k;
  }
}
...
  
  // Card c = new Card(); //에러
  
```

### 매개변수가 있는 생성자

## 6-36,37 생성자 this() 참조변수 this
### 생성자 this()
생성자에서 다른 생성자 호출할 때 사용한다
![image](https://user-images.githubusercontent.com/101965836/164897622-1ebbffee-9ebb-450b-afa2-a16ed05ad743.png)  

**반드시! 생성자 호출시 첫 줄에서만 사용가능**

```
Car(String color) {
  door = 5; // (1) 첫 줄에 this()를 쓰지 않아서 에러!
  Car(color, "auto", 4); // (2) this()라고 쓰지 않고 클래스이름()으로 써서 에러!
}
```

### 참조변수 this
생성자 this()랑은 관련 없음  
  
  
- 인스턴스 자신을 가리키는 참조변수
- 인스턴스 메서드에서 사용 가능 + 생성자에서도 사용 가능
- 지역변수(lv)와 인스턴스 변수(iv)를 구별할 때 사용  

## 6-38~41 변수 초기화, 멤버변수 초기화
### 1. 명시적 초기화 (=)
```
class Car {
  int door = 4;             // 기본형 변수의 초기화 (primitive type)  
  Engine e = new Engine();  // 참조형 변수의 초기화 (reference type)  
  ...
}
```
참조형 변수는 기본은 null 값을 가지므로, 객체 주소 값을 갖도록 초기화 해줘야 한다.   
Engine e; 라고만 해버리면 null 값을 갖게 된다.  

### 2. 초기화 블럭
복잡한 초기화에서 사용한다. 괄호 안에 여러 문장을 넣을 수 있다.  
- 인스턴스 초기화 블럭 : { }  
- 클래스 초기화 블럭 : static { }  

### 3. 생성자  
iv 초기화에 사용. 복잡한 초기화에 사용.  

  
정리하면  
1. 자동초기화
2. 간단초기화
3. 복잡초기화  

### 멤버변수의 초기화
클래스 변수 초기화 시점 : 클래스가 처음 로딩될 때 단 한번(메모리에 올라갈 때)  
인스턴스 변수 초기화 시점 : 인스턴스가 생성될 때 마다
  
