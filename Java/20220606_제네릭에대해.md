[참고](https://vvshinevv.tistory.com/54?category=692309)  
  
[참고2 - super 설명 좋음](https://velog.io/@kasania/Java-Generic%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B4%80%EC%B0%B0-2)  
[참고3 - \<T extends Comparable\<? super T\> 설명 좋음](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=zxwnstn&logNo=221550689930)  

[1. 3달차에 쓴 내용](https://github.com/PhysicksKim/TIL/blob/main/Java/20220606_%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%97%90%EB%8C%80%ED%95%B4.md#1%EF%B8%8F%E2%83%A3-3%EB%8B%AC%EC%B0%A8%EC%97%90-%EC%93%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%97%90-%EB%8C%80%ED%95%B4)  
[2. 6달차에 쓴 내용](https://github.com/PhysicksKim/TIL/blob/main/Java/20220606_%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%97%90%EB%8C%80%ED%95%B4.md#2%EF%B8%8F%E2%83%A3-6%EB%8B%AC%EC%B0%A8%EC%97%90-%EC%93%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%97%90-%EB%8C%80%ED%95%B4)  
[3. 7달차에 쓴 내용](https://github.com/PhysicksKim/TIL/blob/main/Java/20220606_%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%97%90%EB%8C%80%ED%95%B4.md#3%EF%B8%8F%E2%83%A3-7%EB%8B%AC%EC%B0%A8%EC%97%90-%EC%93%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%97%90-%EB%8C%80%ED%95%B4)  
  
---

# 1️⃣ 3달차에 쓴 제네릭에 대해 

---

### 발단
이 글을 쓴 계기는  
Java의 정석 기초편에서 제네릭 관련 문제를 풀다가    
제네릭 메서드를 근데 왜 쓰는거지에 대해서 의문이 들었고,  
검색해보다보니 생각보다 제네릭이 심오하단걸 알게 됐다.  
  
그리고 결론부터 말하자면 아직도 모르겠다.   
일단 제네릭이 처음부터 등장하지 않은 이유가 뭐겠는가?  
선대의 프로그래머들이 기존의 자바 문법과 객체 지향을 활용한 코딩으로는 뭔가 한계라던가 불편함을 느껴서이다.  
근데 그 수많은 시행착오와 경험을 고작 블로그 글 몇 개 읽어본다고  
한방에 빡하고 공감하고 이해할 수 있을리 만무하다.  
  
제네릭의 깊은 의미를 아직은 진정으로 이해하기 힘들다.
제네릭을 깊게 파고들면 어느 순간 왜? 라는 물음에 더이상 답변이 힘들다.   
그러므로 일단은, 이런것들이 있구나, 이런 문제에 답하기 위해서 등장했구나 라는 얕은 선에서 이해하고 넘어가두는게 맞는 것 같다.  
아직은 아키텍처에 대해 심도깊게 고민하는 단계가 아니라  
그냥 프레임워크 겨우 다루고 기초 문법도 가끔 구멍이 생겨서 빌빌대는 수준이니까.  


# 제네릭은 생각보다 복잡하다  

그냥 **"제네릭을 왜 쓰나요?"** 라는 질문에   
1. 컴파일 시점에 타입 체크
2. 타입 변환 불필요  
라고 단순히 말할 수 있다  
  
물론 맞는 말이다   
  
  
### 아주 처음 알게되는 제네릭  
```java
public void myMethod1(Object obj) {
  if (obj instanceof MyClass) {
    ...
  }
}
```
이런식으로 Object로 다형성 살려서 프로그래밍 해도, 기능적으로는 뭐 문제 없겠지만   
```java
public <T> void myMethod1(T paramT) {
  ...
}
```
그냥 이렇게 깔끔하게 바뀔 수 있으니 제네릭을 쓴다   
  
라는 말이 틀린건 아니다.  
  
  
## 하지만, 더 심오한 부분이 있다  
- Raw Type - Generic 관계와 형변환  
- Generic 상속  
- 제네릭 메소드와 와일드 카드  
- 와일드카드의 상한/하한 제한  
- 제네릭의 오버로딩  
- 상한/하한 제한을 활용한 예시 (예.sort() 메서드)

Generice을 왜 쓰나요 라는 물음에 대해서는     
결국 제네릭이 어떻게 발전했는지, 왜 등장했는지 좀 더 심오하게 이해해야 할 것 같다.  
  
이펙티브 자바 같이   
어떻게 코딩해야 하는 가에 대해서 고찰하는 서적들을 통해서  
왜 제네릭을 사용하는지에 대해 좀 더 오래 진득하게 고민해봐야 할 것 같다.  
  
## 그래서 제네릭이 뭔데  

면접관이 질문하는 상상을 해보자  
1. "제네릭이 뭔가요?"  
2. "제네릭을 왜 쓰나요?"  
3. "제네릭 말고 그냥 Object로 써서 다형성으로 코딩하면 안되나요?"  
4. "제네릭을 써서 문제를 해결해본 적이 있나요?"
5. "ArrayList는 왜 제네릭을 쓸까요?"

너무도 많은 질문이 꼬리를 물고 늘어진다  
  
### 질문이 길어진다 -> 심오한 분야이다  
제네릭은 좀 심오한 것 같다.  
한번 딱 검색해서 쓱 읽어보고 알고 땡 치는게 아니라  
코딩 경험이 쌓이고 문제에 직면하면서  
"이럴때 제네릭을 쓰면 어떨까?"  
라고 떠오르고, 제네릭으로 마침내 해결했을 때  
그제서야 심오함에 대해서 좀 더 공감할 수 있다고 생각한다.  
  
## 결론은  
앞서서 나열한 질문과 심오한 부분들에 대해서  
일단 그런게 있구나 알아두자.  
알아두면 언젠가 다시 돌아와서  
아 그때 그거! 라고 깨닫고 쓰게 될 날이 오겠지  

<br><br><br><br><br>  
  
---  
  
# 2️⃣ 6달차에 쓴 제네릭에 대해 
  
---  
  
# 다시 문서를 쓰게 된 계기
Heap 자료구조를 활용한 효율적인 Dijkstra 알고리즘 공부 중,  
공부삼아 Heap 자료 구조를 직접 구현해보다가  
Comparator\<? super E> 같은 코드를 봤다.  
위에서 보듯 이전에 어물쩡 넘어가버려서  
"제네릭이랑 와일드카드가 뭐더라?" 라는 생각이 들어 다시 공부를 했고,  
이전과 다르게 좀 이해가 가서 메모겸 글을 남긴다  
  
<br><br><br>  

# 먼저 머리에 박아놓고 들어가야 하는 내용  
Generic과 Wildcard가 막 복잡하고 이거 왜 쓰는거야 골머리 싸맸는데  
결론은  
### 컴파일 타임에서 에러 검사  
를 위한 내용이다.  
  
## 컴파일 타임에서 에러 검사  
처음에 드는 생각은  
"그냥 Object 로 다형성 활용해서 어찌저찌 구현하면 똑같이 동작하지 않을까?" 이다.  
맞다. 사실 컴파일 후 바이트 코드를 보면, 똑같이 Object로 구현되어 있다.  
  
그럼 뭐 때문에 Generic과 Wildcard를 쓸까?  
Object로 쓰면 컴파일 타임에서 타입 검사를 할 수 없다는 점 때문이다.    
  
예를 들어    
Integer만 받는 List를 만들었다고 해보자. 이름은 intList.  
그럼 intList.add() 메서드는 Integer만 받아야 한다.   
하지만 List 자체는 Integer 뿐만 아니라 모든 객체를 담을 수 있도록 만들어 졌기 때문에  
add(Object obj) 로 매개변수가 선언되어있다.   
따라서 list 자체에서 타입 검사가 안된다.  
하지만 List\<Integer> 라고 제네릭을 사용했다면  
add(E e) 라고 되어 있던게 add(Integer e) 가 되면서  
타입 검사가 이루어 질 수 있다.  
  
정리하면  
제네릭을 쓰면 컴파일 시점에서 타입 검사가 딱 이뤄진다.  
반면 Object를 쓰면, 컴파일 타임에서 타입 검사가 이뤄질 수 없다.  
또 컴파일 후에는 제네릭이 해당 타입으로 바뀌게 된다.  

<br><br><br>
  
# Generic 과 WildCard 구분  
- Generic : \<T\> 
- WildCard : \<?\>

Generic과 WildCard의 차이점은  
Generic은 해당 Type이 갖는 특성(ex.그 타입에 있는 메서드)을 사용할 수 있고    
WildCard는 해당 Type이 갖는 특성을 쓸 수 없다  
  
예를들면  

```java
class TestWildCard {

  // ? 와일드카드 사용
  public void getWildcard(List<?> list) {
    list.add(list.get(0)); // 여기서 컴파일 에러 발생  
  }

  // T 타입매개변수 사용
  public <T> void getTypeParam(List<T> list) {
    list.add(list.get(0));
  }
}
```
위 코드를 컴파일하면 와일드카드쪽에서 에러가 난다  
  
이는 get부분에서 에러가 아니라, add 부분에서 에러이다.  
왜인가 보자.  
  
list.get(0)을 하면, 뭐 어찌됐건 아무거나 튀어나올거다.  
일단은 get()의 경우 Object 타입으로 받든지 할 수 있다.  
  
하지만 add는 아무거나 넣을 수 없다.  
예를 들어 List\<Double> list 에다가  
Number num 이라는 애도 못 넣을거고  
Integer val 이라는 애도 못 넣을거다.  
(상속 관계에서 어쩌고 저쩌고는 뒤에서 super extends 이야기 할 때 다룰거다)  
  
다르게 말하면  
T로 받았으면  
```java
T val = new T();
list.add(val);
```
라고 적었을 시 **컴파일러**가 이를 보고  
"타입 문제 없네" 하고 넘어갈 수 있다  
  
하지만 **? 와일드카드** 로 받았다면   
```java
// ? val = new ?(); // 이런 코드는 불가능  
list.add(val);
```
와일드카드는 특정 타입 정보를 담은게 아니라서  
? val = new ?(); 같은 코드가 불가능하다.  
마찬가지로 list.add(...) 할려면  
컴파일러 입장에서는 컴파일 할 때 add(...) 매개변수에다가 타입 검사가 들어가야되는데  
?로 갖고왔으니 타입 검사를 할 수 없다.  
따라서 와일드카드는 add시에 에러가 나는 것이다.  

<br><br><br><br><br>  
  
---  
  
# 3️⃣ 7달차에 쓴 제네릭에 대해 
  
---  
  
이전과 다르다.  
좀 명확해진 것 같다.  
  
이 문서 제일 상단에 출처 링크 내용에서  
제일 중요한데 이전에는 대수롭지 않게 여겼던 부분이 있다  
바로 **제네릭 클래스간의 다형성** 부분이다  
  
  <br>  
  
### 간단한 OX 퀴즈  
  
```java
// 1.
List<String> strList = new List<>();

// 2.
List<Integer> intList = new List<>();

// 3.
List<Object> objList = new List<>();
```

<br>
  
a. strList = intList 로 바꿀 수 있을까?  
b. strList = objList 로 바꿀 수 있을까?  
  
<br>
 
String 과 Integer는 당연히 상속관계가 없으니 안될것이 자명하다   
그치만 Object - String 은 상속관계니까  
혹시 List\<String\> strList = new List\<Object\>();
가 될 수 있지 않을까?  
  
정답은 a, b 둘다 ❌  
  
<br>  
  
Object 참조 변수가 String 객체를 가리킬 수는 있지만  
List\<Object\> 참조 변수가 List\<String\> 객체를 가리킬 수는 없다  
  
<br>  
  
이게 매우 당연해 보일 수 있지만     
**왜 그럴까?** 생각해볼 필요가 있다  
  
<br><br>    
  
### 제네릭 클래스간 가변성  
먼저 앞서서는 간단히 "다형성" 이라고 말했지만  
이는 엄밀히는 틀린 말이다  
  
---
  
- **다형성**   
Object - Number - Integer 같이 상속관계로 이어질 때  
Object로 Integer 객체를 가리킬 수 있다는 것을  
다형성이라고 한다  
  
- **가변성**  
타입 A 와 타입 B 가 있을 때  
A를 B로 변환할 수 있는가에 대한 이야기다  
앞서 본 List\<Object\> 와 List\<Number\> 에 대해 이야기하면  
List\<Number\> 를 List\<Object\> 로 변환할 수 없다(반대의 경우도 마찬가지)    
이렇게 변환할 수 없는 것을 **불공변(invariant)** 이라고 한다  
  
---
  
<br><br>  
  
위와 같이 다형성과 가변성의 차이가 있다  
  
> # List 안에 요소를 넣는것에는 다형성이 적용된다   
> 예를 들어 List\<Number\> 에다가   
> Number 객체를 넣을 수도 있고   
> Integer , Double 객체도 넣을 수 있다   
>    
> 반면, List\<Number\> 와 List\<Integer\> 끼리는 다형성도 적용 안되고 형변환도 안된다   
> ![image](https://user-images.githubusercontent.com/101965836/198885037-357feec2-6395-40a7-8ce9-1405d3db3a00.png)  
> 이렇게 안된다고 에러가 난다  
>   
> 형변환도  
> ![image](https://user-images.githubusercontent.com/101965836/198885154-7e855803-fb1d-4403-b256-14b9cce8319e.png)  
> 위에서 볼 수 있듯 불가능하다  
> 가변성 측면에서 불공변임을 이를 통해 확인할 수 있다  
  
<br><br><br>  
  
## 그래서 가변성이 뭔 상관인가?  
가변성에 대해 이해해야지   
다음에 배울 와일드카드(Box\<?\> 에서 볼 수 있는 ? 를 와일드카드라 함) 에 대해서 이해할 수 있다    

> 와일드카드를 이해해야하는 이유는 당연히 제네릭을 이해하기 위해서다   
  
<br><br><br>  
  
---
    
### 와일드카드 전에...
  
<br>
  
# 형식 제한의 필요성  
  
```java
class Box<T> {

    protected T t;

    public Box() {}

    public T out() {
        return t;
    }

    public void in(T t) {
        this.t = t;
    }
}
```
예시를 위해 간단히 Box라는 클래스를 만들었다  
Box에 제네릭으로 특정 타입 객체를 넣을 수 있다  
  
이제 이 Box 클래스를 다루는 BoxHandler를 만들 때 문제가 발생한다  

<br><br>  

## 그냥 BoxHandler
```java
class BoxHandler {
    public BoxHandler() {}

    public <T> void set(Box<T> box, T t) {
        box.in(t);
    }

    public <T> void out(Box<T> box) {
        T t = box.out();
    }
}
```
위와 같이 제네릭으로 타입 T에 대한 **그냥 BoxHandler**를 만들었다  
이름이 **그냥 BoxHandler** 인 이유는  
BoxHandler가 **실질적으로는 아무것도 못하기** 때문이다  
  
<br><br>
  
### 예를 들어  
동물을 묘사한 Animal 객체가 들어있는 Box\<Animal\> 이 들어왔다면  
해당 Animal을 박스에서 꺼내서 Animal.speak() 같은 메소드를 실행하고 싶을 수 있다  
  
하지만 그냥 T라고 적으면...  
아무것도 못한다.  
  
왜냐하면 여기에 Box 제네릭 안에 Animal 이 들어올지 Integer가 들어올지 모르기 때문이다  
물론 어찌저찌 Animal이 들어왔는지 검사하고 Animal이면 Animal.speak()를 실행하고 하는 식으로 메서드를 구현할 수 있겠지만  
그럴바엔 그냥 옛날코드처럼 다형성을 이용하거나 그냥 매서드 오버로딩을 사용하는게 더 좋아보인다.  
  
<br><br>
  
## 따라서 형식제한이 필요성이 등장한다
만약 **T가 적어도 .speak() 메서드를 갖고 있다** 는 식으로 형식을 제한한다면  
익숙하게 써온 다형성을 활용해 (Animal animal) 로 매개변수를 받아오는 방식처럼  
제네릭에서도 동일하게 사용할 수 있을거다  
  
### 특정 타입만 제네릭으로 들어오도록 하고 싶어서 형식제한이 필요하다  
왜 특정 타입만? -> 특정 타입들이 갖는 메서드를 사용하고 싶어서  
  
> 사실 메서드 외에도 다른 이유가 있을거다. 
> Python 같은 언어랑 다르게 Java가 타입을 엄밀히 사용하는 이유가 무엇이겠는가?  
> 당연히 타입이 갖는 장점이 있어서이다  
>   
> 마찬가지로 타입 제한도 타입이 갖는 장점을 얻기 위해서 사용하는거다  
> 다만 타입이 갖는 장점에 대해 논하면 글이 길어지니까  
> 그냥 대표적으로 하나인 다형성의 장점을 토대로 제네릭 타입 제한을 설명해나갈거고  
> 다형성을 더 쉽게 풀어서, "공통적으로 .speak() 메서드를 갖고 있다" "적어도 .spaek() 메서드를 갖고 있다" 같은 식으로 설명하려고 했다  
> 어쩌면 더 난해해보일 수 있지만, 나는 처음에 이런식으로 이해했어서 이렇게 설명한다  
