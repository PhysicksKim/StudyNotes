[참고](https://vvshinevv.tistory.com/54?category=692309)  

### 발단
이 글을 쓴 계기는  
Java의 정석 기초편에서 제네릭 관련 문제를 풀다가    
제네릭 메서드를 근데 왜 쓰는거지에 대해서 의문이 들었고,  
검색해보다보니 생각보다 제네릭이 심오하단걸 알게 됐다.  
  
그리고 결론부터 말하자면 아직도 모르겠다.   
일단 제네릭이 처음부터 등장하지 않은 이유가 뭐겠는가?  
선대의 프로그래머들이 기존의 자바 문법과 객체 지향을 활용한 코딩으로는 뭔가 한계라던가 불편함을 느껴서이다.  
근데 그 수많은 시행착오와 경험을 고작 블로그 글 몇 개 읽어본다고  
한방에 빡하고 공감하고 이해할 수 있을리 만무하다.  
  
제네릭의 깊은 의미를 아직은 진정으로 이해하기 힘들다.
제네릭을 깊게 파고들면 어느 순간 왜? 라는 물음에 더이상 답변이 힘들다.   
그러므로 일단은, 이런것들이 있구나, 이런 문제에 답하기 위해서 등장했구나 라는 얕은 선에서 이해하고 넘어가두는게 맞는 것 같다.  
아직은 아키텍처에 대해 심도깊게 고민하는 단계가 아니라  
그냥 프레임워크 겨우 다루고 기초 문법도 가끔 구멍이 생겨서 빌빌대는 수준이니까.  


# 제네릭은 생각보다 복잡하다  

그냥 **"제네릭을 왜 쓰나요?"** 라는 질문에   
1. 컴파일 시점에 타입 체크
2. 타입 변환 불필요  
라고 단순히 말할 수 있다  
  
물론 맞는 말이다   
  
  
### 아주 처음 알게되는 제네릭  
```java
public void myMethod1(Object obj) {
  if (obj instanceof MyClass) {
    ...
  }
}
```
이런식으로 Object로 다형성 살려서 프로그래밍 해도, 기능적으로는 뭐 문제 없겠지만   
```java
public <T> void myMethod1(T paramT) {
  ...
}
```
그냥 이렇게 깔끔하게 바뀔 수 있으니 제네릭을 쓴다   
  
라는 말이 틀린건 아니다.  
  
  
## 하지만, 더 심오한 부분이 있다  
- Raw Type - Generic 관계와 형변환  
- Generic 상속  
- 제네릭 메소드와 와일드 카드  
- 와일드카드의 상한/하한 제한  
- 제네릭의 오버로딩  
- 상한/하한 제한을 활용한 예시 (예.sort() 메서드)

Generice을 왜 쓰나요 라는 물음에 대해서는     
결국 제네릭이 어떻게 발전했는지, 왜 등장했는지 좀 더 심오하게 이해해야 할 것 같다.  
  
이펙티브 자바 같이   
어떻게 코딩해야 하는 가에 대해서 고찰하는 서적들을 통해서  
왜 제네릭을 사용하는지에 대해 좀 더 오래 진득하게 고민해봐야 할 것 같다.  
  
## 그래서 제네릭이 뭔데  

면접관이 질문하는 상상을 해보자  
1. "제네릭이 뭔가요?"  
2. "제네릭을 왜 쓰나요?"  
3. "제네릭 말고 그냥 Object로 써서 다형성으로 코딩하면 안되나요?"  
4. "제네릭을 써서 문제를 해결해본 적이 있나요?"
5. "ArrayList는 왜 제네릭을 쓸까요?"

너무도 많은 질문이 꼬리를 물고 늘어진다  
  
### 질문이 길어진다 -> 심오한 분야이다  
제네릭은 좀 심오한 것 같다.  
한번 딱 검색해서 쓱 읽어보고 알고 땡 치는게 아니라  
코딩 경험이 쌓이고 문제에 직면하면서  
"이럴때 제네릭을 쓰면 어떨까?"  
라고 떠오르고, 제네릭으로 마침내 해결했을 때  
그제서야 심오함에 대해서 좀 더 공감할 수 있다고 생각한다.  
  
## 결론은  
앞서서 나열한 질문과 심오한 부분들에 대해서  
일단 그런게 있구나 알아두자.  
알아두면 언젠가 다시 돌아와서  
아 그때 그거! 라고 깨닫고 쓰게 될 날이 오겠지  
